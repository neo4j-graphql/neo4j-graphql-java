package org.neo4j.graphql.translate

import org.neo4j.cypherdsl.core.*
import org.neo4j.graphql.*
import org.neo4j.graphql.domain.directives.AuthDirective
import org.neo4j.graphql.domain.fields.RelationField
import org.neo4j.graphql.handler.utils.ChainString
import org.neo4j.graphql.schema.model.inputs.connect_or_create.ConnectOrCreateFieldInput


fun createConnectOrCreate(
    input: ConnectOrCreateFieldInput.NodeConnectOrCreateFieldInput,
    startNode: Node,
    relationField: RelationField,
    refNode: org.neo4j.graphql.domain.Node,
    queryContext: QueryContext,
    schemaConfig: SchemaConfig,
    baseName: ChainString, // TODO inline / harmonize
): Statement {
    val paramPrefix = baseName.extend("param")

    val node = refNode.asCypherNode(queryContext)
        .named(queryContext.getNextVariable(baseName))

    val nodeWithProps = input.where?.node
        ?.map { (k, v) ->
            k.dbPropertyName to queryContext.getNextParam(paramPrefix, v)
        }
        ?.takeIf { it.isNotEmpty() }
        ?.let { node.withProperties(it.toMap()) }
        ?: node

    val onNodeCreationProperties = createSetProperties(
        node,
        input.onCreate?.node,
        Operation.CREATE,
        refNode,
        schemaConfig,
        queryContext,
        paramPrefix,
        extendParamWithName = false,
    ) {
        // include autogenerated fields (e.g. @id) only if field is not included in where
        input.where?.node?.containsKey(it) != true
    }

    val dslRelation = relationField.createDslRelation(startNode, node)
        .named(queryContext.getNextVariable(baseName.extend("this"))) // TODO can we name it just "edge"?
    val onEdgeCreationProperties = createSetProperties(
        dslRelation,
        input.onCreate?.edge,
        Operation.CREATE,
        relationField.properties,
        schemaConfig,
        queryContext,
        paramPrefix,
        extendParamWithName = false,
    ) {
        // include autogenerated fields (e.g. @id) only if field is not included in where
        input.where?.node?.containsKey(it) != true
    }

    val authCondition = AuthTranslator(
        schemaConfig, queryContext,
        allow = AuthTranslator.AuthOptions(node, refNode)
    )
        .createAuth(refNode.auth, AuthDirective.AuthOperation.CONNECT, AuthDirective.AuthOperation.CREATE)

    return Cypher
        .with(startNode)
        .merge(nodeWithProps)
        .conditionalBlock(onNodeCreationProperties != null) { it.onCreate().set(onNodeCreationProperties) }
        .merge(dslRelation)
        .conditionalBlock(onEdgeCreationProperties != null) { it.onCreate().set(onEdgeCreationProperties) }
        .apocValidateNew(authCondition, Constants.AUTH_FORBIDDEN_ERROR)
        .returning(Functions.count(Cypher.asterisk()).`as`("_"))
        .build()
}


// TODO inline
fun createConnectOrCreate(
    inputs: List<ConnectOrCreateFieldInput.NodeConnectOrCreateFieldInput>,
    parentVar: Node,
    relationField: RelationField,
    refNode: org.neo4j.graphql.domain.Node,
    withVars: List<SymbolicName>,
    exposeWith: ExposesWith,
    context: QueryContext,
    schemaConfig: SchemaConfig,
    baseName: ChainString = ChainString(schemaConfig, parentVar, relationField, "connectOrCreate")

): ExposesWith {

    val subQueries = inputs.map { input ->
        createConnectOrCreate(input, parentVar, relationField, refNode, context, schemaConfig, baseName)
    }

    return exposeWith
        .maybeWith(withVars)
        .withSubQueries(subQueries)
}
