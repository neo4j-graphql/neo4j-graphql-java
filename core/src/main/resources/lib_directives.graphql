"Instructs neo4j-graphql-java to map a GraphQL field to a Neo4j node or relationship property."
directive @alias(
  "The name of the Neo4j property"
  property:String!
) on FIELD_DEFINITION

directive @authentication(
  operations: [AuthenticationOperation!]! = [ CREATE, READ, AGGREGATE, UPDATE, DELETE, CREATE_RELATIONSHIP, DELETE_RELATIONSHIP, SUBSCRIBE ]
  jwt: JwtWhere
) on OBJECT | FIELD_DEFINITION | SCHEMA

directive @authorization(
  filter: [FilterRule!],
  validate: [ValidationRule!],
) on OBJECT | FIELD_DEFINITION

"Instructs neo4j-graphql-java to wrap the property in a coalesce() function during queries, using the single value specified."
directive @coalesce(
  "The value to use in the coalesce() function. Must be a scalar type and must match the type of the field with which this directive decorates."
  value: ScalarType!
) on FIELD_DEFINITION

"Informs neo4j-graphql-java that a field will be resolved by a custom resolver, and allows specification of any field dependencies."
directive @customResolver(
  "Fields that the custom resolver will depend on. These are passed as an object to the first argument of the custom resolver."
  requires: String
) on FIELD_DEFINITION

"Instructs neo4j-graphql-java to run the specified Cypher statement in order to resolve the value of the field to which the directive is applied."
directive @cypher(
  """The Cypher statement to run which returns a value of the same type composition as the field definition on which the directive is applied.

  Arguments on the field are passed to the Cypher statement and can be used by name.
  They must not be prefixed by `$` since they are no longer parameters.
  Just use the same name as the fields' argument.
  The current node is passed to the statement as `this`.
  The statement should contain exactly one return expression without any alias.
  Input types are supported, they appear as `Map` type in your Cypher statement."""
  statement: String!

  "Name of the returned variable from the Cypher statement."
  columnName: String!
) on FIELD_DEFINITION

"Instructs neo4j-graphql-java that any type that implements this interface must annotate this field with the `@relationship` directive. Allows for nested reading operations in the Interface top level query and opens up the ability to create and connect on this field."
directive @declareRelationship(
  "Prevent all but these operations from being generated for this relationship"
  nestedOperations: [RelationshipNestedOperations!]! = [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT, CONNECT_OR_CREATE]
  "Prevent aggregation for this relationship"
  aggregate: Boolean = true
) on FIELD_DEFINITION

"Instructs neo4j-graphql-java to set the specified value as the default value in the CreateInput type for the object type in which this directive is used."
directive @default(
  "The default value to use. Must be a scalar type and must match the type of the field with which this directive decorates."
  value: ScalarType!
) on FIELD_DEFINITION

"Instructs neo4j-graphql-java to generate filters for this field."
directive @filterable(
  "Generates filters for this field"
  byValue: Boolean! = true,
  "Generates filters for aggregate value based on this field"
  byAggregate: Boolean! = false,
) on FIELD_DEFINITION

"Informs neo4j-graphql-java that there should be a fulltext index in the database, allows users to search by the index in the generated schema."
directive @fulltext(indexes: [FullTextInput!]!) on OBJECT

"Enables the autogeneration of UUID values for an ID field. The field becomes immutable."
directive @id on FIELD_DEFINITION

"Instructs neo4j-graphql-java that the flagged field has a mapped path within the JWT Payload."
directive @jwtClaim(
  "The path of the field in the real JWT as mapped within the JWT Payload."
  path: String!
) on FIELD_DEFINITION

"Instructs neo4j-graphql-java that the flagged object represents the relevant JWT payload"
directive @jwt on OBJECT

"Instructs neo4j-graphql-java to inject limit values into a query."
directive @limit(
  "If no limit argument is supplied on query will fallback to this value."
  default: Int,
  "Maximum limit to be used for queries."
  max: Int
) on OBJECT | INTERFACE


"Instructs neo4j-graphql-java to exclude create, delete or update operations from the mutation root type."
directive @mutation(
  "Describe operations available for this type"
  operations: [MutationFields!]! = [ CREATE, UPDATE, DELETE ]
) on OBJECT | INTERFACE


"Informs neo4j-graphql-java of node metadata"
directive @node(
  "The labels to map this GraphQL type to in the Neo4j database",
  labels: [String!]
) on OBJECT

"Instructs neo4j-graphql-java to use the given value as the plural of the type name."
directive @plural(
  "The value to use as the plural of the type name."
  value: String!
) on OBJECT | INTERFACE | UNION

# TODO ?
"Instructs neo4j-graphql-java to invoke the specified callback function when updating or creating the properties on a node or relationship."
directive @populatedBy(
  "The name of the callback function that will be used to populate the fields values."
  callback: String!

  "Which events to invoke the callback on."
  operations: [PopulatedByOperation!]! = [CREATE, UPDATE]
) on FIELD_DEFINITION

# TODO remove?
"Instructs neo4j-graphql-java to only expose a field through the Neo4j GraphQL OGM."
directive @private on FIELD_DEFINITION

"Instructs neo4j-graphql-java to exclude read or aggregate operations from the query root type."
directive @query(
  "Disable/Enabled read operations from query root type"
  read: Boolean! = true
  "Disable/Enabled aggregate operations from query root type"
  aggregate: Boolean! = false
) on OBJECT | SCHEMA | INTERFACE | UNION

"Instructs neo4j-graphql-java to treat this field as a relationship. Opens up the ability to create and connect on this field."
directive @relationship(
  type:String!,
  "Valid and default directions for this relationship."
  queryDirection: RelationshipQueryDirection! = DEFAULT_DIRECTED,
  direction: RelationshipDirection!,
  "The name of the interface containing the properties for this relationship."
  properties: String
  "Prevent all but these operations from being generated for this relationship"
  nestedOperations: [RelationshipNestedOperations!]! = [CREATE, UPDATE, DELETE, CONNECT, DISCONNECT, CONNECT_OR_CREATE]
  "Prevent aggregation for this relationship"
  aggregate: Boolean! = true
) on FIELD_DEFINITION

"Required to differentiate between interfaces for relationship properties, and otherwise."
directive @relationshipProperties on INTERFACE

"Mark the field to be used as the global node identifier for Relay. This field will be backed by a unique node property constraint."
directive @relayId on FIELD_DEFINITION

"Instructs neo4j-graphql-java to generate this field for selectable types."
directive @selectable(
  "Generates this field on read and subscribe operations."
  onRead: Boolean! = true
  "Generates this field on aggregation operations."
  onAggregate: Boolean! = false
) on FIELD_DEFINITION

"Instructs neo4j-graphql-java to generate this field for mutation inputs."
directive @settable(
  "Generates this input field for create operations."
  onCreate: Boolean! = true
  "Generates this input field for update operations."
  onUpdate: Boolean! = true
) on FIELD_DEFINITION


"Define the granularity of events available in the subscription root type."
directive @subscription(
  "Enable/Disable subscription events for this type"
  events: [SubscriptionEventType!]! = [ CREATED,  UPDATED,  DELETED,  RELATIONSHIP_CREATED,  RELATIONSHIP_DELETED]
) on OBJECT | SCHEMA

"Instructs neo4j-graphql-java to generate timestamps on particular events, which will be available as the value of the specified field."
directive @timestamp(
  "Which events to generate timestamps on. Defaults to both create and update."
  operations: [TimeStampOperation!] = [CREATE, UPDATE]
) on FIELD_DEFINITION

"Informs neo4j-graphql-java that there should be a uniqueness constraint in the database for the decorated field."
directive @unique(
  "The name which should be used for this constraint. By default; type name, followed by an underscore, followed by the field name."
  constraintName: String
) on FIELD_DEFINITION

scalar Object

scalar ScalarType

scalar JwtWhere
scalar NodeWhere

enum RelationshipDirection {
  IN
  OUT
}

enum RelationshipQueryDirection {
  "All queries will be **directed** by default, but users may perform undirected queries."
  DEFAULT_DIRECTED
  "All queries will be **undirected** by default, but users may perform directed queries."
  DEFAULT_UNDIRECTED
  "Only directed queries can be perform on this relationship."
  DIRECTED_ONLY
  "Only undirected queries can be perform on this relationship."
  UNDIRECTED_ONLY
}



input AuthorizationWhere {
  AND: [AuthorizationWhere!]
  OR: [AuthorizationWhere!]
  NOT: AuthorizationWhere
  node: NodeWhere
  jwt: JwtWhere
}

enum AuthorizationFilterOperation {
  READ, AGGREGATE, UPDATE, DELETE, CREATE_RELATIONSHIP, DELETE_RELATIONSHIP
}

input FilterRule {
  operations: [AuthorizationFilterOperation!] = [ READ, AGGREGATE, UPDATE, DELETE, CREATE_RELATIONSHIP, DELETE_RELATIONSHIP ]
  requireAuthentication: Boolean! = true
  where: AuthorizationWhere
}

enum AuthorizationValidateOperation {
  CREATE, READ, AGGREGATE, UPDATE, DELETE, CREATE_RELATIONSHIP, DELETE_RELATIONSHIP
}

enum AuthorizationValidateStage {
  BEFORE, AFTER
}

input ValidationRule {
  operations: [AuthorizationValidateOperation!] = [ CREATE, READ, AGGREGATE, UPDATE, DELETE, CREATE_RELATIONSHIP, DELETE_RELATIONSHIP ]
  when: [AuthorizationValidateStage!] = [BEFORE, AFTER]
  requireAuthentication: Boolean! = true
  where: AuthorizationWhere
}

input FullTextInput {
  fields: [String!]!
  queryName: String
  indexName: String
}

"Limit options."
input LimitInput {
  "If no limit argument is supplied on query will fallback to this value."
  default: Int
  "Maximum limit to be used for queries."
  max: Int
}

enum AuthenticationOperation {
  CREATE, READ, AGGREGATE, UPDATE, DELETE, CREATE_RELATIONSHIP, DELETE_RELATIONSHIP, SUBSCRIBE
}

enum MutationFields {
  CREATE, UPDATE, DELETE
}

enum ExcludeOperation {
  CREATE, READ, UPDATE, DELETE, SUBSCRIBE
}

enum TimeStampOperation {
  CREATE, UPDATE
}

enum PopulatedByOperation {
  CREATE, UPDATE
}

enum RelationshipNestedOperations {
  CREATE, UPDATE, DELETE, CONNECT, DISCONNECT, CONNECT_OR_CREATE
}

enum SubscriptionEventType {
  CREATED,  UPDATED,  DELETED,  RELATIONSHIP_CREATED,  RELATIONSHIP_DELETED
}

# TODO renamed to alias
directive @property(name:String) on FIELD_DEFINITION

# TODO create feature request
directive @dynamic(prefix:String = "properties.") on FIELD_DEFINITION
