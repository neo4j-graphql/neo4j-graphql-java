package org.neo4j.graphql.tools

import org.neo4j.graphql.asciidoc.AsciiDocParser
import org.neo4j.graphql.asciidoc.ast.*
import org.neo4j.graphql.domain.CodeBlockPredicate
import org.neo4j.graphql.domain.TestCase
import org.neo4j.graphql.domain.TestCase.Setup
import org.neo4j.graphql.utils.Assertions
import org.neo4j.graphql.utils.CypherUtils
import org.neo4j.graphql.utils.JsonUtils
import org.neo4j.graphql.utils.JsonUtils.parseJson
import org.neo4j.graphql.utils.SchemaUtils
import org.neo4j.graphql.utils.TestUtils.IS_TEMPLATE
import org.neo4j.graphql.utils.TestUtils.IS_TEST_FILE
import org.neo4j.graphql.utils.TestUtils.TEST_RESOURCES
import java.io.BufferedReader
import java.io.InputStreamReader
import java.nio.file.Files
import java.nio.file.Path
import kotlin.reflect.KProperty1

object JsTestCaseSync : AsciidocReformater() {


    @JvmStatic
    fun main(args: Array<String>) {
        run()
    }

    override fun handleFile(file: Path) {
        if (IS_TEST_FILE.test(file)) {
            val templateFile = file.parent
                .resolve(file.fileName.toString().replace(Regex("\\.adoc$"), ".js.adoc"))
            if (!Files.exists(templateFile)) {
                println("Template file not found: $templateFile, deleting $file")
                Files.delete(file)
            }
            return
        }
        if (!IS_TEMPLATE.test(file)) {
            return
        }

        val currentSourceContent = Files.readString(file)
        val currentSourceDocument = AsciiDocParser(file).parseContent(currentSourceContent)

        val targetFilePath = file.parent
            .resolve(file.fileName.toString().replace(Regex("\\.js.adoc$"), ".adoc"))

        // if the test file does not exist, create it based on the template
        if (!Files.exists(targetFilePath)) {
            println("Test file not found: $file, creating it based on its template")

            val blocks = collectCodeBlocks(currentSourceDocument)
            for (block in blocks) {
                reformatBlock(block)
            }

            currentSourceDocument.blocks
                .filterIsInstance<Block>()
                .firstOrNull()?.let {
                    it.content = it.content.replace(
                        "// This file was generated by the Test-Case extractor of neo4j-graphql\n",
                        ""
                    )
                }
            writeDocument(currentSourceDocument, targetFilePath)
            return
        }

        // else compare the content of the test file with the template diff

        // execute `git show HEAD:file` to get the content of the file in the HEAD commit
        val previousSourceContent = runGitCommand("git show HEAD:core/$TEST_RESOURCES$file")
        if (previousSourceContent.isEmpty()) {
            println("File not found in HEAD: $file")
            return
        }

        if (previousSourceContent == currentSourceContent) {
            // nothing to do since the source (template) file has not changed
            return
        }


        println("File is outdated: $file")
        val previousSourceDocument = AsciiDocParser(file).parseContent(previousSourceContent)

        val targetDocument = AsciiDocParser(targetFilePath).parse()

        mergeSections(currentSourceDocument, previousSourceDocument, targetDocument)

        val blocks = collectCodeBlocks(targetDocument)
        for (block in blocks) {
            reformatBlock(block)
        }
        writeDocument(targetDocument, targetFilePath)
        writeDocument(currentSourceDocument, file)
    }

    private fun removeRedundantThematicBreaks(section: Section) {
        // remove ThematicBreaks that are followed by a Section or that are the last element in the section
        val iterator = section.blocks.asReversed().iterator()
        var hasFollowUpCodeBlock = false
        while (iterator.hasNext()) {
            val block = iterator.next()
            if (block is ThematicBreak) {
                if (!hasFollowUpCodeBlock) {
                    iterator.remove()
                }
            }
            if (block is CodeBlock || block is Table) {
                hasFollowUpCodeBlock = true
            }
            if (block is Section) {
                removeRedundantThematicBreaks(block)
                hasFollowUpCodeBlock = false
            }
        }
    }

    private fun mergeSections(currentSource: Section, previousSource: Section?, target: Section) {

        val currentSections = currentSource.blocks.filterIsInstance<Section>()
        val previousSections = previousSource?.blocks?.filterIsInstance<Section>() ?: emptyList()

        val sourceToTargetSectionMapping = mutableMapOf<Section, Section?>()
        val targetToSourceSectionMapping = mutableMapOf<Section, Section>()
        val iterator = target.blocks.iterator()
        while (iterator.hasNext()) {
            val targetSection = iterator.next() as? Section ?: continue
            val currentSection = currentSections
                .filterNot { sourceToTargetSectionMapping.contains(it) }
                .find { it.title == targetSection.title }
            targetToSourceSectionMapping[targetSection] = currentSource
            if (currentSection == null) {
                iterator.remove()
            } else {
                sourceToTargetSectionMapping[currentSection] = targetSection
                val previousSection = previousSections.find { it.title == targetSection.title }
                mergeSections(currentSection, previousSection, targetSection)
            }
        }

        var lastMatchedTargetSection: Section? = null
        for (currentSection in currentSections) {
            val targetSection = sourceToTargetSectionMapping[currentSection]
            if (targetSection == null) {
                val newSection = Section(currentSection.title, currentSection.uri, target)
                newSection.blocks.addAll(currentSection.blocks)
                target.addAfter(lastMatchedTargetSection, newSection)
            } else {
                lastMatchedTargetSection = targetSection
            }
        }

        if (previousSource != null) {
            sync(
                currentSource, previousSource, target, CodeBlockPredicate.TEST_DATA,
                { a, b -> a?.content == b?.content },
            )
            sync(
                currentSource, previousSource, target, CodeBlockPredicate.GRAPHQL_SOURCE_SCHEMA,
                { a, b -> a?.content == b?.content },
            )

            val currentTestCases = extractTestCases(currentSource)
            val previousTestCases = extractTestCases(previousSource)
            val targetTestCases = extractTestCases(target)

            val count = maxOf(currentTestCases.size, targetTestCases.size)
            for (i in 0 until count) {
                val currentTestCase = currentTestCases.getOrNull(i)
                val previousTestCase = previousTestCases.getOrNull(i)
                val targetTestCase = targetTestCases.getOrNull(i)

                syncTestCases(currentTestCase, previousTestCase, targetTestCase, target)
            }
        }
    }

    private fun syncTestCases(
        currentTestCase: TestCase?,
        previousTestCase: TestCase?,
        targetTestCase: TestCase?,
        target: Section
    ) {
        sync(
            currentTestCase, previousTestCase, targetTestCase,
            target,
            TestCase::queryConfig,
            { a, b -> a?.content == b?.content },
            JsonUtils::prettyPrintJson,
        )
        sync(
            currentTestCase, previousTestCase, targetTestCase,
            target,
            TestCase::graphqlRequest,
            { a, b -> a?.content == b?.content },
            insertPoint = targetTestCase?.queryConfig,
        )
        sync(
            currentTestCase, previousTestCase, targetTestCase,
            target,
            TestCase::graphqlRequestVariables,
            { a, b -> a?.content == b?.content },
            JsonUtils::prettyPrintJson,
            targetTestCase?.graphqlRequest,
        )
        sync(
            currentTestCase, previousTestCase, targetTestCase,
            target,
            TestCase::augmentedSchema,
            { a, b ->
                if (a == null || b == null) {
                    return@sync a == b
                }
                if (a.content == b.content) {
                    return@sync true
                }
                return@sync SchemaUtils.prettyPrintSchema(a.content) == SchemaUtils.prettyPrintSchema(b.content)
            },
            SchemaUtils::prettyPrintSchema,
        )
        syncCypher(currentTestCase, previousTestCase, targetTestCase, target)
        syncGraphqlResponse(currentTestCase, previousTestCase, targetTestCase, target)
    }

    private fun sync(
        currentSection: Section,
        previousSection: Section,
        targetSection: Section,
        predicate: CodeBlockPredicate,
        compartor: (CodeBlock?, CodeBlock?) -> Boolean,
        formatter: (String) -> String = { it },
        insertPoint: CodeBlock? = null
    ) = sync(
        currentSection.findSingleOrNullCodeBlock(predicate),
        previousSection.findSingleOrNullCodeBlock(predicate),
        targetSection.findSingleOrNullCodeBlock(predicate),
        targetSection, compartor, formatter, insertPoint
    )

    private fun sync(
        currentTestCase: TestCase?,
        previousTestCase: TestCase?,
        targetTestCase: TestCase?,
        targetSection: Section,
        prop: KProperty1<TestCase, CodeBlock?>,
        compartor: (CodeBlock?, CodeBlock?) -> Boolean,
        formatter: (String) -> String = { it },
        insertPoint: CodeBlock? = null
    ) = sync(
        currentTestCase?.let { prop(it) },
        previousTestCase?.let { prop(it) },
        targetTestCase?.let { prop(it) },
        targetSection, compartor, formatter, insertPoint
    )

    private fun sync(
        current: CodeBlock?,
        previous: CodeBlock?,
        target: CodeBlock?,
        targetSection: Section,
        compartor: (CodeBlock?, CodeBlock?) -> Boolean,
        formatter: (String) -> String = { it },
        insertPoint: CodeBlock? = null
    ) {
        if (current == null) {
            if (target != null) {
                targetSection.blocks.remove(target)
            }
            return
        }

        if (compartor(current, previous)) {
            // we have no diff between the current and the previous file, so nothing to update
            return
        }

        if (target != null) {
            // there is a diff in the target file, we can compare the content

            target.reformattedContent = formatter(current.content)
            return
        }

        val newTarget = CodeBlock(targetSection.uri, current.language, targetSection, current.attributes)
            .also {
                it.caption = current.caption
                it.content = formatter(current.content)
            }
        targetSection.addAfter(insertPoint, newTarget)
    }

    private fun syncCypher(
        currentTestCase: TestCase?,
        previousTestCase: TestCase?,
        targetTestCase: TestCase?,
        targetSection: Section
    ) {
        val currentCypher = currentTestCase?.cypher
        val previousCypher = previousTestCase?.cypher
        var targetCypher = targetTestCase?.cypher

        val currentCypherParams = currentTestCase?.cypherParams
        val previousCypherParams = previousTestCase?.cypherParams
        var targetCypherParams = targetTestCase?.cypherParams

        if (currentCypher == null) {
            if (targetCypher != null) {
                targetSection.blocks.remove(targetCypher)
            }
            if (targetCypherParams != null) {
                targetSection.blocks.remove(targetCypherParams)
            }
            return
        }

        if (currentCypher.content == previousCypher?.content && currentCypherParams?.content == previousCypherParams?.content) {
            // we have no diff between the current and the previous file, so nothing to update
            return
        }

        if (targetCypher != null) {
            if (currentCypher.content != previousCypher?.content) {
                // we need to update the target file
                targetCypher.reformattedContent = CypherUtils.prettyPrintCypher(currentCypher.content)
            }
        } else {
            if (targetTestCase?.graphqlResponse != null || targetTestCase?.graphqlResponseAssertions != null) {
                // we have an integration test, where the cypher check was deleted, so keep the cypher deleted
                return
            }
            targetCypher = CodeBlock(targetSection.uri, currentCypher.language, targetSection, currentCypher.attributes)
                .also {
                    it.caption = currentCypher.caption
                    it.content = CypherUtils.prettyPrintCypher(currentCypher.content)
                }
            targetSection.addAfter(targetTestCase?.graphqlResponse, targetCypher)
        }

        if (currentCypherParams != null) {
            if (targetCypherParams != null) {
                if (currentCypherParams.content != previousCypherParams?.content) {
                    // we need to update the target file
                    targetCypherParams.reformattedContent = JsonUtils.prettyPrintJson(currentCypherParams.content)
                }
            } else {
                targetCypherParams =
                    CodeBlock(
                        targetSection.uri,
                        currentCypherParams.language,
                        targetSection,
                        currentCypherParams.attributes
                    )
                        .also {
                            it.caption = currentCypherParams.caption
                            it.content = JsonUtils.prettyPrintJson(currentCypherParams.content)
                        }
                targetSection.addAfter(targetCypher, targetCypherParams)
            }
        }
    }

    private fun syncGraphqlResponse(
        currentTestCase: TestCase?,
        previousTestCase: TestCase?,
        targetTestCase: TestCase?,
        targetSection: Section
    ) {
        val currentResponse = currentTestCase?.graphqlResponse
        val previousResponse = previousTestCase?.graphqlResponse
        val targetResponse = targetTestCase?.graphqlResponse
        val targetResponseAssertions = targetTestCase?.graphqlResponseAssertions

        if (currentResponse == null) {
            if (targetResponse != null) {
                targetSection.blocks.remove(targetResponse)
            }
            if (targetResponseAssertions != null) {
                targetSection.blocks.remove(targetResponseAssertions)
            }
            return
        }

        if (currentResponse.content == previousResponse?.content) {
            // we have no diff between the current and the previous file, so nothing to update
            return
        }

        if (targetResponse != null) {
            // there is a response in the target file, we can compare the content

            if (targetResponse.attributes.containsKey("ignore-order")) {
                // check for equality ignoring the order

                val expected = parseJson<Map<String, Any?>>(currentResponse.content)
                val actual = parseJson<Map<String, Any?>>(targetResponse.content)

                try {
                    Assertions.assertEqualIgnoreOrder(expected, actual)

                    // if the content is equal, we can use the previous content to prevent cahnges in the template
                    currentResponse.reformattedContent = previousResponse?.content
                    return
                } catch (ignore: AssertionError) {
                    // handled below
                }
            }

            // we need to update the target file
            targetResponse.reformattedContent = JsonUtils.prettyPrintJson(currentResponse.content)
            return
        }

        if (targetResponseAssertions != null) {
            // we remove the direct content validation and added some JsonPath assertions
            try {
                val expected = parseJson<Map<String, Any?>>(currentResponse.content)
                Assertions.assertWithJsonPath(targetResponseAssertions, expected)

                // if the assertions matches with the current content, we can use the previous content
                currentResponse.reformattedContent = previousResponse?.content
            } catch (e: AssertionError) {
                // otherwise we need to update the target file
                targetSection.addAfter(targetResponseAssertions, currentResponse)
            }
            return
        }

        TODO("target file does not contain a response assertions")
    }

    private fun extractTestCases(section: Section): List<TestCase> {
        val tests = mutableListOf<TestCase>()
        val setup = Setup(section)
        var testCase = TestCase(setup).also { tests += it }
        for (node in section.blocks) {
            when (node) {
                is CodeBlock -> testCase.parseCodeBlock(node)
                is Table -> testCase.parseTable(node)
                is ThematicBreak -> testCase = TestCase(setup).also { tests += it }
                is Block, is Section -> {
                    // ignore
                }
            }
        }
        return tests.filter {
            it.setup.schema != null && (it.graphqlRequest != null || it.augmentedSchema != null)
        }
    }

    private fun runGitCommand(command: String): String {
        val processBuilder = ProcessBuilder(command.split(" "))
        processBuilder.redirectErrorStream(true)
        val process = processBuilder.start()
        val result = StringBuilder()
        BufferedReader(InputStreamReader(process.inputStream)).use { reader ->
            var line: String?
            while (reader.readLine().also { line = it } != null) {
                result.append(line).append("\n")
            }
        }
        process.waitFor()
        return result.toString()
    }

}
