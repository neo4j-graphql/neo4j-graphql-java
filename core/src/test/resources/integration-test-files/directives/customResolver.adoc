:toc:
:toclevels: 42

== @customResolver directive

=== Scalar fields

==== Setup

.Schema
[source,graphql,schema=true]
----
type User {
  id: ID!
  firstName: String!
  lastName: String!
  fullName: String @customResolver(requires: "firstName lastName")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user:User) SET user = {id: "An-ID", firstName: "someFirstName", lastName: "a second name!"}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ScalarFieldCustomResolver.kt[]
----

==== removes a field from all but its object type, and resolves with a custom resolver

.GraphQL-Query
[source,graphql,request=true]
----
query User($userId: ID!) {
  users(where: {id: $userId}) {
    id
    firstName
    lastName
    fullName
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "userId" : "An-ID"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "An-ID"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
RETURN this {
	.id,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "id" : "An-ID",
    "firstName" : "someFirstName",
    "lastName" : "a second name!",
    "fullName" : "someFirstName a second name!"
  } ]
}
----

==== resolves field with custom resolver without required fields in selection set

.GraphQL-Query
[source,graphql,request=true]
----
query User($userId: ID!) {
  users(where: {id: $userId}) {
    id
    fullName
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "userId" : "An-ID"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "An-ID"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
RETURN this {
	.id,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "id" : "An-ID",
    "fullName" : "someFirstName a second name!"
  } ]
}
----

==== resolves field with custom resolver with required field(s) aliased in selection set

.GraphQL-Query
[source,graphql,request=true]
----
query User($userId: ID!) {
  users(where: {id: $userId}) {
    id
    f: firstName
    fullName
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "userId" : "An-ID"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "An-ID"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
RETURN this {
	.id,
	f: this.firstName,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "id" : "An-ID",
    "f" : "someFirstName",
    "fullName" : "someFirstName a second name!"
  } ]
}
----

== Related Fields

=== should be able to require a field from a related type

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user:User)-[:LIVES_AT]->(addr:Address) SET user = {id: "1", firstName: "First", lastName: "Last"}, addr = {city: "some city", street: "some street"}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver.kt[]
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	WITH address0 {
		.city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	.firstName,
	.lastName,
	address: address
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "fullName" : "First Last from some city"
  } ]
}
----

=== should fetch required fields when other fields are also selected

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user:User)-[:LIVES_AT]->(addr:Address) SET user = {id: "1", firstName: "First", lastName: "Last"}, addr = {city: "some city", street: "some street"}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver.kt[]
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    id
    fullName
    address {
      street
      city
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	WITH address0 {
		.street,
		.city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	.id,
	address: address,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "id" : "1",
    "fullName" : "First Last from some city",
    "address" : {
      "street" : "some street",
      "city" : "some city"
    }
  } ]
}
----

=== should fetch customResolver fields over multiple users

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address) SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address) SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver.kt[]
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    id
    fullName
    address {
      street
      city
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	WITH address0 {
		.street,
		.city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	.id,
	address: address,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "users" : [ {
    "id" : "1",
    "fullName" : "First Last from some city",
    "address" : {
      "street" : "some street",
      "city" : "some city"
    }
  }, {
    "id" : "2",
    "fullName" : "New First new-last from another-city",
    "address" : {
      "street" : "another-street",
      "city" : "another-city"
    }
  } ]
}
----

=== should select related fields when not selected last

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName address { city } lastName")
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address) SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address) SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    id
    fullName
    address {
      street
      city
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	WITH address0 {
		.street,
		.city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	.id,
	address: address,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "users" : [ {
    "id" : "1",
    "fullName" : "First Last from some city",
    "address" : {
      "street" : "some street",
      "city" : "some city"
    }
  }, {
    "id" : "2",
    "fullName" : "New First new-last from another-city",
    "address" : {
      "street" : "another-street",
      "city" : "another-city"
    }
  } ]
}
----

=== should select fields from double nested related nodes

.Schema
[source,graphql,schema=true]
----
type City {
  name: String!
  population: Int
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name population } }")
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver2.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address)-[:IN_CITY]->(city1:City)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}, city1 = {name: "city1 name!", population: 8947975}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address)-[:IN_CITY]->(city2:City)
 SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}, city2 = {name: "city2 name?", population: 74}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    fullName
    address {
      street
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	CALL {
		WITH address0
		MATCH (address0)-[inCity0:IN_CITY]->(city0:City)
		WITH city0 {
			.name,
			.population
		} AS city
		RETURN head(collect(city)) AS city
	}
	WITH address0 {
		.street,
		city: city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	address: address,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "users" : [ {
    "fullName" : "First Last from city1 name! with population of 8947975",
    "address" : {
      "street" : "some street"
    }
  }, {
    "fullName" : "New First new-last from city2 name? with population of 74",
    "address" : {
      "street" : "another-street"
    }
  } ]
}
----

=== should select fields from triple nested related nodes

.Schema
[source,graphql,schema=true]
----
type State {
  someValue: Int!
}

type City {
  name: String!
  population: Int
  state: State! @relationship(type: "IN_STATE", direction: OUT)
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name state { someValue } population } }")
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver3.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address)-[:IN_CITY]->(city1:City)
 -[:IN_STATE]->(state:State)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}, city1 = {name: "city1 name!", population: 8947975}, state = {someValue: 4797}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address)-[:IN_CITY]->(city2:City)
 -[:IN_STATE]->(state)
 SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}, city2 = {name: "city2 name?", population: 74}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    fullName
    address {
      street
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	CALL {
		WITH address0
		MATCH (address0)-[inCity0:IN_CITY]->(city0:City)
		CALL {
			WITH city0
			MATCH (city0)-[inState0:IN_STATE]->(state0:State)
			WITH state0 {
				.someValue
			} AS state
			RETURN head(collect(state)) AS state
		}
		WITH city0 {
			.name,
			state: state,
			.population
		} AS city
		RETURN head(collect(city)) AS city
	}
	WITH address0 {
		.street,
		city: city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	address: address,
	.firstName,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "users" : [ {
    "fullName" : "First Last from city1 name! with population of 8947975 with 4797",
    "address" : {
      "street" : "some street"
    }
  }, {
    "fullName" : "New First new-last from city2 name? with population of 74 with 4797",
    "address" : {
      "street" : "another-street"
    }
  } ]
}
----

=== should be able to require fields from a related union

.Schema
[source,graphql,schema=true]
----
union Publication = Book | Journal

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
  publicationsWithAuthor: [String!]! @customResolver(requires: "name publications { ...on Book { title } ... on Journal { subject } }")
}

type Book {
  title: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}

type Journal {
  subject: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ArrayFieldCustomResolver.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (author1:Author)-[:WROTE]->(book1:Book) SET author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author2)-[:WROTE]->(journal2:Journal) SET journal2 = {subject: "a second subject", publicationYear: 9087}
 CREATE (author2)-[:WROTE]->(book2:Book) SET book2 = {title: "another-book-name", publicationYear: 1074}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Author {
  authors {
    publicationsWithAuthor
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
	WITH this
	CALL {
		WITH *
		MATCH (this)-[wrote0:WROTE]->(book0:Book)
		WITH book0 {
			__typename: 'Book',
			__id: elementId(book0),
			.title
		} AS book0
		RETURN book0 AS publications0 UNION
		WITH *
		MATCH (this)-[wrote1:WROTE]->(journal0:Journal)
		WITH journal0 {
			__typename: 'Journal',
			__id: elementId(journal0),
			.subject
		} AS journal0
		RETURN journal0 AS publications0
	}
	WITH publications0
	RETURN collect(publications0) AS publications0
}
RETURN this {
	.name,
	publications: publications0
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "authors" : [ {
    "publicationsWithAuthor" : [ "a book name by some-author-name", "a subject by some-author-name" ]
  }, {
    "publicationsWithAuthor" : [ "another-book-name by another author name", "a second subject by another author name", "a subject by another author name" ]
  } ]
}
----

=== should select @alias fields

.Schema
[source,graphql,schema=true]
----
type City {
  name: String!
  population: Int @alias(property: "cityPopulation")
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String! @alias(property: "first")
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name population } }")
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ComplexFieldCustomResolver2.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address)-[:IN_CITY]->(city1:City)
 SET user1 = {id: "1", first: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}, city1 = {name: "city1 name!", cityPopulation: 8947975}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address)-[:IN_CITY]->(city2:City)
 SET user2 = {id: "2", first: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}, city2 = {name: "city2 name?", cityPopulation: 74}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    firstName
    fullName
    address {
      street
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[livesAt0:LIVES_AT]->(address0:Address)
	CALL {
		WITH address0
		MATCH (address0)-[inCity0:IN_CITY]->(city0:City)
		WITH city0 {
			.name,
			population: city0.cityPopulation
		} AS city
		RETURN head(collect(city)) AS city
	}
	WITH address0 {
		.street,
		city: city
	} AS address
	RETURN head(collect(address)) AS address
}
RETURN this {
	firstName: this.first,
	address: address,
	.lastName
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "users" : [ {
    "firstName" : "New First",
    "fullName" : "New First new-last from city2 name? with population of 74",
    "address" : {
      "street" : "another-street"
    }
  }, {
    "firstName" : "First",
    "fullName" : "First Last from city1 name! with population of 8947975",
    "address" : {
      "street" : "some street"
    }
  } ]
}
----

=== should be able to require fields from a related interface

.Schema
[source,graphql,schema=true]
----
interface Publication {
  publicationYear: Int!
}

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
  publicationsWithAuthor: [String!]! @customResolver(requires: "name publications { publicationYear ...on Book { title } ... on Journal { subject } }")
}

type Book implements Publication {
  title: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
  subject: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/ArrayFieldCustomResolver2.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (author1:Author)-[:WROTE]->(book1:Book) SET author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Author {
  authors {
    publicationsWithAuthor
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
	WITH this
	CALL {
		WITH *
		MATCH (this)-[wrote0:WROTE]->(book0:Book)
		WITH book0 {
			__typename: 'Book',
			__id: elementId(book0),
			.title,
			.publicationYear
		} AS book0
		RETURN book0 AS publications UNION
		WITH *
		MATCH (this)-[wrote1:WROTE]->(journal0:Journal)
		WITH journal0 {
			__typename: 'Journal',
			__id: elementId(journal0),
			.subject,
			.publicationYear
		} AS journal0
		RETURN journal0 AS publications
	}
	WITH publications
	RETURN collect(publications) AS publications
}
RETURN this {
	.name,
	publications: publications
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "authors" : [ {
    "publicationsWithAuthor" : [ "a subject by another author name in 573" ]
  }, {
    "publicationsWithAuthor" : [ "a book name by some-author-name in 12", "a subject by some-author-name in 573" ]
  } ]
}
----

=== should be able to require fields from a nested related interface

.Schema
[source,graphql,schema=true]
----
interface Publication {
  publicationYear: Int!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  followedAuthors: [Author!]! @relationship(type: "FOLLOWS", direction: OUT)
  customResolverField: Int @customResolver(requires: "followedAuthors { name publications { publicationYear ...on Book { title } ... on Journal { subject } } } firstName")
}

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
}

type Book implements Publication {
  title: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
  subject: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/FieldFromInterfaceCustomResolver.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:FOLLOWS]->(author1:Author)-[:WROTE]->(book1:Book)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (user1)-[:FOLLOWS]->(author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    customResolverField
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[follows0:FOLLOWS]->(author0:Author)
	CALL {
		WITH author0
		CALL {
			WITH *
			MATCH (author0)-[wrote0:WROTE]->(book0:Book)
			WITH book0 {
				__typename: 'Book',
				__id: elementId(book0),
				.title,
				.publicationYear
			} AS book0
			RETURN book0 AS publications UNION
			WITH *
			MATCH (author0)-[wrote1:WROTE]->(journal0:Journal)
			WITH journal0 {
				__typename: 'Journal',
				__id: elementId(journal0),
				.subject,
				.publicationYear
			} AS journal0
			RETURN journal0 AS publications
		}
		WITH publications
		RETURN collect(publications) AS publications
	}
	WITH author0 {
		.name,
		publications: publications
	} AS followedAuthors
	RETURN collect(followedAuthors) AS followedAuthors
}
RETURN this {
	followedAuthors: followedAuthors,
	.firstName
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "customResolverField" : 1216
  } ]
}
----

=== should be able to require fields from a nested related union

.Schema
[source,graphql,schema=true]
----
type User {
  id: ID!
  firstName: String!
  lastName: String!
  followedAuthors: [Author!]! @relationship(type: "FOLLOWS", direction: OUT)
  customResolverField: Int @customResolver(requires: "followedAuthors { name publications { ...on Book { title } ... on Journal { subject } } } firstName")
}

union Publication = Book | Journal

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
}

type Book {
  title: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}

type Journal {
  subject: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}
----

.CustomResolver
[source,kotlin]
----
include::../../../kotlin/org/neo4j/graphql/custom_resolver/FieldFromUnionCustomResolver.kt[]
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:FOLLOWS]->(author1:Author)-[:WROTE]->(book1:Book)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (user1)-[:FOLLOWS]->(author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    customResolverField
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[follows0:FOLLOWS]->(author0:Author)
	CALL {
		WITH author0
		CALL {
			WITH *
			MATCH (author0)-[wrote0:WROTE]->(book0:Book)
			WITH book0 {
				__typename: 'Book',
				__id: elementId(book0),
				.title
			} AS book0
			RETURN book0 AS publications0 UNION
			WITH *
			MATCH (author0)-[wrote1:WROTE]->(journal0:Journal)
			WITH journal0 {
				__typename: 'Journal',
				__id: elementId(journal0),
				.subject
			} AS journal0
			RETURN journal0 AS publications0
		}
		WITH publications0
		RETURN collect(publications0) AS publications0
	}
	WITH author0 {
		.name,
		publications: publications0
	} AS followedAuthors
	RETURN collect(followedAuthors) AS followedAuthors
}
RETURN this {
	followedAuthors: followedAuthors,
	.firstName
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users" : [ {
    "customResolverField" : 58
  } ]
}
----
