// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

== @customResolver directive

=== Scalar fields

==== Setup

.Schema
[source,graphql,schema=true]
----
type User {
  id: ID!
  firstName: String!
  lastName: String!
  fullName: String @customResolver(requires: "firstName lastName")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user:User) SET user = {id: "An-ID", firstName: "someFirstName", lastName: "a second name!"}
----

==== removes a field from all but its object type, and resolves with a custom resolver

.GraphQL-Query
[source,graphql,request=true]
----
query User($userId: ID!) {
  users(where: {id: $userId}) {
    id
    firstName
    lastName
    fullName
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "userId": "An-ID"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "An-ID"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
RETURN this { .id, .firstName, .lastName, .fullName } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "id": "An-ID",
      "firstName": "someFirstName",
      "lastName": "a second name!",
      "fullName": "someFirstName a second name!"
    }
  ]
}
----

==== resolves field with custom resolver without required fields in selection set

.GraphQL-Query
[source,graphql,request=true]
----
query User($userId: ID!) {
  users(where: {id: $userId}) {
    id
    fullName
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "userId": "An-ID"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "An-ID"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
RETURN this { .id, .fullName, .firstName, .lastName } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "id": "An-ID",
      "fullName": "someFirstName a second name!"
    }
  ]
}
----

==== resolves field with custom resolver with required field(s) aliased in selection set

.GraphQL-Query
[source,graphql,request=true]
----
query User($userId: ID!) {
  users(where: {id: $userId}) {
    id
    f: firstName
    fullName
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "userId": "An-ID"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "An-ID"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
RETURN this { .id, .fullName, .firstName, .lastName, f: this.firstName } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "id": "An-ID",
      "f": "someFirstName",
      "fullName": "someFirstName a second name!"
    }
  ]
}
----

== Related Fields

=== should be able to require a field from a related type

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user:User)-[:LIVES_AT]->(addr:Address) SET user = {id: "1", firstName: "First", lastName: "Last"}, addr = {city: "some city", street: "some street"}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    WITH this1 { .city } AS this1
    RETURN head(collect(this1)) AS var2
}
RETURN this { .fullName, .firstName, .lastName, address: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "fullName": "First Last from some city"
    }
  ]
}
----

=== should fetch required fields when other fields are also selected

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user:User)-[:LIVES_AT]->(addr:Address) SET user = {id: "1", firstName: "First", lastName: "Last"}, addr = {city: "some city", street: "some street"}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    id
    fullName
    address {
      street
      city
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    WITH this1 { .street, .city } AS this1
    RETURN head(collect(this1)) AS var2
}
RETURN this { .id, .fullName, .firstName, .lastName, address: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "id": "1",
      "fullName": "First Last from some city",
      "address": {
        "street": "some street",
        "city": "some city"
      }
    }
  ]
}
----

=== should fetch customResolver fields over multiple users

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address) SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address) SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    id
    fullName
    address {
      street
      city
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    WITH this1 { .street, .city } AS this1
    RETURN head(collect(this1)) AS var2
}
RETURN this { .id, .fullName, .firstName, .lastName, address: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "id": "1",
      "fullName": "First Last from some city",
      "address": {
        "street": "some street",
        "city": "some city"
      }
    },
    {
      "id": "2",
      "fullName": "New First new-last from another-city",
      "address": {
        "street": "another-street",
        "city": "another-city"
      }
    }
  ]
}
----

=== should select related fields when not selected last

.Schema
[source,graphql,schema=true]
----
type Address {
  street: String!
  city: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName address { city } lastName")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address) SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address) SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    id
    fullName
    address {
      street
      city
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    WITH this1 { .street, .city } AS this1
    RETURN head(collect(this1)) AS var2
}
RETURN this { .id, .fullName, .firstName, .lastName, address: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "id": "1",
      "fullName": "First Last from some city",
      "address": {
        "street": "some street",
        "city": "some city"
      }
    },
    {
      "id": "2",
      "fullName": "New First new-last from another-city",
      "address": {
        "street": "another-street",
        "city": "another-city"
      }
    }
  ]
}
----

=== should select fields from double nested related nodes

.Schema
[source,graphql,schema=true]
----
type City {
  name: String!
  population: Int
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name population } }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address)-[:IN_CITY]->(city1:City)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}, city1 = {name: "city1 name!", population: 8947975}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address)-[:IN_CITY]->(city2:City)
 SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}, city2 = {name: "city2 name?", population: 74}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    fullName
    address {
      street
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    CALL {
        WITH this1
        MATCH (this1)-[this2:IN_CITY]->(this3:City)
        WITH this3 { .name, .population } AS this3
        RETURN head(collect(this3)) AS var4
    }
    WITH this1 { .street, city: var4 } AS this1
    RETURN head(collect(this1)) AS var5
}
RETURN this { .fullName, .firstName, .lastName, address: var5 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "fullName": "First Last from city1 name! with population of 8947975",
      "address": {
        "street": "some street"
      }
    },
    {
      "fullName": "New First new-last from city2 name? with population of 74",
      "address": {
        "street": "another-street"
      }
    }
  ]
}
----

=== should select fields from triple nested related nodes

.Schema
[source,graphql,schema=true]
----
type State {
  someValue: Int!
}

type City {
  name: String!
  population: Int
  state: State! @relationship(type: "IN_STATE", direction: OUT)
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name state { someValue } population } }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address)-[:IN_CITY]->(city1:City)
 -[:IN_STATE]->(state:State)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}, city1 = {name: "city1 name!", population: 8947975}, state = {someValue: 4797}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address)-[:IN_CITY]->(city2:City)
 -[:IN_STATE]->(state)
 SET user2 = {id: "2", firstName: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}, city2 = {name: "city2 name?", population: 74}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    fullName
    address {
      street
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    CALL {
        WITH this1
        MATCH (this1)-[this2:IN_CITY]->(this3:City)
        CALL {
            WITH this3
            MATCH (this3)-[this4:IN_STATE]->(this5:State)
            WITH this5 { .someValue } AS this5
            RETURN head(collect(this5)) AS var6
        }
        WITH this3 { .name, .population, state: var6 } AS this3
        RETURN head(collect(this3)) AS var7
    }
    WITH this1 { .street, city: var7 } AS this1
    RETURN head(collect(this1)) AS var8
}
RETURN this { .fullName, .firstName, .lastName, address: var8 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "fullName": "First Last from city1 name! with population of 8947975 with 4797",
      "address": {
        "street": "some street"
      }
    },
    {
      "fullName": "New First new-last from city2 name? with population of 74 with 4797",
      "address": {
        "street": "another-street"
      }
    }
  ]
}
----

=== should be able to require fields from a related union

.Schema
[source,graphql,schema=true]
----
union Publication = Book | Journal

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
  publicationsWithAuthor: [String!]! @customResolver(requires: "name publications { ...on Book { title } ... on Journal { subject } }")
}

type Book {
  title: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}

type Journal {
  subject: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (author1:Author)-[:WROTE]->(book1:Book) SET author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author2)-[:WROTE]->(journal2:Journal) SET journal2 = {subject: "a second subject", publicationYear: 9087}
 CREATE (author2)-[:WROTE]->(book2:Book) SET book2 = {title: "another-book-name", publicationYear: 1074}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Author {
  authors {
    publicationsWithAuthor
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .publicationsWithAuthor, .name, publications: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "authors": [
    {
      "publicationsWithAuthor": [
        "a book name by some-author-name",
        "a subject by some-author-name"
      ]
    },
    {
      "publicationsWithAuthor": [
        "another-book-name by another author name",
        "a subject by another author name",
        "a second subject by another author name"
      ]
    }
  ]
}
----

=== should select @alias fields

.Schema
[source,graphql,schema=true]
----
type City {
  name: String!
  population: Int @alias(property: "cityPopulation")
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String! @alias(property: "first")
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name population } }")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:LIVES_AT]->(addr1:Address)-[:IN_CITY]->(city1:City)
 SET user1 = {id: "1", first: "First", lastName: "Last"}, addr1 = {city: "some city", street: "some street"}, city1 = {name: "city1 name!", cityPopulation: 8947975}
 CREATE (user2:User)-[:LIVES_AT]->(addr2:Address)-[:IN_CITY]->(city2:City)
 SET user2 = {id: "2", first: "New First", lastName: "new-last"}, addr2 = {city: "another-city", street: "another-street"}, city2 = {name: "city2 name?", cityPopulation: 74}
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    firstName
    fullName
    address {
      street
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    CALL {
        WITH this1
        MATCH (this1)-[this2:IN_CITY]->(this3:City)
        WITH this3 { .name, population: this3.cityPopulation } AS this3
        RETURN head(collect(this3)) AS var4
    }
    WITH this1 { .street, city: var4 } AS this1
    RETURN head(collect(this1)) AS var5
}
RETURN this { .fullName, .lastName, firstName: this.first, address: var5 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "firstName": "First",
      "fullName": "First Last from city1 name! with population of 8947975",
      "address": {
        "street": "some street"
      }
    },
    {
      "firstName": "New First",
      "fullName": "New First new-last from city2 name? with population of 74",
      "address": {
        "street": "another-street"
      }
    }
  ]
}
----

=== should be able to require fields from a related interface

.Schema
[source,graphql,schema=true]
----
interface Publication {
  publicationYear: Int!
}

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
  publicationsWithAuthor: [String!]! @customResolver(requires: "name publications { publicationYear ...on Book { title } ... on Journal { subject } }")
}

type Book implements Publication {
  title: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
  subject: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (author1:Author)-[:WROTE]->(book1:Book) SET author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Author {
  authors {
    publicationsWithAuthor
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .publicationYear, .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .publicationYear, .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .publicationsWithAuthor, .name, publications: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "authors": [
    {
      "publicationsWithAuthor": [
        "a book name by some-author-name in 12",
        "a subject by some-author-name in 573"
      ]
    },
    {
      "publicationsWithAuthor": [
        "a subject by another author name in 573"
      ]
    }
  ]
}
----

=== should be able to require fields from a nested related interface

.Schema
[source,graphql,schema=true]
----
interface Publication {
  publicationYear: Int!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  followedAuthors: [Author!]! @relationship(type: "FOLLOWS", direction: OUT)
  customResolverField: Int @customResolver(requires: "followedAuthors { name publications { publicationYear ...on Book { title } ... on Journal { subject } } } firstName")
}

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
}

type Book implements Publication {
  title: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
  subject: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:FOLLOWS]->(author1:Author)-[:WROTE]->(book1:Book)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (user1)-[:FOLLOWS]->(author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    customResolverField
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:FOLLOWS]->(this1:Author)
    CALL {
        WITH this1
        CALL {
            WITH *
            MATCH (this1)-[this2:WROTE]->(this3:Book)
            WITH this3 { .publicationYear, .title, __typename: "Book", __id: toString(id(this3)) } AS this3
            RETURN this3 AS var4
            UNION
            WITH *
            MATCH (this1)-[this5:WROTE]->(this6:Journal)
            WITH this6 { .publicationYear, .subject, __typename: "Journal", __id: toString(id(this6)) } AS this6
            RETURN this6 AS var4
        }
        WITH var4
        RETURN collect(var4) AS var4
    }
    WITH this1 { .name, publications: var4 } AS this1
    RETURN collect(this1) AS var7
}
RETURN this { .customResolverField, .firstName, followedAuthors: var7 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "customResolverField": 1216
    }
  ]
}
----

=== should be able to require fields from a nested related union

.Schema
[source,graphql,schema=true]
----
type User {
  id: ID!
  firstName: String!
  lastName: String!
  followedAuthors: [Author!]! @relationship(type: "FOLLOWS", direction: OUT)
  customResolverField: Int @customResolver(requires: "followedAuthors { name publications { ...on Book { title } ... on Journal { subject } } } firstName")
}

union Publication = Book | Journal

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
}

type Book {
  title: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}

type Journal {
  subject: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (user1:User)-[:FOLLOWS]->(author1:Author)-[:WROTE]->(book1:Book)
 SET user1 = {id: "1", firstName: "First", lastName: "Last"}, author1 = {name: "some-author-name"}, book1 = {title: "a book name", publicationYear: 12}
 CREATE (user1)-[:FOLLOWS]->(author2:Author)-[:WROTE]->(journal1:Journal) SET author2 = {name: "another author name"}, journal1 = {subject: "a subject", publicationYear: 573}
 CREATE (author1)-[:WROTE]->(journal1)
----

.GraphQL-Query
[source,graphql,request=true]
----
query User {
  users {
    customResolverField
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:FOLLOWS]->(this1:Author)
    CALL {
        WITH this1
        CALL {
            WITH *
            MATCH (this1)-[this2:WROTE]->(this3:Book)
            WITH this3 { .title, __typename: "Book", __id: toString(id(this3)) } AS this3
            RETURN this3 AS var4
            UNION
            WITH *
            MATCH (this1)-[this5:WROTE]->(this6:Journal)
            WITH this6 { .subject, __typename: "Journal", __id: toString(id(this6)) } AS this6
            RETURN this6 AS var4
        }
        WITH var4
        RETURN collect(var4) AS var4
    }
    WITH this1 { .name, publications: var4 } AS this1
    RETURN collect(this1) AS var7
}
RETURN this { .customResolverField, .firstName, followedAuthors: var7 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "users": [
    {
      "customResolverField": 58
    }
  ]
}
----
