// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= interface relationships

== Setup

.Schema
[source,graphql,schema=true]
----
interface Production {
  title: String!
}

type Movie implements Production {
  title: String!
  runtime: Int!
}

type Series implements Production {
  title: String!
  episodes: Int!
}

type ActedIn @relationshipProperties {
  screenTime: Int!
}

type Actor {
  name: String!
  currentlyActingIn: Production @relationship(type: "CURRENTLY_ACTING_IN", direction: OUT)
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----

== should read and return interface relationship fields with interface relationship filter SOME

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (a)-[:ACTED_IN { screenTime: 9448 }]->(:Movie { title: "RandomString3", runtime:96406 })
 CREATE (a)-[:ACTED_IN { screenTime: 3167 }]->(:Series { title: "RandomString5", episodes: 56834 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 9448 }]->(:Movie { title: "RandomString4", runtime:96406 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_SOME: {title: $title}}) {
    name
    actedIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString4",
  "param1": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
} OR EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
})
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString4",
          "runtime": 96406
        }
      ]
    }
  ]
}
----

== should read and return interface relationship fields with interface relationship filter ALL (both implementations in the input and DB)

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:47026 })
 CREATE (a)-[:ACTED_IN { screenTime: 85740 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 96705 }]->(:Series { title: "RandomString4", episodes: 3093 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 85740 }]->(m)
 CREATE (a2)-[:ACTED_IN { screenTime: 96705 }]->(:Series { title: "RandomString3", episodes: 3093 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_ALL: {title: $title}}) {
    name
    actedIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString3"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString3",
  "param1": "RandomString3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE ((EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE NOT (this0.title = $param0)
})) AND (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE NOT (this1.title = $param1)
})))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 47026
        },
        {
          "title": "RandomString3",
          "episodes": 3093
        }
      ]
    }
  ]
}
----

== should read and return interface relationship fields with interface relationship filter ALL (both implementations in the input and one out of two in DB)

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:46474 })
 CREATE (a)-[:ACTED_IN { screenTime: 95753 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 76273 }]->(:Series { title: "RandomString4", episodes: 8658 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 95753 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_ALL: {title: $title}}) {
    name
    actedIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString3"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString3",
  "param1": "RandomString3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE ((EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE NOT (this0.title = $param0)
})) AND (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE NOT (this1.title = $param1)
})))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": []
}
----

== should read and return interface relationship fields with interface relationship filter SINGLE

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:51686 })
 CREATE (a)-[:ACTED_IN { screenTime: 60481 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 75798 }]->(:Series { title: "RandomString5", episodes: 18888 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 60481 }]->(:Movie { title: "RandomString4", runtime:51686 })
 CREATE (a2)-[:ACTED_IN { screenTime: 60481 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_SINGLE: {title: $title}}) {
    name
    actedIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString4",
  "param1": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE (single(this0 IN [(this)-[:ACTED_IN]->(this0:Movie) WHERE this0.title = $param0 | 1] WHERE true) XOR single(this1 IN [(this)-[:ACTED_IN]->(this1:Series) WHERE this1.title = $param1 | 1] WHERE true))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 51686
        },
        {
          "title": "RandomString4",
          "runtime": 51686
        }
      ]
    }
  ]
}
----

== should read and return interface relationship fields with interface relationship filter NONE

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:13985 })
 CREATE (a)-[:ACTED_IN { screenTime: 20492 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 70112 }]->(:Series { title: "RandomString5", episodes: 4471 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 20492 }]->(:Movie { title: "RandomString4", runtime:13985 })
 CREATE (a2)-[:ACTED_IN { screenTime: 20492 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_NONE: {title: $title}}) {
    name
    actedIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString4",
  "param1": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE (NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
}) AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
}))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 13985
        },
        {
          "title": "RandomString5",
          "episodes": 4471
        }
      ]
    }
  ]
}
----
