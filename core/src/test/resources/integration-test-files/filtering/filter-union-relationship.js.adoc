// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= union relationships

== Setup

.Schema
[source,graphql,schema=true]
----
type Movie {
  title: String!
  runtime: Int!
}

type Series {
  title: String!
  episodes: Int!
}

union Production = Movie | Series

type ActedIn @relationshipProperties {
  screenTime: Int!
}

type Actor {
  name: String!
  currentlyActingIn: Production @relationship(type: "CURRENTLY_ACTING_IN", direction: OUT)
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----

== should read and return union relationship fields with union relationship filter SOME

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (a)-[:ACTED_IN { screenTime: 83582 }]->(:Movie { title: "RandomString3", runtime:18723 })
 CREATE (a)-[:ACTED_IN { screenTime: 8697 }]->(:Series { title: "RandomString5", episodes: 50148 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 83582 }]->(:Movie { title: "RandomString4", runtime:18723 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_SOME: {Movie: {title: $title}}}) {
    name
    actedIn {
      ... on Movie {
        title
        runtime
      }
      ... on Series {
        title
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
}
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this1:ACTED_IN]->(this2:Movie)
        WITH this2 { .title, .runtime, __typename: "Movie", __id: toString(id(this2)) } AS this2
        RETURN this2 AS var3
        UNION
        WITH *
        MATCH (this)-[this4:ACTED_IN]->(this5:Series)
        WITH this5 { .title, .episodes, __typename: "Series", __id: toString(id(this5)) } AS this5
        RETURN this5 AS var3
    }
    WITH var3
    RETURN collect(var3) AS var3
}
RETURN this { .name, actedIn: var3 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString4",
          "runtime": 18723
        }
      ]
    }
  ]
}
----

== should read and return union relationship fields with union relationship filter ALL (one out of two implementations in the input and DB)

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:61632 })
 CREATE (a)-[:ACTED_IN { screenTime: 69036 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 51960 }]->(:Series { title: "RandomString4", episodes: 61753 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 69036 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_ALL: {Movie: {title: $title}}}) {
    name
    actedIn {
      ... on Movie {
        title
        runtime
      }
      ... on Series {
        title
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString3"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE NOT (this0.title = $param0)
}))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this1:ACTED_IN]->(this2:Movie)
        WITH this2 { .title, .runtime, __typename: "Movie", __id: toString(id(this2)) } AS this2
        RETURN this2 AS var3
        UNION
        WITH *
        MATCH (this)-[this4:ACTED_IN]->(this5:Series)
        WITH this5 { .title, .episodes, __typename: "Series", __id: toString(id(this5)) } AS this5
        RETURN this5 AS var3
    }
    WITH var3
    RETURN collect(var3) AS var3
}
RETURN this { .name, actedIn: var3 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 61632
        },
        {
          "title": "RandomString4",
          "episodes": 61753
        }
      ]
    },
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 61632
        }
      ]
    }
  ]
}
----

== should read and return union relationship fields with union relationship filter ALL (both implementations in the input and DB)

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:25423 })
 CREATE (a)-[:ACTED_IN { screenTime: 26354 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 74985 }]->(:Series { title: "RandomString4", episodes: 36248 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 26354 }]->(m)
 CREATE (a2)-[:ACTED_IN { screenTime: 74985 }]->(:Series { title: "RandomString3", episodes: 36248 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_ALL: {Movie: {title: $title}, Series: {title: $title}}}) {
    name
    actedIn {
      ... on Movie {
        title
        runtime
      }
      ... on Series {
        title
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString3"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString3",
  "param1": "RandomString3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE ((EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE NOT (this0.title = $param0)
})) AND (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE NOT (this1.title = $param1)
})))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 25423
        },
        {
          "title": "RandomString3",
          "episodes": 36248
        }
      ]
    }
  ]
}
----

== should read and return union relationship fields with union relationship filter ALL (both implementations in the input and one out of two in DB)

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:24426 })
 CREATE (a)-[:ACTED_IN { screenTime: 65872 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 26046 }]->(:Series { title: "RandomString4", episodes: 84714 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 65872 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_ALL: {Movie: {title: $title}, Series: {title: $title}}}) {
    name
    actedIn {
      ... on Movie {
        title
        runtime
      }
      ... on Series {
        title
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString3"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString3",
  "param1": "RandomString3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE ((EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE NOT (this0.title = $param0)
})) AND (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
} AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE NOT (this1.title = $param1)
})))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": []
}
----

== should read and return interface relationship fields with interface relationship filter SINGLE

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:55815 })
 CREATE (a)-[:ACTED_IN { screenTime: 86611 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 64097 }]->(:Series { title: "RandomString5", episodes: 61405 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 86611 }]->(:Movie { title: "RandomString4", runtime:55815 })
 CREATE (a2)-[:ACTED_IN { screenTime: 86611 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_SINGLE: {Movie: {title: $title}}}) {
    name
    actedIn {
      ... on Movie {
        title
        runtime
      }
      ... on Series {
        title
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE single(this0 IN [(this)-[:ACTED_IN]->(this0:Movie) WHERE this0.title = $param0 | 1] WHERE true)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this1:ACTED_IN]->(this2:Movie)
        WITH this2 { .title, .runtime, __typename: "Movie", __id: toString(id(this2)) } AS this2
        RETURN this2 AS var3
        UNION
        WITH *
        MATCH (this)-[this4:ACTED_IN]->(this5:Series)
        WITH this5 { .title, .episodes, __typename: "Series", __id: toString(id(this5)) } AS this5
        RETURN this5 AS var3
    }
    WITH var3
    RETURN collect(var3) AS var3
}
RETURN this { .name, actedIn: var3 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString2",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 55815
        },
        {
          "title": "RandomString4",
          "runtime": 55815
        }
      ]
    }
  ]
}
----

== should read and return interface relationship fields with interface relationship filter NONE

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (m:Movie { title: "RandomString3", runtime:9931 })
 CREATE (a)-[:ACTED_IN { screenTime: 29383 }]->(m)
 CREATE (a)-[:ACTED_IN { screenTime: 72093 }]->(:Series { title: "RandomString5", episodes: 15912 })
 CREATE (a2:Actor { name: "RandomString2" })
 CREATE (a2)-[:ACTED_IN { screenTime: 29383 }]->(:Movie { title: "RandomString4", runtime:9931 })
 CREATE (a2)-[:ACTED_IN { screenTime: 29383 }]->(m)
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($title: String) {
  actors(where: {actedIn_NONE: {Movie: {title: $title}, Series: {title: $title}}}) {
    name
    actedIn {
      ... on Movie {
        title
        runtime
      }
      ... on Series {
        title
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString4",
  "param1": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE (NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title = $param0
}) AND NOT (EXISTS {
    MATCH (this)-[:ACTED_IN]->(this1:Series)
    WHERE this1.title = $param1
}))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this2:ACTED_IN]->(this3:Movie)
        WITH this3 { .title, .runtime, __typename: "Movie", __id: toString(id(this3)) } AS this3
        RETURN this3 AS var4
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WITH this6 { .title, .episodes, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var4
    }
    WITH var4
    RETURN collect(var4) AS var4
}
RETURN this { .name, actedIn: var4 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "actedIn": [
        {
          "title": "RandomString3",
          "runtime": 9931
        },
        {
          "title": "RandomString5",
          "episodes": 15912
        }
      ]
    }
  ]
}
----
