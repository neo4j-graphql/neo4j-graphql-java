// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= typename_IN

== Setup

.Schema
[source,graphql,schema=true]
----
interface Production {
  title: String!
  cost: Float!
}

type Movie implements Production {
  title: String!
  cost: Float!
  runtime: Int!
}

type Series implements Production {
  title: String!
  cost: Float!
  episodes: Int!
}

type Cartoon implements Production {
  title: String!
  cost: Float!
  cartoonist: String!
}

type ActedIn @relationshipProperties {
  screenTime: Int!
}

type Actor {
  name: String!
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE(a:Actor { name: "Keanu" })
 CREATE(a)-[:ACTED_IN]->(m:Movie { title: "The Matrix" })
 CREATE(a)-[:ACTED_IN]->(s:Series { title: "The Matrix animated series" })
 CREATE(a)-[:ACTED_IN]->(c:Cartoon { title: "Matrix the cartoon" })
----

== top-level

.GraphQL-Query
[source,graphql,request=true]
----
{
  productions(
    where: {OR: [{AND: [{title: "The Matrix"}, {typename_IN: [Movie]}]}, {typename_IN: [Series]}]}
  ) {
    __typename
    title
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Matrix",
  "param1": "The Matrix",
  "param2": "The Matrix"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Cartoon)
    WHERE ((this0.title = $param0 AND this0:Movie) OR this0:Series)
    WITH this0 { .title, __typename: "Cartoon", __id: toString(id(this0)) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:Movie)
    WHERE ((this1.title = $param1 AND this1:Movie) OR this1:Series)
    WITH this1 { .title, __typename: "Movie", __id: toString(id(this1)) } AS this1
    RETURN this1 AS this
    UNION
    MATCH (this2:Series)
    WHERE ((this2.title = $param2 AND this2:Movie) OR this2:Series)
    WITH this2 { .title, __typename: "Series", __id: toString(id(this2)) } AS this2
    RETURN this2 AS this
}
WITH this
RETURN this AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "productions": [
    {
      "__typename": "Movie",
      "title": "The Matrix"
    },
    {
      "__typename": "Series",
      "title": "The Matrix animated series"
    }
  ]
}
----

== nested

.GraphQL-Query
[source,graphql,request=true]
----
{
  actors {
    actedIn(
      where: {OR: [{AND: [{title: "The Matrix"}, {typename_IN: [Movie]}]}, {typename_IN: [Series]}]}
    ) {
      __typename
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Matrix",
  "param1": "The Matrix",
  "param2": "The Matrix"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:ACTED_IN]->(this1:Cartoon)
        WHERE ((this1.title = $param0 AND this1:Movie) OR this1:Series)
        WITH this1 { .title, __typename: "Cartoon", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:ACTED_IN]->(this4:Movie)
        WHERE ((this4.title = $param1 AND this4:Movie) OR this4:Series)
        WITH this4 { .title, __typename: "Movie", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
        UNION
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Series)
        WHERE ((this6.title = $param2 AND this6:Movie) OR this6:Series)
        WITH this6 { .title, __typename: "Series", __id: toString(id(this6)) } AS this6
        RETURN this6 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { actedIn: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "actedIn": [
        {
          "__typename": "Movie",
          "title": "The Matrix"
        },
        {
          "__typename": "Series",
          "title": "The Matrix animated series"
        }
      ]
    }
  ]
}
----
