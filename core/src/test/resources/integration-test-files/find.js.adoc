// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= find

== should find Movie by id

.Schema
[source,graphql,schema=true]
----
type Actor {
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Movie {
  id: ID!
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:Movie {id: "RandomString1"}), (:Movie {id: "RandomString1"}), (:Movie {id: "RandomString1"})
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($id: ID) {
  movies(where: {id: $id}) {
    id
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "id": "RandomString1"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0
RETURN this { .id } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1"
    },
    {
      "id": "RandomString1"
    },
    {
      "id": "RandomString1"
    }
  ]
}
----

== should find Move by id and limit

.Schema
[source,graphql,schema=true]
----
type Actor {
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Movie {
  id: ID!
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:Movie {id: "RandomString1"}), (:Movie {id: "RandomString1"}), (:Movie {id: "RandomString1"})
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($id: ID) {
  movies(where: {id: $id}, options: {limit: 2}) {
    id
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "id": "RandomString1"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1",
  "param1": 2
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0
WITH *

LIMIT $param1
RETURN this { .id } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1"
    },
    {
      "id": "RandomString1"
    }
  ]
}
----

== should find Movie IN ids

.Schema
[source,graphql,schema=true]
----
type Actor {
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Movie {
  id: ID!
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:Movie {id: "RandomString1"}), (:Movie {id: "RandomString2"}), (:Movie {id: "RandomString3"})
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($ids: [ID!]) {
  movies(where: {id_IN: $ids}) {
    id
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "ids": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ]
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
RETURN this { .id } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1"
    },
    {
      "id": "RandomString2"
    },
    {
      "id": "RandomString3"
    }
  ]
}
----

== should find Movie IN ids with one other param

.Schema
[source,graphql,schema=true]
----
type Actor {
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Movie {
  id: ID!
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:User {id: "RandomString1", title: "RandomString4"}), (:User {id: "RandomString2", title: "RandomString4"}), (:User {id: "RandomString3", title: "RandomString4"})
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($ids: [ID!], $title: String) {
  movies(where: {id_IN: $ids, title: $title}) {
    id
    title
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "ids": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "title": "RandomString4"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "RandomString4"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.title = $param1)
RETURN this { .id, .title } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": []
}
----

== should find Movie IN id and many Movie.actor IN id

.Schema
[source,graphql,schema=true]
----
type Actor {
  id: ID!
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Movie {
  id: ID!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:Movie {id: "RandomString1"})-[:ACTED_IN]->(:Actor {id: "RandomString4"}),
 (:Movie {id: "RandomString2"})-[:ACTED_IN]->(:Actor {id: "RandomString5"}),
 (:Movie {id: "RandomString3"})-[:ACTED_IN]->(:Actor {id: "RandomString6"})
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($movieIds: [ID!], $actorIds: [ID!]) {
  movies(where: {id_IN: $movieIds}) {
    id
    actors(where: {id_IN: $actorIds}) {
      id
      movies {
        id
        actors {
          id
        }
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "movieIds": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "actorIds": [
    "RandomString4",
    "RandomString5",
    "RandomString6"
  ]
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": [
    "RandomString4",
    "RandomString5",
    "RandomString6"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
CALL {
    WITH this
    MATCH (this)-[this0:ACTED_IN]->(this1:Actor)
    WHERE this1.id IN $param1
    CALL {
        WITH this1
        MATCH (this1)<-[this2:ACTED_IN]-(this3:Movie)
        CALL {
            WITH this3
            MATCH (this3)-[this4:ACTED_IN]->(this5:Actor)
            WITH this5 { .id } AS this5
            RETURN collect(this5) AS var6
        }
        WITH this3 { .id, actors: var6 } AS this3
        RETURN collect(this3) AS var7
    }
    WITH this1 { .id, movies: var7 } AS this1
    RETURN collect(this1) AS var8
}
RETURN this { .id, actors: var8 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "actors": [
        {
          "id": "RandomString6",
          "movies": [
            {
              "id": "RandomString3",
              "actors": [
                {
                  "id": "RandomString6"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "RandomString1",
      "actors": [
        {
          "id": "RandomString4",
          "movies": [
            {
              "id": "RandomString1",
              "actors": [
                {
                  "id": "RandomString4"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "RandomString2",
      "actors": [
        {
          "id": "RandomString5",
          "movies": [
            {
              "id": "RandomString2",
              "actors": [
                {
                  "id": "RandomString5"
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
----

== should use OR and find Movie by id or title

.Schema
[source,graphql,schema=true]
----
type Actor {
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Movie {
  id: ID!
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: OUT)
  mainActor: Actor! @relationship(type: "MAIN_ACTOR", direction: OUT)
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:Movie {id: "RandomString1", title: "RandomString2"})
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($movieWhere: MovieWhere) {
  movies(where: $movieWhere) {
    id
    title
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "movieWhere": {
    "OR": [
      {
        "title": "RandomString2",
        "id": "RandomString1"
      }
    ]
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1",
  "param1": "RandomString2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id = $param0 AND this.title = $param1)
RETURN this { .id, .title } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "title": "RandomString2"
    }
  ]
}
----
