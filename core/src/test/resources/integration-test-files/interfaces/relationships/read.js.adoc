// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= interface relationships

== Setup

.Schema
[source,graphql,schema=true]
----
interface Production {
  title: String!
}

type Movie implements Production {
  title: String!
  runtime: Int!
}

type Series implements Production {
  title: String!
  episodes: Int!
}

type ActedIn @relationshipProperties {
  screenTime: Int!
}

type Actor {
  name: String!
  currentlyActingIn: Production @relationship(type: "CURRENTLY_ACTING_IN", direction: OUT)
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----

== should read and return interface relationship fields

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (a)-[:ACTED_IN { screenTime: 47337 }]->(:Movie { title: "RandomString2", runtime:88052 })
 CREATE (a)-[:ACTED_IN { screenTime: 99847 }]->(:Series { title: "RandomString3", episodes: 45953 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($name: String) {
  actors(where: {name: $name}) {
    name
    actedIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "name": "RandomString1"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE this.name = $param0
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WITH this1 { .title, .runtime, __typename: "Movie", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:ACTED_IN]->(this4:Series)
        WITH this4 { .title, .episodes, __typename: "Series", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .name, actedIn: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "actedIn": [
        {
          "title": "RandomString2",
          "runtime": 88052
        },
        {
          "title": "RandomString3",
          "episodes": 45953
        }
      ]
    }
  ]
}
----

== should read and return sorted interface relationship fields

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (:Movie { title: "A", runtime:23408 })<-[:ACTED_IN { screenTime: 40446 }]-(a)-[:ACTED_IN { screenTime: 89440 }]->(:Movie { title: "B", runtime: 76130 })
 CREATE (:Series { title: "C", episodes: 64675 })<-[:ACTED_IN { screenTime: 83928 }]-(a)-[:ACTED_IN { screenTime: 83728 }]->(:Series { title: "D", episodes: 8135 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($name: String) {
  actors(where: {name: $name}) {
    name
    actedIn(options: {sort: [{title: DESC}]}) {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "name": "RandomString1"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE this.name = $param0
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WITH this1 { .title, .runtime, __typename: "Movie", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:ACTED_IN]->(this4:Series)
        WITH this4 { .title, .episodes, __typename: "Series", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    ORDER BY var2.title DESC
    RETURN collect(var2) AS var2
}
RETURN this { .name, actedIn: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "actedIn": [
        {
          "title": "D",
          "episodes": 8135
        },
        {
          "title": "C",
          "episodes": 64675
        },
        {
          "title": "B",
          "runtime": 76130
        },
        {
          "title": "A",
          "runtime": 23408
        }
      ]
    }
  ]
}
----

== should read and return non-array interface relationship fields

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (a)-[:ACTED_IN { screenTime: 50667 }]->(:Movie { title: "RandomString2", runtime:85953 })
 CREATE (a)-[:ACTED_IN { screenTime: 1726 }]->(:Series { title: "RandomString3", episodes: 85490 })
 CREATE (a)-[:CURRENTLY_ACTING_IN]->(:Movie { title: "RandomString4", runtime: 6106 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($name: String) {
  actors(where: {name: $name}) {
    name
    currentlyActingIn {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "name": "RandomString1"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE this.name = $param0
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:CURRENTLY_ACTING_IN]->(this1:Movie)
        WITH this1 { .title, .runtime, __typename: "Movie", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:CURRENTLY_ACTING_IN]->(this4:Series)
        WITH this4 { .title, .episodes, __typename: "Series", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN head(collect(var2)) AS var2
}
RETURN this { .name, currentlyActingIn: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "currentlyActingIn": {
        "title": "RandomString4",
        "runtime": 6106
      }
    }
  ]
}
----

== should read and return interface relationship fields with shared where

.Test Data
[source,cypher,test-data=true]
----
CREATE (a:Actor { name: "RandomString1" })
 CREATE (a)-[:ACTED_IN { screenTime: 28270 }]->(:Movie { title: "Apple", runtime:76300 })
 CREATE (a)-[:ACTED_IN { screenTime: 28270 }]->(:Movie { title: "RandomString2", runtime:76300 })
 CREATE (a)-[:ACTED_IN { screenTime: 70458 }]->(:Series { title: "Apple", episodes: 52388 })
----

.GraphQL-Query
[source,graphql,request=true]
----
query Actors($name: String, $title: String) {
  actors(where: {name: $name}) {
    name
    actedIn(where: {title: $title}) {
      title
      ... on Movie {
        runtime
      }
      ... on Series {
        episodes
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "name": "RandomString1",
  "title": "Apple"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1",
  "param1": "Apple",
  "param2": "Apple"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE this.name = $param0
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE this1.title = $param1
        WITH this1 { .title, .runtime, __typename: "Movie", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:ACTED_IN]->(this4:Series)
        WHERE this4.title = $param2
        WITH this4 { .title, .episodes, __typename: "Series", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .name, actedIn: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "RandomString1",
      "actedIn": [
        {
          "title": "Apple",
          "runtime": 76300
        },
        {
          "title": "Apple",
          "episodes": 52388
        }
      ]
    }
  ]
}
----
