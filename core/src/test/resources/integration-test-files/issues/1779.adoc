:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/1779

== Setup

.Schema
[source,graphql,schema=true]
----
type Person {
  name: String
  age: Int
  attends: [School!]! @relationship(type: "ATTENDS", direction: OUT)
}

type School {
  name: String
  students: [Person!]! @relationship(type: "ATTENDS", direction: IN)
}
----

== Does not throw error 'The EXISTS subclause is not valid inside a WITH or RETURN clause. '

.Test Data
[source,cypher,test-data=true]
----
CREATE (personA:Person { name: "A", age: 24 })-[:ATTENDS]->(schoolOld:School { name: "Old" })
 CREATE (personB:Person { name: "B", age: 26 })-[:ATTENDS]->(schoolOld)
 CREATE (personC:Person { name: "C", age: 23 })-[:ATTENDS]->(schoolYoung:School { name: "Young" })
 CREATE (personD:Person { name: "D", age: 25 })-[:ATTENDS]->(schoolYoung)
----

.GraphQL-Query
[source,graphql]
----
{
  people {
    name
    attends(where: {students_ALL: {age_GT: 23}}) {
      name
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 23
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Person)
CALL {
	WITH this
	MATCH (this)-[attends0:ATTENDS]->(school0:School)
	WHERE (EXISTS {
			MATCH (school00:Person)-[:ATTENDS]->(school0)
			WHERE school00.age > $param0
		}
		AND NOT (EXISTS {
			MATCH (school00:Person)-[:ATTENDS]->(school0)
			WHERE NOT (school00.age > $param0)
		}))
	WITH school0 {
		.name
	} AS attends
	RETURN collect(attends) AS attends
}
RETURN this {
	.name,
	attends: attends
} AS this
----

.GraphQL-Response
[source,json,response=true,ignore-order]
----
{
  "people": [
    {
      "name": "A",
      "attends": [
        {
          "name": "Old"
        }
      ]
    },
    {
      "name": "C",
      "attends": []
    },
    {
      "name": "D",
      "attends": []
    },
    {
      "name": "B",
      "attends": [
        {
          "name": "Old"
        }
      ]
    }
  ]
}
----

'''

