// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/3394

== Setup

.Schema
[source,graphql,schema=true]
----
type Employee {
  products: [Product!]! @relationship(type: "CAN_ACCESS", direction: OUT)
}

type Product {
  id: String! @alias(property: "fg_item_id")
  description: String!
  partNumber: ID! @alias(property: "fg_item")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (e:Employee {fg_item_id: "p1", description: "a p1", fg_item: "part1"})
 CREATE (p1:Product {fg_item_id: "p1", description: "a p1", fg_item: "part1"})
 CREATE (p2:Product {fg_item_id: "p2", description: "a p2", fg_item: "part2"})

 CREATE (e)-[:CAN_ACCESS]->(p1)
 CREATE (e)-[:CAN_ACCESS]->(p2)
----

== should sort elements by aliased field

.GraphQL-Query
[source,graphql,request=true]
----
query listProducts {
  products(options: {sort: {partNumber: DESC}}) {
    id
    partNumber
    description
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Product)
WITH *
ORDER BY this.fg_item DESC
RETURN this { .description, id: this.fg_item_id, partNumber: this.fg_item } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "products": [
    {
      "id": "p2",
      "partNumber": "part2",
      "description": "a p2"
    },
    {
      "id": "p1",
      "partNumber": "part1",
      "description": "a p1"
    }
  ]
}
----

== should sort elements by aliased field in relationship

.GraphQL-Query
[source,graphql,request=true]
----
query listProducts {
  employees {
    products(options: {sort: {partNumber: DESC}}) {
      id
      partNumber
      description
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Employee)
CALL {
    WITH this
    MATCH (this)-[this0:CAN_ACCESS]->(this1:Product)
    WITH this1 { .description, id: this1.fg_item_id, partNumber: this1.fg_item } AS this1
    ORDER BY this1.partNumber DESC
    RETURN collect(this1) AS var2
}
RETURN this { products: var2 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "employees": [
    {
      "products": [
        {
          "id": "p2",
          "partNumber": "part2",
          "description": "a p2"
        },
        {
          "id": "p1",
          "partNumber": "part1",
          "description": "a p1"
        }
      ]
    }
  ]
}
----

== Connection sort

=== Setup

.Schema
[source,graphql,schema=true]
----
type Employee {
  products: [Product!]! @relationship(type: "CAN_ACCESS", direction: OUT)
}

type Product {
  id: String! @alias(property: "fg_item_id")
  description: String!
  partNumber: ID! @alias(property: "fg_item")
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (e:Employee {fg_item_id: "p1", description: "a p1", fg_item: "part1"})
 CREATE (p1:Product {fg_item_id: "p1", description: "a p1", fg_item: "part1"})
 CREATE (p2:Product {fg_item_id: "p2", description: "a p2", fg_item: "part2"})

 CREATE (e)-[:CAN_ACCESS]->(p1)
 CREATE (e)-[:CAN_ACCESS]->(p2)
----

=== should sort elements by aliased field in connection

.GraphQL-Query
[source,graphql,request=true]
----
query listProducts {
  productsConnection(sort: {partNumber: DESC}) {
    edges {
      node {
        id
        partNumber
        description
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Product)
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    WITH *
    ORDER BY this0.fg_item DESC
    RETURN collect({ node: { id: this0.fg_item_id, partNumber: this0.fg_item, description: this0.description, __typename: "Product" } }) AS var1
}
RETURN { edges: var1, totalCount: totalCount } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "productsConnection": {
    "edges": [
      {
        "node": {
          "id": "p2",
          "partNumber": "part2",
          "description": "a p2"
        }
      },
      {
        "node": {
          "id": "p1",
          "partNumber": "part1",
          "description": "a p1"
        }
      }
    ]
  }
}
----

=== should sort elements by aliased field in nested  connection

.GraphQL-Query
[source,graphql,request=true]
----
query listProducts {
  employees {
    productsConnection(sort: {node: {partNumber: DESC}}) {
      edges {
        node {
          id
          partNumber
          description
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Employee)
CALL {
    WITH this
    MATCH (this)-[this0:CAN_ACCESS]->(this1:Product)
    WITH collect({ node: this1, relationship: this0 }) AS edges
    WITH edges, size(edges) AS totalCount
    CALL {
        WITH edges
        UNWIND edges AS edge
        WITH edge.node AS this1, edge.relationship AS this0
        WITH *
        ORDER BY this1.fg_item DESC
        RETURN collect({ node: { id: this1.fg_item_id, partNumber: this1.fg_item, description: this1.description, __typename: "Product" } }) AS var2
    }
    RETURN { edges: var2, totalCount: totalCount } AS var3
}
RETURN this { productsConnection: var3 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "employees": [
    {
      "productsConnection": {
        "edges": [
          {
            "node": {
              "id": "p2",
              "partNumber": "part2",
              "description": "a p2"
            }
          },
          {
            "node": {
              "id": "p1",
              "partNumber": "part1",
              "description": "a p1"
            }
          }
        ]
      }
    }
  ]
}
----
