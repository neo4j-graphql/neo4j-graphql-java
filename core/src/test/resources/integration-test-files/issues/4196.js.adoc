// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/4196

== Setup

.Schema
[source,graphql,schema=true]
----
type Foo {
  name: String
  bars: [Bar!]! @relationship(type: "relatesTo", direction: OUT)
}

type Bar {
  name: String
  foobars: [FooBar!]! @relationship(type: "relatesTo", direction: OUT)
}

type FooBar {
  name: String
  bars: [FooBar!]! @relationship(type: "relatesTo", direction: IN)
}
----

.Test Data
[source,cypher,test-data=true]
----
MERGE (:Foo {name: "A"})-[:relatesTo]->(b1:Bar {name: "bar1"})
 MERGE (:Foo {name: "B"})
 MERGE (:Foo {name: "C"})-[:relatesTo]->(b3:Bar {name: "bar3"})
 MERGE (b1)-[:relatesTo]->(:FooBar {name: "a"})
 MERGE (b3)-[:relatesTo]->(:FooBar {name: "b"})
----

== querying multiple nested nodes should be sorted correctly

.GraphQL-Query
[source,graphql,request=true]
----
{
  foos(options: {sort: {name: ASC}}) {
    name
    bars {
      foobars {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Foo)
WITH *
ORDER BY this.name ASC
CALL {
    WITH this
    MATCH (this)-[this0:relatesTo]->(this1:Bar)
    CALL {
        WITH this1
        MATCH (this1)-[this2:relatesTo]->(this3:FooBar)
        WITH this3 { .name } AS this3
        RETURN collect(this3) AS var4
    }
    WITH this1 { foobars: var4 } AS this1
    RETURN collect(this1) AS var5
}
RETURN this { .name, bars: var5 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "foos": [
    {
      "name": "A",
      "bars": [
        {
          "foobars": [
            {
              "name": "a"
            }
          ]
        }
      ]
    },
    {
      "name": "B",
      "bars": []
    },
    {
      "name": "C",
      "bars": [
        {
          "foobars": [
            {
              "name": "b"
            }
          ]
        }
      ]
    }
  ]
}
----
