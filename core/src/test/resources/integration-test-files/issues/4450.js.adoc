// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/4450

== Setup

.Schema
[source,graphql,schema=true]
----
type Actor {
  name: String
  scene: [Scene!]! @relationship(type: "IN_SCENE", properties: "ActorScene", direction: OUT)
}

type Scene {
  number: Int
  actors: [Actor!]! @relationship(type: "IN_SCENE", properties: "ActorScene", direction: IN)
  location: Location! @relationship(type: "AT_LOCATION", direction: OUT)
}

type Location {
  city: String
  scenes: [Scene!]! @relationship(type: "AT_LOCATION", direction: IN)
}

type ActorScene @relationshipProperties {
  cut: Boolean
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (:Actor {name: "actor-1"})-[:IN_SCENE {cut: true}]->(:Scene {number: 1})-[:AT_LOCATION]->(:Location {city: "test"})
----

== filtering through a connection to a many-to-1 relationship should work

.GraphQL-Query
[source,graphql,request=true]
----
{
  actors(
    where: {sceneConnection_SOME: {edge: {cut: true}, node: {location: {city: "test"}}}}
  ) {
    name
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "test",
  "param1": true
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    MATCH (this)-[this0:IN_SCENE]->(this1:Scene)
    OPTIONAL MATCH (this1)-[:AT_LOCATION]->(this2:Location)
    WITH *, count(this2) AS locationCount
    WITH *
    WHERE ((locationCount <> 0 AND this2.city = $param0) AND this0.cut = $param1)
    RETURN count(this1) > 0 AS var3
}
WITH *
WHERE var3 = true
RETURN this { .name } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "actor-1"
    }
  ]
}
----
