// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/4532

== order-by relationship property

=== Setup

.Schema
[source,graphql,schema=true]
----
type Inventory {
  id: ID
  children: [Scenario!]! @relationship(type: "HasChildren", properties: "InventoryChildRelation", direction: OUT)
}

type Scenario {
  id: ID
}

type InventoryChildRelation @relationshipProperties {
  order: Int
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE(i:Inventory {id: "i1"})
 CREATE(i)-[:HasChildren { order: 3 }]->(c1:Scenario { id: "c3"})
 CREATE(i)-[:HasChildren { order: 1 }]->(c2:Scenario { id: "c1"})
 CREATE(i)-[:HasChildren { order: 2 }]->(c3:Scenario { id: "c2"})

 CREATE(:Inventory {id: "i2"})
----

=== should return all elements when ordering by nested connection

.GraphQL-Query
[source,graphql,request=true]
----
{
  inventories {
    id
    childrenConnection(sort: {edge: {order: ASC}}) {
      edges {
        properties {
          order
        }
        node {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Inventory)
CALL {
    WITH this
    MATCH (this)-[this0:HasChildren]->(this1:Scenario)
    WITH collect({ node: this1, relationship: this0 }) AS edges
    WITH edges, size(edges) AS totalCount
    CALL {
        WITH edges
        UNWIND edges AS edge
        WITH edge.node AS this1, edge.relationship AS this0
        WITH *
        ORDER BY this0.order ASC
        RETURN collect({ properties: { order: this0.order, __typename: "InventoryChildRelation" }, node: { id: this1.id, __typename: "Scenario" } }) AS var2
    }
    RETURN { edges: var2, totalCount: totalCount } AS var3
}
RETURN this { .id, childrenConnection: var3 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "inventories": [
    {
      "id": "i1",
      "childrenConnection": {
        "edges": [
          {
            "properties": {
              "order": 1
            },
            "node": {
              "id": "c1"
            }
          },
          {
            "properties": {
              "order": 2
            },
            "node": {
              "id": "c2"
            }
          },
          {
            "properties": {
              "order": 3
            },
            "node": {
              "id": "c3"
            }
          }
        ]
      }
    },
    {
      "id": "i2",
      "childrenConnection": {
        "edges": []
      }
    }
  ]
}
----

== order-by relationship property on interface node target

=== Setup

.Schema
[source,graphql,schema=true]
----
type Inventory {
  id: ID
  children: [Scenario!]! @relationship(type: "HasChildren", properties: "InventoryChildRelation", direction: OUT)
}

interface Scenario {
  id: ID
}

type Image implements Scenario {
  id: ID
}

type Video implements Scenario {
  id: ID
}

type InventoryChildRelation @relationshipProperties {
  order: Int
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE(i:Inventory {id: "i1"})
 CREATE(i)-[:HasChildren { order: 3 }]->(c1:Image { id: "c3"})
 CREATE(i)-[:HasChildren { order: 1 }]->(c2:Video { id: "c1"})
 CREATE(i)-[:HasChildren { order: 2 }]->(c3:Video { id: "c2"})

 CREATE(:Inventory {id: "i2"})
----

=== should return all elements when ordering by nested connection on an interface target

.GraphQL-Query
[source,graphql,request=true]
----
{
  inventories {
    id
    childrenConnection(sort: {edge: {order: ASC}}) {
      edges {
        properties {
          order
        }
        node {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Inventory)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:HasChildren]->(this1:Image)
        WITH { properties: { order: this0.order, __typename: "InventoryChildRelation" }, node: { __typename: "Image", __id: toString(id(this1)), id: this1.id } } AS edge
        RETURN edge
        UNION
        WITH this
        MATCH (this)-[this2:HasChildren]->(this3:Video)
        WITH { properties: { order: this2.order, __typename: "InventoryChildRelation" }, node: { __typename: "Video", __id: toString(id(this3)), id: this3.id } } AS edge
        RETURN edge
    }
    WITH collect(edge) AS edges
    WITH edges, size(edges) AS totalCount
    CALL {
        WITH edges
        UNWIND edges AS edge
        WITH edge
        ORDER BY edge.properties.order ASC
        RETURN collect(edge) AS var4
    }
    RETURN { edges: var4, totalCount: totalCount } AS var5
}
RETURN this { .id, childrenConnection: var5 } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "inventories": [
    {
      "id": "i2",
      "childrenConnection": {
        "edges": []
      }
    },
    {
      "id": "i1",
      "childrenConnection": {
        "edges": [
          {
            "properties": {
              "order": 1
            },
            "node": {
              "id": "c1"
            }
          },
          {
            "properties": {
              "order": 2
            },
            "node": {
              "id": "c2"
            }
          },
          {
            "properties": {
              "order": 3
            },
            "node": {
              "id": "c3"
            }
          }
        ]
      }
    }
  ]
}
----
