// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= Duration

== filter

=== Setup

.Schema
[source,graphql,schema=true]
----
type Movie {
  id: ID!
  duration: Duration!
}
----

=== should filter based on duration equality

.Test Data
[source,cypher,test-data=true]
----
CREATE (movie:Movie)
 SET movie = {id: "RandomString1", duration: duration("P0M4DT0S")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($id: ID!, $duration: Duration!) {
  movies(where: {id: $id, duration: $duration}) {
    id
    duration
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "id": "RandomString1",
  "duration": "P4D"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "RandomString1",
  "param1": "P0M4DT0S"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id = $param0 AND this.duration = $param1)
RETURN this { .id, .duration } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "duration": "P0M4DT0S"
    }
  ]
}
----

=== should filter based on duration comparison, for filter: LT

.Test Data
[source,cypher,test-data=true]
----
CREATE (long:Movie)
 SET long = {id: "RandomString1", duration: duration("P24M0DT0S")}
 CREATE (medium:Movie)
 SET medium = {id: "RandomString2", duration: duration("P2M0DT0S")}
 CREATE (short:Movie)
 SET short = {id: "RandomString3", duration: duration("P0M2DT0S")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{duration: ASC}]}) {
    id
    duration
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "duration_LT": "P2M"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "P2M0DT0S"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND (datetime() + this.duration) < (datetime() + $param1))
WITH *
ORDER BY this.duration ASC
RETURN this { .id, .duration } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "duration": "P0M2DT0S"
    }
  ]
}
----

=== should filter based on duration comparison, for filter: LTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (long:Movie)
 SET long = {id: "RandomString1", duration: duration("P24M0DT0S")}
 CREATE (medium:Movie)
 SET medium = {id: "RandomString2", duration: duration("P2M0DT0S")}
 CREATE (short:Movie)
 SET short = {id: "RandomString3", duration: duration("P0M2DT0S")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{duration: ASC}]}) {
    id
    duration
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "duration_LTE": "P2M"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "P2M0DT0S"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND (datetime() + this.duration) <= (datetime() + $param1))
WITH *
ORDER BY this.duration ASC
RETURN this { .id, .duration } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "duration": "P0M2DT0S"
    },
    {
      "id": "RandomString2",
      "duration": "P2M0DT0S"
    }
  ]
}
----

=== should filter based on duration comparison, for filter: GT

.Test Data
[source,cypher,test-data=true]
----
CREATE (long:Movie)
 SET long = {id: "RandomString1", duration: duration("P24M0DT0S")}
 CREATE (medium:Movie)
 SET medium = {id: "RandomString2", duration: duration("P2M0DT0S")}
 CREATE (short:Movie)
 SET short = {id: "RandomString3", duration: duration("P0M2DT0S")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{duration: ASC}]}) {
    id
    duration
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "duration_GT": "P2M"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "P2M0DT0S"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND (datetime() + this.duration) > (datetime() + $param1))
WITH *
ORDER BY this.duration ASC
RETURN this { .id, .duration } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "duration": "P24M0DT0S"
    }
  ]
}
----

=== should filter based on duration comparison, for filter: GTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (long:Movie)
 SET long = {id: "RandomString1", duration: duration("P24M0DT0S")}
 CREATE (medium:Movie)
 SET medium = {id: "RandomString2", duration: duration("P2M0DT0S")}
 CREATE (short:Movie)
 SET short = {id: "RandomString3", duration: duration("P0M2DT0S")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{duration: ASC}]}) {
    id
    duration
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "duration_GTE": "P2M"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "P2M0DT0S"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND (datetime() + this.duration) >= (datetime() + $param1))
WITH *
ORDER BY this.duration ASC
RETURN this { .id, .duration } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString2",
      "duration": "P2M0DT0S"
    },
    {
      "id": "RandomString1",
      "duration": "P24M0DT0S"
    }
  ]
}
----
