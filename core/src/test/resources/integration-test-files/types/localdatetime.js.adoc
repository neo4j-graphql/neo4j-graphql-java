// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= LocalDateTime

== Setup

.Schema
[source,graphql,schema=true]
----
type Movie {
  id: ID!
  localDT: LocalDateTime
  localDTs: [LocalDateTime!]
}
----

== filter

=== should filter based on localDT equality

.Test Data
[source,cypher,test-data=true]
----
CREATE (movie:Movie)
 SET movie = {id: "RandomString1", localDT: localdatetime("2024-09-17T11:49:48.322000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($localDT: LocalDateTime!) {
  movies(where: {localDT: $localDT}) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "localDT": "2024-09-17T11:49:48.322"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "2024-09-17T11:49:48.322000000"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.localDT = $param0
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "localDT": "2024-09-17T11:49:48.322000000"
    }
  ]
}
----

=== should filter based on localDT comparison, for filter LT

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", localDT: localdatetime("2025-02-18T18:10:55.462000000")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", localDT: localdatetime("2024-12-24T18:42:24.123000000")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", localDT: localdatetime("2022-08-29T10:21:43.108000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{localDT: ASC}]}) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "localDT_LT": "2024-12-24T18:42:24.123"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "2024-12-24T18:42:24.123000000"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.localDT < $param1)
WITH *
ORDER BY this.localDT ASC
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "localDT": "2022-08-29T10:21:43.108000000"
    }
  ]
}
----

=== should filter based on localDT comparison, for filter LTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", localDT: localdatetime("2025-02-18T18:10:55.462000000")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", localDT: localdatetime("2024-12-24T18:42:24.123000000")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", localDT: localdatetime("2022-08-29T10:21:43.108000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{localDT: ASC}]}) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "localDT_LTE": "2024-12-24T18:42:24.123"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "2024-12-24T18:42:24.123000000"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.localDT <= $param1)
WITH *
ORDER BY this.localDT ASC
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "localDT": "2022-08-29T10:21:43.108000000"
    },
    {
      "id": "RandomString2",
      "localDT": "2024-12-24T18:42:24.123000000"
    }
  ]
}
----

=== should filter based on localDT comparison, for filter GT

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", localDT: localdatetime("2025-02-18T18:10:55.462000000")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", localDT: localdatetime("2024-12-24T18:42:24.123000000")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", localDT: localdatetime("2022-08-29T10:21:43.108000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{localDT: ASC}]}) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "localDT_GT": "2024-12-24T18:42:24.123"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "2024-12-24T18:42:24.123000000"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.localDT > $param1)
WITH *
ORDER BY this.localDT ASC
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "localDT": "2025-02-18T18:10:55.462000000"
    }
  ]
}
----

=== should filter based on localDT comparison, for filter GTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", localDT: localdatetime("2025-02-18T18:10:55.462000000")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", localDT: localdatetime("2024-12-24T18:42:24.123000000")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", localDT: localdatetime("2022-08-29T10:21:43.108000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{localDT: ASC}]}) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "localDT_GTE": "2024-12-24T18:42:24.123"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "2024-12-24T18:42:24.123000000"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.localDT >= $param1)
WITH *
ORDER BY this.localDT ASC
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString2",
      "localDT": "2024-12-24T18:42:24.123000000"
    },
    {
      "id": "RandomString1",
      "localDT": "2025-02-18T18:10:55.462000000"
    }
  ]
}
----

== sorting

=== should sort based on localDT, sorting by ASC

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", localDT: localdatetime("2025-08-10T05:25:26.654000000")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", localDT: localdatetime("2024-12-24T18:42:24.123000000")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", localDT: localdatetime("2023-10-05T14:58:45.170000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($futureId: ID!, $presentId: ID!, $pastId: ID!, $sort: SortDirection!) {
  movies(
    where: {id_IN: [$futureId, $presentId, $pastId]}
    options: {sort: [{localDT: $sort}]}
  ) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "futureId": "RandomString1",
  "presentId": "RandomString2",
  "pastId": "RandomString3",
  "sort": "ASC"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
WITH *
ORDER BY this.localDT ASC
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "localDT": "2023-10-05T14:58:45.170000000"
    },
    {
      "id": "RandomString2",
      "localDT": "2024-12-24T18:42:24.123000000"
    },
    {
      "id": "RandomString1",
      "localDT": "2025-08-10T05:25:26.654000000"
    }
  ]
}
----

=== should sort based on localDT, sorting by DESC

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", localDT: localdatetime("2025-08-10T05:25:26.654000000")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", localDT: localdatetime("2024-12-24T18:42:24.123000000")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", localDT: localdatetime("2023-10-05T14:58:45.170000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($futureId: ID!, $presentId: ID!, $pastId: ID!, $sort: SortDirection!) {
  movies(
    where: {id_IN: [$futureId, $presentId, $pastId]}
    options: {sort: [{localDT: $sort}]}
  ) {
    id
    localDT
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "futureId": "RandomString1",
  "presentId": "RandomString2",
  "pastId": "RandomString3",
  "sort": "DESC"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
WITH *
ORDER BY this.localDT DESC
RETURN this { .id, .localDT } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "localDT": "2025-08-10T05:25:26.654000000"
    },
    {
      "id": "RandomString2",
      "localDT": "2024-12-24T18:42:24.123000000"
    },
    {
      "id": "RandomString3",
      "localDT": "2023-10-05T14:58:45.170000000"
    }
  ]
}
----
