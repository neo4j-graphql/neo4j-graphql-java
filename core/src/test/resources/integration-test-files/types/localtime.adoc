:toc:
:toclevels: 42

= LocalTime

== Setup

.Schema
[source,graphql,schema=true]
----
type Movie {
  id: ID!
  time: LocalTime
  times: [LocalTime!]
}
----

== filter

=== should filter based on time equality

.Test Data
[source,cypher,test-data=true]
----
CREATE (movie:Movie)
 SET movie = {id: "RandomString1", time: localtime("11:49:48.322000000")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($time: LocalTime!) {
  movies(where: {time: $time}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "id" : "RandomString1",
  "time" : "11:49:48.322"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "11:49:48.322"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.time = $param0
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString1",
    "time" : "11:49:48.322"
  } ]
}
----

=== should filter based on time comparison, for filter LT

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: localtime("13:00:00")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: localtime("12:00:00")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: localtime("11:00:00")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where" : {
    "id_IN" : [ "RandomString1", "RandomString2", "RandomString3" ],
    "time_LT" : "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : [ "RandomString1", "RandomString2", "RandomString3" ],
  "param1" : "12:00:00"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0
	AND this.time < $param1)
WITH * ORDER BY this.time ASC
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString3",
    "time" : "11:00"
  } ]
}
----

=== should filter based on time comparison, for filter LTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: localtime("13:00:00")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: localtime("12:00:00")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: localtime("11:00:00")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where" : {
    "id_IN" : [ "RandomString1", "RandomString2", "RandomString3" ],
    "time_LTE" : "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : [ "RandomString1", "RandomString2", "RandomString3" ],
  "param1" : "12:00:00"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0
	AND this.time <= $param1)
WITH * ORDER BY this.time ASC
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString3",
    "time" : "11:00"
  }, {
    "id" : "RandomString2",
    "time" : "12:00"
  } ]
}
----

=== should filter based on time comparison, for filter GT

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: localtime("13:00:00")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: localtime("12:00:00")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: localtime("11:00:00")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where" : {
    "id_IN" : [ "RandomString1", "RandomString2", "RandomString3" ],
    "time_GT" : "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : [ "RandomString1", "RandomString2", "RandomString3" ],
  "param1" : "12:00:00"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0
	AND this.time > $param1)
WITH * ORDER BY this.time ASC
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString1",
    "time" : "13:00"
  } ]
}
----

=== should filter based on time comparison, for filter GTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: localtime("13:00:00")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: localtime("12:00:00")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: localtime("11:00:00")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where" : {
    "id_IN" : [ "RandomString1", "RandomString2", "RandomString3" ],
    "time_GTE" : "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : [ "RandomString1", "RandomString2", "RandomString3" ],
  "param1" : "12:00:00"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0
	AND this.time >= $param1)
WITH * ORDER BY this.time ASC
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString2",
    "time" : "12:00"
  }, {
    "id" : "RandomString1",
    "time" : "13:00"
  } ]
}
----

== sorting

=== should sort based on time, sorting by ASC

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: localtime("13:00:00")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: localtime("12:00:00")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: localtime("11:00:00")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($futureId: ID!, $presentId: ID!, $pastId: ID!, $sort: SortDirection!) {
  movies(
    where: {id_IN: [$futureId, $presentId, $pastId]}
    options: {sort: [{time: $sort}]}
  ) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "futureId" : "RandomString1",
  "pastId" : "RandomString3",
  "presentId" : "RandomString2",
  "sort" : "ASC"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : [ "RandomString1", "RandomString2", "RandomString3" ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
WITH * ORDER BY this.time ASC
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString3",
    "time" : "11:00"
  }, {
    "id" : "RandomString2",
    "time" : "12:00"
  }, {
    "id" : "RandomString1",
    "time" : "13:00"
  } ]
}
----

=== should sort based on time, sorting by DESC

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: localtime("13:00:00")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: localtime("12:00:00")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: localtime("11:00:00")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($futureId: ID!, $presentId: ID!, $pastId: ID!, $sort: SortDirection!) {
  movies(
    where: {id_IN: [$futureId, $presentId, $pastId]}
    options: {sort: [{time: $sort}]}
  ) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "futureId" : "RandomString1",
  "pastId" : "RandomString3",
  "presentId" : "RandomString2",
  "sort" : "DESC"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : [ "RandomString1", "RandomString2", "RandomString3" ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
WITH * ORDER BY this.time DESC
RETURN this {
	.id,
	.time
} AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies" : [ {
    "id" : "RandomString1",
    "time" : "13:00"
  }, {
    "id" : "RandomString2",
    "time" : "12:00"
  }, {
    "id" : "RandomString3",
    "time" : "11:00"
  } ]
}
----
