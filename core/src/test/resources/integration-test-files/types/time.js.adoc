// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= Time

== filter

=== Setup

.Schema
[source,graphql,schema=true]
----
type Movie {
  id: ID!
  time: Time!
}
----

=== should filter based on time equality

.Test Data
[source,cypher,test-data=true]
----
CREATE (movie:Movie)
 SET movie = {id: "RandomString1", time: time("11:49:48.322000000Z")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($time: Time!) {
  movies(where: {time: $time}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "time": "11:49:48.322Z"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "11:49:48.322000000Z"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.time = $param0
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "time": "11:49:48.322000000Z"
    }
  ]
}
----

=== should filter based on time comparison for filter: LT

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: time("13:00:00Z")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: time("12:00:00Z")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: time("11:00:00Z")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "time_LT": "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "12:00:00Z"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.time < $param1)
WITH *
ORDER BY this.time ASC
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "time": "11:00:00Z"
    }
  ]
}
----

=== should filter based on time comparison for filter: LTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: time("13:00:00Z")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: time("12:00:00Z")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: time("11:00:00Z")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "time_LTE": "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "12:00:00Z"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.time <= $param1)
WITH *
ORDER BY this.time ASC
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "time": "11:00:00Z"
    },
    {
      "id": "RandomString2",
      "time": "12:00:00Z"
    }
  ]
}
----

=== should filter based on time comparison for filter: GT

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: time("13:00:00Z")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: time("12:00:00Z")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: time("11:00:00Z")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "time_GT": "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "12:00:00Z"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.time > $param1)
WITH *
ORDER BY this.time ASC
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "time": "13:00:00Z"
    }
  ]
}
----

=== should filter based on time comparison for filter: GTE

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: time("13:00:00Z")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: time("12:00:00Z")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: time("11:00:00Z")}
----

.GraphQL-Query
[source,graphql,request=true]
----
query ($where: MovieWhere!) {
  movies(where: $where, options: {sort: [{time: ASC}]}) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id_IN": [
      "RandomString1",
      "RandomString2",
      "RandomString3"
    ],
    "time_GTE": "12:00:00"
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ],
  "param1": "12:00:00Z"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE (this.id IN $param0 AND this.time >= $param1)
WITH *
ORDER BY this.time ASC
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString2",
      "time": "12:00:00Z"
    },
    {
      "id": "RandomString1",
      "time": "13:00:00Z"
    }
  ]
}
----

== sorting

=== Setup

.Schema
[source,graphql,schema=true]
----
type Movie {
  id: ID!
  time: Time!
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE (future:Movie)
 SET future = {id: "RandomString1", time: time("13:00:00Z")}
 CREATE (present:Movie)
 SET present = {id: "RandomString2", time: time("12:00:00Z")}
 CREATE (past:Movie)
 SET past = {id: "RandomString3", time: time("11:00:00Z")}
----

=== should sort based on time, sorted by: ASC

.GraphQL-Query
[source,graphql,request=true]
----
query ($futureId: ID!, $presentId: ID!, $pastId: ID!, $sort: SortDirection!) {
  movies(
    where: {id_IN: [$futureId, $presentId, $pastId]}
    options: {sort: [{time: $sort}]}
  ) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "futureId": "RandomString1",
  "presentId": "RandomString2",
  "pastId": "RandomString3",
  "sort": "ASC"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
WITH *
ORDER BY this.time ASC
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString3",
      "time": "11:00:00Z"
    },
    {
      "id": "RandomString2",
      "time": "12:00:00Z"
    },
    {
      "id": "RandomString1",
      "time": "13:00:00Z"
    }
  ]
}
----

=== should sort based on time, sorted by: DESC

.GraphQL-Query
[source,graphql,request=true]
----
query ($futureId: ID!, $presentId: ID!, $pastId: ID!, $sort: SortDirection!) {
  movies(
    where: {id_IN: [$futureId, $presentId, $pastId]}
    options: {sort: [{time: $sort}]}
  ) {
    id
    time
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "futureId": "RandomString1",
  "presentId": "RandomString2",
  "pastId": "RandomString3",
  "sort": "DESC"
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "RandomString1",
    "RandomString2",
    "RandomString3"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id IN $param0
WITH *
ORDER BY this.time DESC
RETURN this { .id, .time } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "movies": [
    {
      "id": "RandomString1",
      "time": "13:00:00Z"
    },
    {
      "id": "RandomString2",
      "time": "12:00:00Z"
    },
    {
      "id": "RandomString3",
      "time": "11:00:00Z"
    }
  ]
}
----
