// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= Union filtering

== Setup

.Schema
[source,graphql,schema=true]
----
union Production = Movie | Series

type Movie {
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}

type Series {
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}

type Actor {
  name: String!
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}

type ActedIn @relationshipProperties {
  screenTime: Int!
}
----

.Test Data
[source,cypher,test-data=true]
----
CREATE(m1:Movie { title: "The Office" })
 CREATE(m2:Movie { title: "The Office 2" })
 CREATE(m3:Movie { title: "NOT The Office 2" })
 CREATE(s1:Series { title: "The Office 2" })
 CREATE(s2:Series { title: "NOT The Office" })
 CREATE(a1:Actor {name: "Keanu"})
 CREATE(a2:Actor {name: "Michael"})
 CREATE(a3:Actor {name: "John"})
 MERGE(a1)-[:ACTED_IN]->(m1)
 MERGE(a1)-[:ACTED_IN]->(s2)
 MERGE(a2)-[:ACTED_IN]->(m2)
 MERGE(a2)-[:ACTED_IN]->(m3)
 MERGE(a2)-[:ACTED_IN]->(s1)
 MERGE(a3)-[:ACTED_IN]->(s1)
 MERGE(a3)-[:ACTED_IN]->(s2)
----

== allow for filtering on top-level union relationships

.GraphQL-Query
[source,graphql,request=true]
----
{
  productions(
    where: {Movie: {title: "The Office"}, Series: {title: "The Office 2"}}
  ) {
    ... on Movie {
      title
    }
    ... on Series {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Office",
  "param1": "The Office 2"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Movie)
    WHERE this0.title = $param0
    WITH this0 { .title, __typename: "Movie", __id: toString(id(this0)) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:Series)
    WHERE this1.title = $param1
    WITH this1 { .title, __typename: "Series", __id: toString(id(this1)) } AS this1
    RETURN this1 AS this
}
WITH this
RETURN this AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "productions": [
    {
      "title": "The Office"
    },
    {
      "title": "The Office 2"
    }
  ]
}
----

== allow for filtering on nested-level relationship unions

.GraphQL-Query
[source,graphql,request=true]
----
{
  actors(where: {actedIn_SOME: {Movie: {title_CONTAINS: "Office"}}}) {
    name
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Office"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE EXISTS {
    MATCH (this)-[:ACTED_IN]->(this0:Movie)
    WHERE this0.title CONTAINS $param0
}
RETURN this { .name } AS this
----

.GraphQL-Response
[source,json,response=true]
----
{
  "actors": [
    {
      "name": "Keanu"
    },
    {
      "name": "Michael"
    }
  ]
}
----
