:toc:

= Cypher Aggregations Many with Alias directive

== Source schema

[source,graphql,schema=true]
----
type Movie {
  id: ID! @alias(property: "_id")
  title: String! @alias(property: "_title")
  imdbRating: Int! @alias(property: "_imdb Rating")
  createdAt: DateTime! @alias(property: "_createdAt")
}
----
== Min

.GraphQL-Query
[source,graphql]
----
{
  moviesAggregate {
    id {
      shortest
      longest
    }
    title {
      shortest
      longest
    }
    imdbRating {
      min
      max
      average
    }
    createdAt {
      min
      max
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this:Movie)
    RETURN { shortest: min(this._id), longest: max(this._id) } AS var0
}
CALL {
    MATCH (this:Movie)
    WITH this
    ORDER BY size(this._title) DESC
    WITH collect(this._title) AS list
    RETURN { longest: head(list), shortest: last(list) } AS var1
}
CALL {
    MATCH (this:Movie)
    RETURN { min: min(this.`_imdb Rating`), max: max(this.`_imdb Rating`), average: avg(this.`_imdb Rating`) } AS var2
}
CALL {
    MATCH (this:Movie)
    RETURN { min: apoc.date.convertFormat(toString(min(this._createdAt)), "iso_zoned_date_time", "iso_offset_date_time"), max: apoc.date.convertFormat(toString(max(this._createdAt)), "iso_zoned_date_time", "iso_offset_date_time") } AS var3
}
RETURN { id: var0, title: var1, imdbRating: var2, createdAt: var3 }
----

'''

