:toc:

= Field Level Aggregations Where

== Source schema

[source,graphql,schema=true]
----
type Movie {
  title: String
  actors: [Person!]! @relationship(type: "ACTED_IN", direction: IN)
  directors: [Person!]! @relationship(type: "DIRECTED", direction: IN)
  released: DateTime
}

type Person {
  name: String
  age: Int
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----
== Count aggregation with colliding filter

.GraphQL-Query
[source,graphql]
----
{
  movies {
    title
    actorsAggregate(where: {name_CONTAINS: "abc"}) {
      count
    }
    directorsAggregate(where: {name_CONTAINS: "abcdefg"}) {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "abc",
  "param1" : "abcdefg"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
CALL {
	WITH this
	MATCH (this)<-[this0:ACTED_IN]-(this1:Person)
	WHERE this1.name CONTAINS $param0
	RETURN count(this1) AS var2
}
CALL {
	WITH this
	MATCH (this)<-[this3:DIRECTED]-(this4:Person)
	WHERE this4.name CONTAINS $param1
	RETURN count(this4) AS var5
}
RETURN this {
	.title,
	actorsAggregate: {
		count: var2
	},
	directorsAggregate: {
		count: var5
	}
} AS this
----

'''

== Count aggregation with number filter

.GraphQL-Query
[source,graphql]
----
{
  movies {
    title
    actorsAggregate(where: {age_GT: 40}) {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : 40
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
CALL {
	WITH this
	MATCH (this)<-[this0:ACTED_IN]-(this1:Person)
	WHERE this1.age > $param0
	RETURN count(this1) AS var2
}
RETURN this {
	.title,
	actorsAggregate: {
		count: var2
	}
} AS this
----

'''

