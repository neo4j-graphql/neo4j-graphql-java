:toc:

= connectOrCreate

== Source schema

[source,graphql,schema=true]
----
type JWT @jwt {
  roles: [String!]!
}

type Movie {
  title: String
  genres: [Genre!]! @relationship(type: "IN_GENRE", direction: OUT)
}

type Genre @authorization(validate: [{operations: [DELETE], where: {jwt: {roles_INCLUDES: "admin"}}}]) {
  name: String @unique
}
----
== Create -> nested connectOrCreate

=== Create with createOrConnect and DELETE operation rule

.GraphQL-Query
[source,graphql]
----
mutation {
  createMovies(
    input: [{title: "Cool Movie", genres: {connectOrCreate: [{where: {node: {name: "Horror"}}, onCreate: {node: {name: "Horror"}}}]}}]
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_title": "Cool Movie",
  "this0_genres_connectOrCreate_param0": "Horror",
  "this0_genres_connectOrCreate_param1": "Horror"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
CREATE (this0:Movie)
SET this0.title = $this0_title
WITH this0
CALL {
    WITH this0
    MERGE (this0_genres_connectOrCreate0:Genre { name: $this0_genres_connectOrCreate_param0 })
    ON CREATE SET
        this0_genres_connectOrCreate0.name = $this0_genres_connectOrCreate_param1
    MERGE (this0)-[this0_genres_connectOrCreate_this0:IN_GENRE]->(this0_genres_connectOrCreate0)
    RETURN count(*) AS _
}
RETURN this0
}
CALL {
    WITH this0
    RETURN this0 { .title } AS create_var0
}
RETURN [create_var0] AS data
----

'''


== Update -> connectOrCreate

=== Create with createOrConnect and DELETE operation rule

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    update: {title: "Cool Movie"}
    connectOrCreate: {genres: {where: {node: {name: "Horror"}}, onCreate: {node: {name: "Horror"}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_update_title": "Cool Movie",
  "this_connectOrCreate_genres_param0": "Horror",
  "this_connectOrCreate_genres_param1": "Horror"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)


SET this.title = $this_update_title

WITH this
CALL {
    WITH this
    MERGE (this_connectOrCreate_genres0:Genre { name: $this_connectOrCreate_genres_param0 })
    ON CREATE SET
        this_connectOrCreate_genres0.name = $this_connectOrCreate_genres_param1
    MERGE (this)-[this_connectOrCreate_genres_this0:IN_GENRE]->(this_connectOrCreate_genres0)
    RETURN count(*) AS _
}
WITH *
RETURN collect(DISTINCT this { .title }) AS data
----

'''


== Update -> nested connectOrCreate

=== Create with createOrConnect and DELETE operation rule

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    update: {title: "Cool Movie", genres: {connectOrCreate: [{where: {node: {name: "Horror"}}, onCreate: {node: {name: "Horror"}}}]}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_update_title": "Cool Movie",
  "this_genres0_connectOrCreate_param0": "Horror",
  "this_genres0_connectOrCreate_param1": "Horror"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)


SET this.title = $this_update_title
WITH this
CALL {
    WITH this
    MERGE (this_genres0_connectOrCreate0:Genre { name: $this_genres0_connectOrCreate_param0 })
    ON CREATE SET
        this_genres0_connectOrCreate0.name = $this_genres0_connectOrCreate_param1
    MERGE (this)-[this_genres0_connectOrCreate_this0:IN_GENRE]->(this_genres0_connectOrCreate0)
    RETURN count(*) AS _
}

RETURN collect(DISTINCT this { .title }) AS data
----

'''


