:toc:

= Update -> connectOrCreate

== Source schema

[source,graphql,schema=true]
----
type Movie {
  title: String
  genres: [Genre!]! @relationship(type: "IN_GENRE", direction: OUT)
}

type Genre {
  name: String @unique
}

extend type Genre @auth(rules: [{operations: [CREATE], allow: {name: "$jwt.sub"}}])
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Create with createOrConnect and allow in auth

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    update: {title: "Cool Movie"}
    connectOrCreate: {genres: {where: {node: {name: "Horror"}}, onCreate: {node: {name: "Horror"}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {},
  "contextParams": {
    "jwt": {
      "sub": "test"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_connectOrCreate_genres0auth_param0" : "test",
  "this_connectOrCreate_genres_param0" : "Horror",
  "this_connectOrCreate_genres_param1" : "Horror",
  "this_update_title" : "Cool Movie"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
SET this.title = $this_update_title
WITH this
CALL {
	WITH this
	MERGE (this_connectOrCreate_genres0:Genre {
		name: $this_connectOrCreate_genres_param0
	})
	ON CREATE SET this_connectOrCreate_genres0.name = $this_connectOrCreate_genres_param1
	MERGE (this)-[this_connectOrCreate_genres_this0:IN_GENRE]->(this_connectOrCreate_genres0)
	WITH * CALL apoc.util.validate(NOT ((this_connectOrCreate_genres0.name IS NOT NULL
		AND this_connectOrCreate_genres0.name = $this_connectOrCreate_genres0auth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
	RETURN count(*) AS _
}
WITH *
RETURN collect(DISTINCT this {
	.title
}) AS data
----

'''

