:toc:

= Update -> connectOrCreate

== Source schema

[source,graphql,schema=true]
----
type Movie {
  title: String
  genres: [Genre!]! @relationship(type: "IN_GENRE", direction: OUT)
}

type Genre {
  name: String @unique
}

extend type Genre @authorization(validate: [{when: [BEFORE], operations: [CREATE], where: {node: {name: "$jwt.sub"}}}])
----
== Create with createOrConnect and allow in auth

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    update: {title: "Cool Movie"}
    connectOrCreate: {genres: {where: {node: {name: "Horror"}}, onCreate: {node: {name: "Horror"}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_update_title": "Cool Movie",
  "this_connectOrCreate_genres_param0": "Horror",
  "this_connectOrCreate_genres_param1": "Horror"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)


SET this.title = $this_update_title

WITH this
CALL {
    WITH this
    MERGE (this_connectOrCreate_genres0:Genre { name: $this_connectOrCreate_genres_param0 })
    ON CREATE SET
        this_connectOrCreate_genres0.name = $this_connectOrCreate_genres_param1
    MERGE (this)-[this_connectOrCreate_genres_this0:IN_GENRE]->(this_connectOrCreate_genres0)
    RETURN count(*) AS _
}
WITH *
RETURN collect(DISTINCT this { .title }) AS data
----

'''

