:toc:

= @auth allow when inherited from interface

== Source schema

[source,graphql,schema=true]
----
interface Content @auth(rules: [{operations: [READ, UPDATE, DELETE, DISCONNECT, CONNECT], allow: {creator: {id: "$jwt.sub"}}}]) {
  id: ID
  content: String
}

type Comment implements Content {
  id: ID
  content: String
  creator: User! @relationship(type: "HAS_COMMENT", direction: IN)
  post: Post! @relationship(type: "HAS_COMMENT", direction: IN)
}

type Post implements Content {
  id: ID
  content: String
  creator: User! @relationship(type: "HAS_POST", direction: IN)
  comments: [Comment!]! @relationship(type: "HAS_COMMENT", direction: OUT)
}

type User {
  id: ID
  name: String
  posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}

extend type User @auth(rules: [{operations: [READ, UPDATE, DELETE, DISCONNECT, CONNECT], allow: {id: "$jwt.sub"}}])

extend type User {
  password: String! @auth(rules: [{operations: [READ, UPDATE, DELETE], allow: {id: "$jwt.sub"}}])
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Connect Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(
    where: {id: "user-id"}
    connect: {posts: {where: {node: {id: "post-id"}}}}
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_connect_posts0_node_param0" : "post-id",
  "this_connect_posts0_nodeauth_param0" : "user-id",
  "thisauth_param0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_posts0_node:Post)
	WHERE this_connect_posts0_node.id = $this_connect_posts0_node_param0
	WITH this, this_connect_posts0_node CALL apoc.util.validate(NOT ((exists((this_connect_posts0_node)<-[:HAS_POST]-(:User))
		AND any(auth_this0 IN [(this_connect_posts0_node)<-[:HAS_POST]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_connect_posts0_nodeauth_param0))
		AND this.id IS NOT NULL
		AND this.id = $thisauth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH *
		WITH collect(this_connect_posts0_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_posts0_node
			MERGE (this)-[:HAS_POST]->(this_connect_posts0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_posts0_node
	RETURN count(*) AS connect_this_connect_posts_Post
}
WITH *
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Delete Node

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers(where: {id: "user-id"}) {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "thisauth_param0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((this.id IS NOT NULL
	AND this.id = $thisauth_param0)), '@neo4j/graphql/FORBIDDEN', [0]) DETACH DELETE this
----

'''

== Disconnect Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(
    where: {id: "user-id"}
    disconnect: {posts: {where: {node: {id: "post-id"}}}}
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_disconnect_posts0auth_param0" : "user-id",
  "thisauth_param0" : "user-id",
  "updateUsers" : {
    "args" : {
      "disconnect" : {
        "posts" : [ {
          "where" : {
            "node" : {
              "id" : "post-id"
            }
          }
        } ]
      }
    }
  },
  "updateUsers_args_disconnect_posts0_where_Postparam0" : "post-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this)-[this_disconnect_posts0_rel:HAS_POST]->(this_disconnect_posts0:Post)
	WHERE this_disconnect_posts0.id = $updateUsers_args_disconnect_posts0_where_Postparam0
	WITH this, this_disconnect_posts0, this_disconnect_posts0_rel CALL apoc.util.validate(NOT ((this.id IS NOT NULL
		AND this.id = $thisauth_param0
		AND exists((this_disconnect_posts0)<-[:HAS_POST]-(:User))
		AND any(auth_this0 IN [(this_disconnect_posts0)<-[:HAS_POST]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_disconnect_posts0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH this_disconnect_posts0, this_disconnect_posts0_rel, this
		WITH collect(this_disconnect_posts0) AS this_disconnect_posts0, this_disconnect_posts0_rel, this
		UNWIND this_disconnect_posts0 AS x DELETE this_disconnect_posts0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_posts_Post
}
WITH *
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Nested Delete Node

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers(
    where: {id: "user-id"}
    delete: {posts: {where: {node: {id: "post-id"}}}}
  ) {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_deleteUsers" : {
    "args" : {
      "delete" : {
        "posts" : [ {
          "where" : {
            "node" : {
              "id" : "post-id"
            }
          }
        } ]
      }
    }
  },
  "this_deleteUsers_args_delete_posts0_where_Postparam0" : "post-id",
  "this_posts0auth_param0" : "user-id",
  "thisauth_param0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this
OPTIONAL MATCH (this)-[this_posts0_relationship:HAS_POST]->(this_posts0:Post)
WHERE this_posts0.id = $this_deleteUsers_args_delete_posts0_where_Postparam0
WITH this, this_posts0 CALL apoc.util.validate(NOT ((exists((this_posts0)<-[:HAS_POST]-(:User))
	AND any(auth_this0 IN [(this_posts0)<-[:HAS_POST]-(auth_this0) | auth_this0]
	WHERE (auth_this0.id IS NOT NULL
		AND auth_this0.id = $this_posts0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
WITH this, collect(DISTINCT this_posts0) AS this_posts0_to_delete
CALL {
	WITH this_posts0_to_delete
	UNWIND this_posts0_to_delete AS x DETACH DELETE x
	RETURN count(*) AS _
}
WITH this CALL apoc.util.validate(NOT ((this.id IS NOT NULL
	AND this.id = $thisauth_param0)), '@neo4j/graphql/FORBIDDEN', [0]) DETACH DELETE this
----

'''

== Nested Disconnect Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateComments(
    where: {id: "comment-id"}
    update: {post: {disconnect: {disconnect: {creator: {where: {node: {id: "user-id"}}}}}}}
  ) {
    comments {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "comment-id",
  "this_post0_disconnect0_creator0auth_param0" : "user-id",
  "this_post0_disconnect0auth_param0" : "user-id",
  "thisauth_param0" : "user-id",
  "updateComments" : {
    "args" : {
      "update" : {
        "post" : {
          "disconnect" : {
            "disconnect" : {
              "creator" : {
                "where" : {
                  "node" : {
                    "id" : "user-id"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "updateComments_args_update_post_disconnect_disconnect_creator_where_Userparam0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Comment)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((exists((this)<-[:HAS_COMMENT]-(:User))
	AND any(auth_this0 IN [(this)<-[:HAS_COMMENT]-(auth_this0) | auth_this0]
	WHERE (auth_this0.id IS NOT NULL
		AND auth_this0.id = $thisauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this)<-[this_post0_disconnect0_rel:HAS_COMMENT]-(this_post0_disconnect0:Post)
	WITH this, this_post0_disconnect0, this_post0_disconnect0_rel CALL apoc.util.validate(NOT ((exists((this)<-[:HAS_COMMENT]-(:User))
		AND any(auth_this0 IN [(this)<-[:HAS_COMMENT]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $thisauth_param0))
		AND exists((this_post0_disconnect0)<-[:HAS_POST]-(:User))
		AND any(auth_this0 IN [(this_post0_disconnect0)<-[:HAS_POST]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_post0_disconnect0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH this_post0_disconnect0, this_post0_disconnect0_rel, this
		WITH collect(this_post0_disconnect0) AS this_post0_disconnect0, this_post0_disconnect0_rel, this
		UNWIND this_post0_disconnect0 AS x DELETE this_post0_disconnect0_rel
		RETURN count(*) AS _
	}
	CALL {
		WITH this, this_post0_disconnect0
		OPTIONAL MATCH (this_post0_disconnect0)<-[this_post0_disconnect0_creator0_rel:HAS_POST]-(this_post0_disconnect0_creator0:User)
		WHERE this_post0_disconnect0_creator0.id = $updateComments_args_update_post_disconnect_disconnect_creator_where_Userparam0
		WITH this, this_post0_disconnect0, this_post0_disconnect0_creator0, this_post0_disconnect0_creator0_rel CALL apoc.util.validate(NOT ((exists((this_post0_disconnect0)<-[:HAS_POST]-(:User))
			AND any(auth_this0 IN [(this_post0_disconnect0)<-[:HAS_POST]-(auth_this0:User) | auth_this0]
			WHERE (auth_this0.id IS NOT NULL
				AND auth_this0.id = $this_post0_disconnect0auth_param0))
			AND this_post0_disconnect0_creator0.id IS NOT NULL
			AND this_post0_disconnect0_creator0.id = $this_post0_disconnect0_creator0auth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
		CALL {
			WITH this_post0_disconnect0_creator0, this_post0_disconnect0_creator0_rel, this_post0_disconnect0
			WITH collect(this_post0_disconnect0_creator0) AS this_post0_disconnect0_creator0, this_post0_disconnect0_creator0_rel, this_post0_disconnect0
			UNWIND this_post0_disconnect0_creator0 AS x DELETE this_post0_disconnect0_creator0_rel
			RETURN count(*) AS _
		}
		RETURN count(*) AS disconnect_this_post0_disconnect0_creator_User
	}
	RETURN count(*) AS disconnect_this_post0_disconnect_Post
}
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_creator_User_unique:HAS_COMMENT]-(:User)
	WITH count(this_creator_User_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDComment.creator required exactly once', [0])
	RETURN c AS this_creator_User_unique_ignored
}
CALL {
	WITH this
	MATCH (this)<-[this_post_Post_unique:HAS_COMMENT]-(:Post)
	WITH count(this_post_Post_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDComment.post required exactly once', [0])
	RETURN c AS this_post_Post_unique_ignored
}
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Nested Update Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updatePosts(
    where: {id: "post-id"}
    update: {creator: {update: {node: {id: "new-id"}}}}
  ) {
    posts {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "post-id",
  "this_creator0auth_param0" : "user-id",
  "this_update_creator0_id" : "new-id",
  "thisauth_param0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((exists((this)<-[:HAS_POST]-(:User))
	AND any(auth_this0 IN [(this)<-[:HAS_POST]-(auth_this0) | auth_this0]
	WHERE (auth_this0.id IS NOT NULL
		AND auth_this0.id = $thisauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_has_post0_relationship:HAS_POST]-(this_creator0:User)
	WITH this, this_creator0 CALL apoc.util.validate(NOT ((this_creator0.id IS NOT NULL
		AND this_creator0.id = $this_creator0auth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
	SET this_creator0.id = $this_update_creator0_id
	RETURN count(*) AS update_this_creator0
}
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_creator_User_unique:HAS_POST]-(:User)
	WITH count(this_creator_User_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDPost.creator required exactly once', [0])
	RETURN c AS this_creator_User_unique_ignored
}
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Nested Update Property

.GraphQL-Query
[source,graphql]
----
mutation {
  updatePosts(
    where: {id: "post-id"}
    update: {creator: {update: {node: {password: "new-password"}}}}
  ) {
    posts {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "post-id",
  "this_creator0auth_param0" : "user-id",
  "this_update_creator0_password" : "new-password",
  "thisauth_param0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((exists((this)<-[:HAS_POST]-(:User))
	AND any(auth_this0 IN [(this)<-[:HAS_POST]-(auth_this0) | auth_this0]
	WHERE (auth_this0.id IS NOT NULL
		AND auth_this0.id = $thisauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_has_post0_relationship:HAS_POST]-(this_creator0:User)
	WITH this, this_creator0 CALL apoc.util.validate(NOT ((this_creator0.id IS NOT NULL
		AND this_creator0.id = $this_creator0auth_param0
		AND this_creator0.id IS NOT NULL
		AND this_creator0.id = $this_creator0auth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
	SET this_creator0.password = $this_update_creator0_password
	RETURN count(*) AS update_this_creator0
}
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_creator_User_unique:HAS_POST]-(:User)
	WITH count(this_creator_User_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDPost.creator required exactly once', [0])
	RETURN c AS this_creator_User_unique_ignored
}
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Read Node

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE apoc.util.validatePredicate(NOT ((this.id IS NOT NULL
	AND this.id = $param0)), '@neo4j/graphql/FORBIDDEN', [0])
RETURN this {
	.id
} AS this
----

'''

== Read Node & Protected Field

.GraphQL-Query
[source,graphql]
----
{
  users {
    password
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "id-01",
  "thisauth_param0" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE apoc.util.validatePredicate(NOT ((this.id IS NOT NULL
	AND this.id = $param0)), '@neo4j/graphql/FORBIDDEN', [0]) CALL apoc.util.validate(NOT ((this.id IS NOT NULL
	AND this.id = $thisauth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
RETURN this {
	.password
} AS this
----

'''

== Read Relationship

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    posts {
      content
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "id-01",
  "param1" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE apoc.util.validatePredicate(NOT ((this.id IS NOT NULL
	AND this.id = $param0)), '@neo4j/graphql/FORBIDDEN', [0])
CALL {
	WITH this
	MATCH (this)-[this0:HAS_POST]->(this_posts:Post)
	WHERE apoc.util.validatePredicate(NOT ((exists((this_posts)<-[:HAS_POST]-(:User))
		AND any(this1 IN [(this_posts)<-[:HAS_POST]-(this1:User) | this1]
		WHERE (this1.id IS NOT NULL
			AND this1.id = $param1)))), '@neo4j/graphql/FORBIDDEN', [0])
	WITH this_posts {
		.content
	} AS this_posts
	RETURN collect(this_posts) AS this_posts
}
RETURN this {
	.id,
	posts: this_posts
} AS this
----

'''

== Read Relationship & Protected Field

.GraphQL-Query
[source,graphql]
----
{
  posts {
    creator {
      password
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "id-01",
  "param1" : "id-01",
  "this_creatorauth_param0" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE apoc.util.validatePredicate(NOT ((exists((this)<-[:HAS_POST]-(:User))
	AND any(this0 IN [(this)<-[:HAS_POST]-(this0) | this0]
	WHERE (this0.id IS NOT NULL
		AND this0.id = $param0)))), '@neo4j/graphql/FORBIDDEN', [0])
CALL {
	WITH this
	MATCH (this_creator:User)-[this1:HAS_POST]->(this)
	WHERE (apoc.util.validatePredicate(NOT ((this_creator.id IS NOT NULL
			AND this_creator.id = $param1)), '@neo4j/graphql/FORBIDDEN', [0])
		AND apoc.util.validatePredicate(NOT ((this_creator.id IS NOT NULL
			AND this_creator.id = $this_creatorauth_param0)), '@neo4j/graphql/FORBIDDEN', [0]))
	WITH this_creator {
		.password
	} AS this_creator
	RETURN head(collect(this_creator)) AS this_creator
}
RETURN this {
	creator: this_creator
} AS this
----

'''

== Read Two Relationships

.GraphQL-Query
[source,graphql]
----
{
  users(where: {id: "1"}) {
    id
    posts(where: {id: "1"}) {
      comments(where: {id: "1"}) {
        content
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "1",
  "param1" : "id-01",
  "param2" : "1",
  "param3" : "id-01",
  "param4" : "1",
  "param5" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE (this.id = $param0
	AND apoc.util.validatePredicate(NOT ((this.id IS NOT NULL
		AND this.id = $param1)), '@neo4j/graphql/FORBIDDEN', [0]))
CALL {
	WITH this
	MATCH (this)-[this0:HAS_POST]->(this_posts:Post)
	WHERE (this_posts.id = $param2
		AND apoc.util.validatePredicate(NOT ((exists((this_posts)<-[:HAS_POST]-(:User))
			AND any(this1 IN [(this_posts)<-[:HAS_POST]-(this1:User) | this1]
			WHERE (this1.id IS NOT NULL
				AND this1.id = $param3)))), '@neo4j/graphql/FORBIDDEN', [0]))
	CALL {
		WITH this_posts
		MATCH (this_posts)-[this2:HAS_COMMENT]->(this_posts_comments:Comment)
		WHERE (this_posts_comments.id = $param4
			AND apoc.util.validatePredicate(NOT ((exists((this_posts_comments)<-[:HAS_COMMENT]-(:User))
				AND any(this3 IN [(this_posts_comments)<-[:HAS_COMMENT]-(this3:User) | this3]
				WHERE (this3.id IS NOT NULL
					AND this3.id = $param5)))), '@neo4j/graphql/FORBIDDEN', [0]))
		WITH this_posts_comments {
			.content
		} AS this_posts_comments
		RETURN collect(this_posts_comments) AS this_posts_comments
	}
	WITH this_posts {
		comments: this_posts_comments
	} AS this_posts
	RETURN collect(this_posts) AS this_posts
}
RETURN this {
	.id,
	posts: this_posts
} AS this
----

'''

== Update Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {id: "old-id"}, update: {id: "new-id"}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "old-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "old-id",
  "this_update_id" : "new-id",
  "thisauth_param0" : "old-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((this.id IS NOT NULL
	AND this.id = $thisauth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
SET this.id = $this_update_id
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Update Node Property

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {id: "id-01"}, update: {password: "new-password"}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "id-01",
  "this_update_password" : "new-password",
  "thisauth_param0" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((this.id IS NOT NULL
	AND this.id = $thisauth_param0
	AND this.id IS NOT NULL
	AND this.id = $thisauth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
SET this.password = $this_update_password
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

