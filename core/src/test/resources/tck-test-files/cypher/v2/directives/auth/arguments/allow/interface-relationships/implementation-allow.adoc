:toc:

= @auth allow on specific interface implementation

== Source schema

[source,graphql,schema=true]
----
interface Content {
  id: ID
  content: String
  creator: User! @relationship(type: "HAS_CONTENT", direction: IN)
}

type Comment implements Content {
  id: ID
  content: String
  creator: User!
  post: Post! @relationship(type: "HAS_COMMENT", direction: IN)
}

type Post implements Content @auth(rules: [{operations: [READ, UPDATE, DELETE, DISCONNECT, CONNECT], allow: {creator: {id: "$jwt.sub"}}}]) {
  id: ID
  content: String
  creator: User!
  comments: [Comment!]! @relationship(type: "HAS_COMMENT", direction: OUT)
}

type User {
  id: ID
  name: String
  content: [Content!]! @relationship(type: "HAS_CONTENT", direction: OUT)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Connect node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(
    where: {id: "user-id"}
    connect: {content: {where: {node: {id: "post-id"}}}}
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_connect_content0_nodeparam0" : "post-id",
  "this_connect_content1_nodeauth_param0" : "user-id",
  "this_connect_content1_nodeparam0" : "post-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_content0_node:Comment)
	WHERE this_connect_content0_node.id = $this_connect_content0_nodeparam0
	CALL {
		WITH *
		WITH collect(this_connect_content0_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_content0_node
			MERGE (this)-[:HAS_CONTENT]->(this_connect_content0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_content0_node
	RETURN count(*) AS connect_this_connect_content_Comment
}
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_content1_node:Post)
	WHERE this_connect_content1_node.id = $this_connect_content1_nodeparam0
	WITH this, this_connect_content1_node
	CALL apoc.util.validate(NOT ((exists((this_connect_content1_node)<-[:HAS_CONTENT]-(:User))
		AND any(auth_this0 IN [(this_connect_content1_node)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_connect_content1_nodeauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH *
		WITH collect(this_connect_content1_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_content1_node
			MERGE (this)-[:HAS_CONTENT]->(this_connect_content1_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_content1_node
	RETURN count(*) AS connect_this_connect_content_Post
}
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Disconnect Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(
    where: {id: "user-id"}
    disconnect: {content: {where: {node: {id: "post-id"}}}}
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_disconnect_content0auth_param0" : "user-id",
  "updateUsers_args_disconnect_content0_where_Commentparam0" : "post-id",
  "updateUsers_args_disconnect_content0_where_Postparam0" : "post-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
CALL {
	WITH this
	OPTIONAL MATCH (this)-[this_disconnect_content0_rel:HAS_CONTENT]->(this_disconnect_content0:Comment)
	WHERE this_disconnect_content0.id = $updateUsers_args_disconnect_content0_where_Commentparam0
	CALL {
		WITH this_disconnect_content0, this_disconnect_content0_rel, this
		WITH collect(this_disconnect_content0) AS this_disconnect_content0, this_disconnect_content0_rel, this
		UNWIND this_disconnect_content0 AS x
		DELETE this_disconnect_content0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_content_Comment
}
CALL {
	WITH this
	OPTIONAL MATCH (this)-[this_disconnect_content0_rel:HAS_CONTENT]->(this_disconnect_content0:Post)
	WHERE this_disconnect_content0.id = $updateUsers_args_disconnect_content0_where_Postparam0
	WITH this, this_disconnect_content0, this_disconnect_content0_rel
	CALL apoc.util.validate(NOT ((exists((this_disconnect_content0)<-[:HAS_CONTENT]-(:User))
		AND any(auth_this0 IN [(this_disconnect_content0)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_disconnect_content0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH this_disconnect_content0, this_disconnect_content0_rel, this
		WITH collect(this_disconnect_content0) AS this_disconnect_content0, this_disconnect_content0_rel, this
		UNWIND this_disconnect_content0 AS x
		DELETE this_disconnect_content0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_content_Post
}
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Nested Delete Node

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers(
    where: {id: "user-id"}
    delete: {content: {where: {node: {id: "post-id"}}}}
  ) {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_content_Post0auth_param0" : "user-id",
  "this_deleteUsers_args_delete_content0_where_Commentparam0" : "post-id",
  "this_deleteUsers_args_delete_content0_where_Postparam0" : "post-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this
OPTIONAL MATCH (this)-[this_content_Comment0_relationship:HAS_CONTENT]->(this_content_Comment0:Comment)
WHERE this_content_Comment0.id = $this_deleteUsers_args_delete_content0_where_Commentparam0
WITH this, collect(DISTINCT this_content_Comment0) AS this_content_Comment0_to_delete
CALL {
	WITH this_content_Comment0_to_delete
	UNWIND this_content_Comment0_to_delete AS x
	DETACH DELETE x
	RETURN count(*) AS _
}
WITH this
OPTIONAL MATCH (this)-[this_content_Post0_relationship:HAS_CONTENT]->(this_content_Post0:Post)
WHERE this_content_Post0.id = $this_deleteUsers_args_delete_content0_where_Postparam0
WITH this, this_content_Post0
CALL apoc.util.validate(NOT ((exists((this_content_Post0)<-[:HAS_CONTENT]-(:User))
	AND any(auth_this0 IN [(this_content_Post0)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
	WHERE (auth_this0.id IS NOT NULL
		AND auth_this0.id = $this_content_Post0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
WITH this, collect(DISTINCT this_content_Post0) AS this_content_Post0_to_delete
CALL {
	WITH this_content_Post0_to_delete
	UNWIND this_content_Post0_to_delete AS x
	DETACH DELETE x
	RETURN count(*) AS _
}
DETACH DELETE this
----

'''

== Nested Disconnect Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(
    where: {id: "user-id"}
    disconnect: {content: {where: {node: {id: "post-id"}}, disconnect: {_on: {Post: {comments: {where: {node: {id: "comment-id"}}}}}}}}
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_disconnect_content0auth_param0" : "user-id",
  "updateUsers_args_disconnect_content0_disconnect__on_Post0_comments0_where_Commentparam0" : "comment-id",
  "updateUsers_args_disconnect_content0_where_Commentparam0" : "post-id",
  "updateUsers_args_disconnect_content0_where_Postparam0" : "post-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
CALL {
	WITH this
	OPTIONAL MATCH (this)-[this_disconnect_content0_rel:HAS_CONTENT]->(this_disconnect_content0:Comment)
	WHERE this_disconnect_content0.id = $updateUsers_args_disconnect_content0_where_Commentparam0
	CALL {
		WITH this_disconnect_content0, this_disconnect_content0_rel, this
		WITH collect(this_disconnect_content0) AS this_disconnect_content0, this_disconnect_content0_rel, this
		UNWIND this_disconnect_content0 AS x
		DELETE this_disconnect_content0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_content_Comment
}
CALL {
	WITH this
	OPTIONAL MATCH (this)-[this_disconnect_content0_rel:HAS_CONTENT]->(this_disconnect_content0:Post)
	WHERE this_disconnect_content0.id = $updateUsers_args_disconnect_content0_where_Postparam0
	WITH this, this_disconnect_content0, this_disconnect_content0_rel
	CALL apoc.util.validate(NOT ((exists((this_disconnect_content0)<-[:HAS_CONTENT]-(:User))
		AND any(auth_this0 IN [(this_disconnect_content0)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_disconnect_content0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH this_disconnect_content0, this_disconnect_content0_rel, this
		WITH collect(this_disconnect_content0) AS this_disconnect_content0, this_disconnect_content0_rel, this
		UNWIND this_disconnect_content0 AS x
		DELETE this_disconnect_content0_rel
		RETURN count(*) AS _
	}
	CALL {
		WITH this, this_disconnect_content0
		OPTIONAL MATCH (this_disconnect_content0)-[this_disconnect_content0_comments0_rel:HAS_COMMENT]->(this_disconnect_content0_comments0:Comment)
		WHERE this_disconnect_content0_comments0.id = $updateUsers_args_disconnect_content0_disconnect__on_Post0_comments0_where_Commentparam0
		WITH this, this_disconnect_content0, this_disconnect_content0_comments0, this_disconnect_content0_comments0_rel
		CALL apoc.util.validate(NOT ((exists((this_disconnect_content0)<-[:HAS_CONTENT]-(:User))
			AND any(auth_this0 IN [(this_disconnect_content0)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
			WHERE (auth_this0.id IS NOT NULL
				AND auth_this0.id = $this_disconnect_content0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
		CALL {
			WITH this_disconnect_content0_comments0, this_disconnect_content0_comments0_rel, this_disconnect_content0
			WITH collect(this_disconnect_content0_comments0) AS this_disconnect_content0_comments0, this_disconnect_content0_comments0_rel, this_disconnect_content0
			UNWIND this_disconnect_content0_comments0 AS x
			DELETE this_disconnect_content0_comments0_rel
			RETURN count(*) AS _
		}
		RETURN count(*) AS disconnect_this_disconnect_content0_comments_Comment
	}
	RETURN count(*) AS disconnect_this_disconnect_content_Post
}
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Nested Update Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(
    where: {id: "user-id"}
    update: {content: {update: {node: {id: "new-id"}}}}
  ) {
    users {
      id
      content {
        id
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "user-id"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "user-id",
  "this_Postauth_param0" : "user-id",
  "this_content0auth_param0" : "user-id",
  "this_update_content0_id" : "new-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
CALL {
	WITH this
	MATCH (this)-[this_has_content0_relationship:HAS_CONTENT]->(this_content0:Comment)
	SET this_content0.id = $this_update_content0_id
	WITH this, this_content0
	CALL {
		WITH this_content0
		MATCH (this_content0)<-[this_content0_creator_User_unique:HAS_CONTENT]-(:User)
		WITH count(this_content0_creator_User_unique) AS c
		CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDComment.creator required', [0])
		RETURN c AS this_content0_creator_User_unique_ignored
	}
	CALL {
		WITH this_content0
		MATCH (this_content0)<-[this_content0_post_Post_unique:HAS_COMMENT]-(:Post)
		WITH count(this_content0_post_Post_unique) AS c
		CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDComment.post required', [0])
		RETURN c AS this_content0_post_Post_unique_ignored
	}
	RETURN count(*) AS update_this_Comment
}
CALL {
	WITH this
	MATCH (this)-[this_has_content0_relationship:HAS_CONTENT]->(this_content0:Post)
	WITH this, this_content0
	CALL apoc.util.validate(NOT ((exists((this_content0)<-[:HAS_CONTENT]-(:User))
		AND any(auth_this0 IN [(this_content0)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
		WHERE (auth_this0.id IS NOT NULL
			AND auth_this0.id = $this_content0auth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
	SET this_content0.id = $this_update_content0_id
	WITH this, this_content0
	CALL {
		WITH this_content0
		MATCH (this_content0)<-[this_content0_creator_User_unique:HAS_CONTENT]-(:User)
		WITH count(this_content0_creator_User_unique) AS c
		CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDPost.creator required', [0])
		RETURN c AS this_content0_creator_User_unique_ignored
	}
	RETURN count(*) AS update_this_Post
}
CALL {
	WITH *
	CALL {
		WITH this
		MATCH (this)-[this0:HAS_CONTENT]->(this_Comment:Comment)
		RETURN {
			__resolveType: 'Comment',
			id: this_Comment.id
		} AS this_content UNION
		WITH this
		MATCH (this)-[this1:HAS_CONTENT]->(this_Post:Post)
		WHERE apoc.util.validatePredicate(NOT ((exists((this_Post)<-[:HAS_CONTENT]-(:User))
			AND any(auth_this0 IN [(this_Post)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
			WHERE (auth_this0.id IS NOT NULL
				AND auth_this0.id = $this_Postauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
		RETURN {
			__resolveType: 'Post',
			id: this_Post.id
		} AS this_content
	}
	RETURN collect(this_content) AS this_content
}
RETURN collect(DISTINCT this {
	.id,
	content: this_content
}) AS data
----

'''

== read allow protected interface relationship

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    content {
      id
      content
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_Postauth_param0" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH *
	CALL {
		WITH this
		MATCH (this)-[this0:HAS_CONTENT]->(this_Comment:Comment)
		RETURN {
			__resolveType: 'Comment',
			id: this_Comment.id,
			content: this_Comment.content
		} AS this_content UNION
		WITH this
		MATCH (this)-[this1:HAS_CONTENT]->(this_Post:Post)
		WHERE apoc.util.validatePredicate(NOT ((exists((this_Post)<-[:HAS_CONTENT]-(:User))
			AND any(auth_this0 IN [(this_Post)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
			WHERE (auth_this0.id IS NOT NULL
				AND auth_this0.id = $this_Postauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
		RETURN {
			__resolveType: 'Post',
			id: this_Post.id,
			content: this_Post.content
		} AS this_content
	}
	RETURN collect(this_content) AS this_content
}
RETURN this {
	.id,
	content: this_content
} AS this
----

'''

== Read Two Relationships

.GraphQL-Query
[source,graphql]
----
{
  users(where: {id: "1"}) {
    id
    content(where: {id: "1"}) {
      ... on Post {
        comments(where: {id: "1"}) {
          content
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "1",
  "this_Postauth_param0" : "id-01"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
CALL {
	WITH *
	CALL {
		WITH this
		MATCH (this)-[this0:HAS_CONTENT]->(this_Comment:Comment)
		WHERE this_Comment.id = $param0
		RETURN {
			__resolveType: 'Comment'
		} AS this_content UNION
		WITH this
		MATCH (this)-[this1:HAS_CONTENT]->(this_Post:Post)
		WHERE (apoc.util.validatePredicate(NOT ((exists((this_Post)<-[:HAS_CONTENT]-(:User))
				AND any(auth_this0 IN [(this_Post)<-[:HAS_CONTENT]-(auth_this0:User) | auth_this0]
				WHERE (auth_this0.id IS NOT NULL
					AND auth_this0.id = $this_Postauth_param0)))), '@neo4j/graphql/FORBIDDEN', [0])
			AND this_Post.id = $param0)
		CALL {
			WITH this_Post
			MATCH (this_Post)-[this_Post2:HAS_COMMENT]->(this_Post_comments:Comment)
			WHERE this_Post_comments.id = $param0
			WITH this_Post_comments {
				.content
			} AS this_Post_comments
			RETURN collect(this_Post_comments) AS this_Post_comments
		}
		RETURN {
			__resolveType: 'Post',
			comments: this_Post_comments
		} AS this_content
	}
	RETURN collect(this_content) AS this_content
}
RETURN this {
	.id,
	content: this_content
} AS this
----

'''

