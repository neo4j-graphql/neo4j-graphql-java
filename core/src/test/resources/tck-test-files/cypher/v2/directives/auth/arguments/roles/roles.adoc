:toc:

= Cypher Auth Roles

== Source schema

[source,graphql,schema=true]
----
type History {
  url: String @auth(rules: [{operations: [READ], roles: ["super-admin"]}])
}

type Comment {
  id: String
  content: String
  post: Post! @relationship(type: "HAS_COMMENT", direction: IN)
}

type Post {
  id: String
  content: String
  creator: User! @relationship(type: "HAS_POST", direction: OUT)
  comments: [Comment!]! @relationship(type: "HAS_COMMENT", direction: OUT)
}

type User {
  id: ID
  name: String
  password: String @auth(rules: [{operations: [READ, CREATE, UPDATE], roles: ["super-admin"]}])
  posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}

extend type User @auth(rules: [{operations: [READ, CREATE, UPDATE, CONNECT, DISCONNECT, DELETE], roles: ["admin"]}])

extend type Post @auth(rules: [{operations: [CONNECT, DISCONNECT, DELETE], roles: ["super-admin"]}])

extend type User {
  password: String @auth(rules: [{operations: [READ, CREATE, UPDATE], roles: ["super-admin"]}])
}

extend type User {
  history: [History] @cypher(statement: "MATCH (this)-[:HAS_HISTORY]->(h:History) RETURN h") @auth(rules: [{operations: [READ], roles: ["super-admin"]}])
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Connect

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(connect: {posts: {}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_posts0_node:Post)
	WITH this, this_connect_posts0_node CALL apoc.util.validate(NOT ((any(r IN ['super-admin']
		WHERE any(rr IN $auth.roles
		WHERE rr = r))
		AND any(r IN ['admin']
		WHERE any(rr IN $auth.roles
		WHERE rr = r)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH *
		WITH collect(this_connect_posts0_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_posts0_node
			MERGE (this)-[:HAS_POST]->(this_connect_posts0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_posts0_node
	RETURN count(*) AS connect_this_connect_posts_Post
}
WITH *
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Create Node

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(input: [{id: "1"}]) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "create_param0" : [ {
    "id" : "1"
  } ]
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var1
CALL {
	WITH create_var1
	CREATE (create_this0:User)
	SET create_this0.id = create_var1.id
	WITH * CALL apoc.util.validate(NOT (any(r IN ['admin']
	WHERE any(rr IN $auth.roles
	WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
	RETURN create_this0
}
RETURN collect(create_this0 {
	.id
}) AS data
----

'''

== Create Node & Field

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(input: [{id: "1", password: "super-password"}]) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "create_param0" : [ {
    "id" : "1",
    "password" : "super-password"
  } ]
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var1
CALL {
	WITH create_var1
	CREATE (create_this0:User)
	SET create_this0.id = create_var1.id, create_this0.password = create_var1.password
	WITH * CALL apoc.util.validate(NOT (any(r IN ['admin']
	WHERE any(rr IN $auth.roles
	WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
	WITH * CALL apoc.util.validate((create_var1.password IS NOT NULL
		AND NOT (any(r IN ['super-admin']
		WHERE any(rr IN $auth.roles
		WHERE rr = r)))), '@neo4j/graphql/FORBIDDEN', [0])
	RETURN create_this0
}
RETURN collect(create_this0 {
	.id
}) AS data
----

'''

== Delete

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH this CALL apoc.util.validate(NOT (any(r IN ['admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0]) DETACH DELETE this
----

'''

== Disconnect

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(disconnect: {posts: {}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "updateUsers" : {
    "args" : {
      "disconnect" : {
        "posts" : [ { } ]
      }
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this)-[this_disconnect_posts0_rel:HAS_POST]->(this_disconnect_posts0:Post)
	WITH this, this_disconnect_posts0, this_disconnect_posts0_rel CALL apoc.util.validate(NOT ((any(r IN ['admin']
		WHERE any(rr IN $auth.roles
		WHERE rr = r))
		AND any(r IN ['super-admin']
		WHERE any(rr IN $auth.roles
		WHERE rr = r)))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH this_disconnect_posts0, this_disconnect_posts0_rel, this
		WITH collect(this_disconnect_posts0) AS this_disconnect_posts0, this_disconnect_posts0_rel, this
		UNWIND this_disconnect_posts0 AS x DELETE this_disconnect_posts0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_posts_Post
}
WITH *
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Nested Connect

.GraphQL-Query
[source,graphql]
----
mutation {
  updateComments(
    update: {post: {update: {node: {creator: {connect: {where: {node: {id: "user-id"}}}}}}}}
  ) {
    comments {
      content
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "this_post0_creator0_connect0_node_param0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Comment)
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_has_comment0_relationship:HAS_COMMENT]-(this_post0:Post)
	WITH this, this_post0
	CALL {
		WITH this, this_post0
		OPTIONAL MATCH (this_post0_creator0_connect0_node:User)
		WHERE this_post0_creator0_connect0_node.id = $this_post0_creator0_connect0_node_param0
		WITH this, this_post0, this_post0_creator0_connect0_node CALL apoc.util.validate(NOT ((any(r IN ['admin']
			WHERE any(rr IN $auth.roles
			WHERE rr = r))
			AND any(r IN ['super-admin']
			WHERE any(rr IN $auth.roles
			WHERE rr = r)))), '@neo4j/graphql/FORBIDDEN', [0])
		CALL {
			WITH *
			WITH this, collect(this_post0_creator0_connect0_node) AS connectedNodes, collect(this_post0) AS parentNodes
			CALL {
				WITH connectedNodes, parentNodes
				UNWIND parentNodes AS this_post0
				UNWIND connectedNodes AS this_post0_creator0_connect0_node
				MERGE (this_post0)-[:HAS_POST]->(this_post0_creator0_connect0_node)
				RETURN count(*) AS _
			}
			RETURN count(*) AS _
		}
		WITH this, this_post0, this_post0_creator0_connect0_node
		RETURN count(*) AS connect_this_post0_creator0_connect_User
	}
	WITH this, this_post0
	CALL {
		WITH this_post0
		MATCH (this_post0)-[this_post0_creator_User_unique:HAS_POST]->(:User)
		WITH count(this_post0_creator_User_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDPost.creator required exactly once', [0])
		RETURN c AS this_post0_creator_User_unique_ignored
	}
	RETURN count(*) AS update_this_post0
}
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_post_Post_unique:HAS_COMMENT]-(:Post)
	WITH count(this_post_Post_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDComment.post required exactly once', [0])
	RETURN c AS this_post_Post_unique_ignored
}
RETURN collect(DISTINCT this {
	.content
}) AS data
----

'''

== Nested Delete

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers(delete: {posts: {where: {}}}) {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH this
OPTIONAL MATCH (this)-[this_posts0_relationship:HAS_POST]->(this_posts0:Post)
WITH this, this_posts0 CALL apoc.util.validate(NOT (any(r IN ['super-admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
WITH this, collect(DISTINCT this_posts0) AS this_posts0_to_delete
CALL {
	WITH this_posts0_to_delete
	UNWIND this_posts0_to_delete AS x DETACH DELETE x
	RETURN count(*) AS _
}
WITH this CALL apoc.util.validate(NOT (any(r IN ['admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0]) DETACH DELETE this
----

'''

== Nested Disconnect

.GraphQL-Query
[source,graphql]
----
mutation {
  updateComments(
    update: {post: {update: {node: {creator: {disconnect: {where: {node: {id: "user-id"}}}}}}}}
  ) {
    comments {
      content
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "updateComments" : {
    "args" : {
      "update" : {
        "post" : {
          "update" : {
            "node" : {
              "creator" : {
                "disconnect" : {
                  "where" : {
                    "node" : {
                      "id" : "user-id"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "updateComments_args_update_post_update_node_creator_disconnect_where_Userparam0" : "user-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Comment)
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_has_comment0_relationship:HAS_COMMENT]-(this_post0:Post)
	WITH this, this_post0
	CALL {
		WITH this, this_post0
		OPTIONAL MATCH (this_post0)-[this_post0_creator0_disconnect0_rel:HAS_POST]->(this_post0_creator0_disconnect0:User)
		WHERE this_post0_creator0_disconnect0.id = $updateComments_args_update_post_update_node_creator_disconnect_where_Userparam0
		WITH this, this_post0, this_post0_creator0_disconnect0, this_post0_creator0_disconnect0_rel CALL apoc.util.validate(NOT ((any(r IN ['super-admin']
			WHERE any(rr IN $auth.roles
			WHERE rr = r))
			AND any(r IN ['admin']
			WHERE any(rr IN $auth.roles
			WHERE rr = r)))), '@neo4j/graphql/FORBIDDEN', [0])
		CALL {
			WITH this_post0_creator0_disconnect0, this_post0_creator0_disconnect0_rel, this_post0
			WITH collect(this_post0_creator0_disconnect0) AS this_post0_creator0_disconnect0, this_post0_creator0_disconnect0_rel, this_post0
			UNWIND this_post0_creator0_disconnect0 AS x DELETE this_post0_creator0_disconnect0_rel
			RETURN count(*) AS _
		}
		RETURN count(*) AS disconnect_this_post0_creator0_disconnect_User
	}
	WITH this, this_post0
	CALL {
		WITH this_post0
		MATCH (this_post0)-[this_post0_creator_User_unique:HAS_POST]->(:User)
		WITH count(this_post0_creator_User_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDPost.creator required exactly once', [0])
		RETURN c AS this_post0_creator_User_unique_ignored
	}
	RETURN count(*) AS update_this_post0
}
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_post_Post_unique:HAS_COMMENT]-(:Post)
	WITH count(this_post_Post_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDComment.post required exactly once', [0])
	RETURN c AS this_post_Post_unique_ignored
}
RETURN collect(DISTINCT this {
	.content
}) AS data
----

'''

== Read Node

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    name
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE apoc.util.validatePredicate(NOT (any(r IN ['admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
RETURN this {
	.id,
	.name
} AS this
----

'''

== Read Node & Cypher Field

.GraphQL-Query
[source,graphql]
----
{
  users {
    history {
      url
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE apoc.util.validatePredicate(NOT (any(r IN ['admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0]) CALL apoc.util.validate(NOT (any(r IN ['super-admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
CALL {
	WITH this
	UNWIND apoc.cypher.runFirstColumnMany('MATCH (this)-[:HAS_HISTORY]->(h:History) RETURN h', {
		this: this,
		auth: $auth
	}) AS this_history
	RETURN collect(this_history {
		.url
	}) AS this_history
}
RETURN this {
	history: this_history
} AS this
----

'''

== Read Node & Field

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    name
    password
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE apoc.util.validatePredicate(NOT (any(r IN ['admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0]) CALL apoc.util.validate(NOT (any(r IN ['super-admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
RETURN this {
	.id,
	.name,
	.password
} AS this
----

'''

== Update Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {id: "1"}, update: {id: "id-1"}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "param0" : "1",
  "this_update_id" : "id-1"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT (any(r IN ['admin']
WHERE any(rr IN $auth.roles
WHERE rr = r))), '@neo4j/graphql/FORBIDDEN', [0])
SET this.id = $this_update_id
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

== Update Node & Field

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {id: "1"}, update: {password: "password"}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ]
  },
  "contextParams": {
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : true,
    "roles" : [ "admin" ],
    "jwt" : {
      "roles" : [ "admin" ],
      "sub" : "super_admin"
    }
  },
  "param0" : "1",
  "this_update_password" : "password"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE this.id = $param0
WITH this CALL apoc.util.validate(NOT ((any(r IN ['admin']
	WHERE any(rr IN $auth.roles
	WHERE rr = r))
	AND any(r IN ['super-admin']
	WHERE any(rr IN $auth.roles
	WHERE rr = r)))), '@neo4j/graphql/FORBIDDEN', [0])
SET this.password = $this_update_password
RETURN collect(DISTINCT this {
	.id
}) AS data
----

'''

