:toc:

= Cypher Auth Where

== Source schema

[source,graphql,schema=true]
----
type JWTPayload @jwt {
  roles: [String!]!
}

union Search = Post

type User {
  id: ID
  name: String
  posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
  content: [Search!]! @relationship(type: "HAS_POST", direction: OUT)
}

type Post {
  id: ID
  content: String
  creator: User! @relationship(type: "HAS_POST", direction: IN)
}

extend type User @authorization(filter: [{where: {node: {id: "$jwt.sub"}}}])

extend type User {
  password: String! @authorization(filter: [{operations: [READ], where: {node: {id: "$jwt.sub"}}}])
}

extend type Post {
  secretKey: String! @authorization(filter: [{operations: [READ], where: {node: {creator: {id: "$jwt.sub"}}}}])
}

extend type Post @authorization(filter: [{where: {node: {creator: {id: "$jwt.sub"}}}}])
----
== Connect Node (from create)

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(
    input: [{id: "123", name: "Bob", password: "password", posts: {connect: {where: {node: {}}}}}]
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_id": "123",
  "this0_name": "Bob",
  "this0_password": "password",
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
CREATE (this0:User)
SET this0.id = $this0_id
SET this0.name = $this0_name
SET this0.password = $this0_password
WITH *
CALL {
	WITH this0
	OPTIONAL MATCH (this0_posts_connect0_node:Post)
OPTIONAL MATCH (this0_posts_connect0_node)<-[:HAS_POST]-(authorization_0_before_this0:User)
WITH *, count(authorization_0_before_this0) AS creatorCount
WITH *
	WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization_0_before_this0.id = $jwt.sub)))
	CALL {
		WITH *
		WITH collect(this0_posts_connect0_node) as connectedNodes, collect(this0) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this0
			UNWIND connectedNodes as this0_posts_connect0_node
			MERGE (this0)-[:HAS_POST]->(this0_posts_connect0_node)
		}
	}
WITH this0, this0_posts_connect0_node
	RETURN count(*) AS connect_this0_posts_connect_Post0
}
RETURN this0
}
CALL {
    WITH this0
    RETURN this0 { .id } AS create_var0
}
RETURN [create_var0] AS data
----

'''

== Connect Node (from update connect)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(connect: {posts: {where: {node: {}}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
WITH *
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_posts0_node:Post)
OPTIONAL MATCH (this_connect_posts0_node)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WITH *
	WHERE (($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))) AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))
	CALL {
		WITH *
		WITH collect(this_connect_posts0_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_connect_posts0_node
			MERGE (this)-[:HAS_POST]->(this_connect_posts0_node)
		}
	}
WITH this, this_connect_posts0_node
	RETURN count(*) AS connect_this_connect_posts_Post0
}
WITH *
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Connect Node (from update update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {posts: {connect: {where: {node: {}}}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))


WITH *
CALL {
	WITH this
	OPTIONAL MATCH (this_posts0_connect0_node:Post)
OPTIONAL MATCH (this_posts0_connect0_node)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WITH *
	WHERE (($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))) AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))
	CALL {
		WITH *
		WITH collect(this_posts0_connect0_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_posts0_connect0_node
			MERGE (this)-[:HAS_POST]->(this_posts0_connect0_node)
		}
	}
WITH this, this_posts0_connect0_node
	RETURN count(*) AS connect_this_posts0_connect_Post0
}

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Connect Node + User Defined Where (from create)

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(
    input: [{id: "123", name: "Bob", password: "password", posts: {connect: {where: {node: {id: "post-id"}}}}}]
  ) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_id": "123",
  "this0_name": "Bob",
  "this0_password": "password",
  "this0_posts_connect0_node_param0": "post-id",
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
CREATE (this0:User)
SET this0.id = $this0_id
SET this0.name = $this0_name
SET this0.password = $this0_password
WITH *
CALL {
	WITH this0
	OPTIONAL MATCH (this0_posts_connect0_node:Post)
OPTIONAL MATCH (this0_posts_connect0_node)<-[:HAS_POST]-(authorization_0_before_this0:User)
WITH *, count(authorization_0_before_this0) AS creatorCount
WITH *
	WHERE this0_posts_connect0_node.id = $this0_posts_connect0_node_param0 AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization_0_before_this0.id = $jwt.sub)))
	CALL {
		WITH *
		WITH collect(this0_posts_connect0_node) as connectedNodes, collect(this0) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this0
			UNWIND connectedNodes as this0_posts_connect0_node
			MERGE (this0)-[:HAS_POST]->(this0_posts_connect0_node)
		}
	}
WITH this0, this0_posts_connect0_node
	RETURN count(*) AS connect_this0_posts_connect_Post0
}
RETURN this0
}
CALL {
    WITH this0
    RETURN this0 { .id } AS create_var0
}
RETURN [create_var0] AS data
----

'''

== Connect Node + User Defined Where (from update connect)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(connect: {posts: {where: {node: {id: "some-id"}}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "this_connect_posts0_node_param0": "some-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
WITH *
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_posts0_node:Post)
OPTIONAL MATCH (this_connect_posts0_node)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WITH *
	WHERE this_connect_posts0_node.id = $this_connect_posts0_node_param0 AND (($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))) AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))
	CALL {
		WITH *
		WITH collect(this_connect_posts0_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_connect_posts0_node
			MERGE (this)-[:HAS_POST]->(this_connect_posts0_node)
		}
	}
WITH this, this_connect_posts0_node
	RETURN count(*) AS connect_this_connect_posts_Post0
}
WITH *
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Connect Node + User Defined Where (from update update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {posts: {connect: {where: {node: {id: "new-id"}}}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "this_posts0_connect0_node_param0": "new-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))


WITH *
CALL {
	WITH this
	OPTIONAL MATCH (this_posts0_connect0_node:Post)
OPTIONAL MATCH (this_posts0_connect0_node)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WITH *
	WHERE this_posts0_connect0_node.id = $this_posts0_connect0_node_param0 AND (($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))) AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))
	CALL {
		WITH *
		WITH collect(this_posts0_connect0_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_posts0_connect0_node
			MERGE (this)-[:HAS_POST]->(this_posts0_connect0_node)
		}
	}
WITH this, this_posts0_connect0_node
	RETURN count(*) AS connect_this_posts0_connect_Post0
}

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Delete Nested Node

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers(delete: {posts: {where: {}}}) {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
WITH *
CALL {
    WITH *
    OPTIONAL MATCH (this)-[this0:HAS_POST]->(this1:Post)
    OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
    WITH *, count(this2) AS creatorCount
    WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub)))
    WITH this0, collect(DISTINCT this1) AS var3
    CALL {
        WITH var3
        UNWIND var3 AS var4
        DETACH DELETE var4
    }
}
WITH *
DETACH DELETE this
----

'''

== Delete Node

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
DETACH DELETE this
----

'''

== Delete Node + User Defined Where

.GraphQL-Query
[source,graphql]
----
mutation {
  deleteUsers(where: {name: "Bob"}) {
    nodesDeleted
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Bob",
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WHERE (this.name = $param0 AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))
DETACH DELETE this
----

'''

== Disconnect Node (from update disconnect)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(disconnect: {posts: {where: {}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "updateUsers": {
    "args": {
      "disconnect": {
        "posts": [
          {
            "where": {}
          }
        ]
      }
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
WITH this
CALL {
WITH this
OPTIONAL MATCH (this)-[this_disconnect_posts0_rel:HAS_POST]->(this_disconnect_posts0:Post)
OPTIONAL MATCH (this_disconnect_posts0)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WHERE (($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)) AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))))
CALL {
	WITH this_disconnect_posts0, this_disconnect_posts0_rel, this
	WITH collect(this_disconnect_posts0) as this_disconnect_posts0, this_disconnect_posts0_rel, this
	UNWIND this_disconnect_posts0 as x
	DELETE this_disconnect_posts0_rel
}
RETURN count(*) AS disconnect_this_disconnect_posts_Post
}
WITH *
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Disconnect Node (from update update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {posts: {disconnect: {where: {}}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))


WITH this
CALL {
WITH this
OPTIONAL MATCH (this)-[this_posts0_disconnect0_rel:HAS_POST]->(this_posts0_disconnect0:Post)
OPTIONAL MATCH (this_posts0_disconnect0)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WHERE (($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)) AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))))
CALL {
	WITH this_posts0_disconnect0, this_posts0_disconnect0_rel, this
	WITH collect(this_posts0_disconnect0) as this_posts0_disconnect0, this_posts0_disconnect0_rel, this
	UNWIND this_posts0_disconnect0 as x
	DELETE this_posts0_disconnect0_rel
}
RETURN count(*) AS disconnect_this_posts0_disconnect_Post
}

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Disconnect Node + User Defined Where (from update disconnect)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(disconnect: {posts: {where: {node: {id: "some-id"}}}}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "updateUsers_args_disconnect_posts0_where_Post_this_disconnect_posts0param0": "some-id",
  "updateUsers": {
    "args": {
      "disconnect": {
        "posts": [
          {
            "where": {
              "node": {
                "id": "some-id"
              }
            }
          }
        ]
      }
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
WITH this
CALL {
WITH this
OPTIONAL MATCH (this)-[this_disconnect_posts0_rel:HAS_POST]->(this_disconnect_posts0:Post)
OPTIONAL MATCH (this_disconnect_posts0)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WHERE this_disconnect_posts0.id = $updateUsers_args_disconnect_posts0_where_Post_this_disconnect_posts0param0 AND (($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)) AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))))
CALL {
	WITH this_disconnect_posts0, this_disconnect_posts0_rel, this
	WITH collect(this_disconnect_posts0) as this_disconnect_posts0, this_disconnect_posts0_rel, this
	UNWIND this_disconnect_posts0 as x
	DELETE this_disconnect_posts0_rel
}
RETURN count(*) AS disconnect_this_disconnect_posts_Post
}
WITH *
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Disconnect Node + User Defined Where (from update update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {posts: [{disconnect: {where: {node: {id: "new-id"}}}}]}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "updateUsers_args_update_posts0_disconnect0_where_Post_this_posts0_disconnect0param0": "new-id",
  "updateUsers": {
    "args": {
      "update": {
        "posts": [
          {
            "disconnect": [
              {
                "where": {
                  "node": {
                    "id": "new-id"
                  }
                }
              }
            ]
          }
        ]
      }
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))


WITH this
CALL {
WITH this
OPTIONAL MATCH (this)-[this_posts0_disconnect0_rel:HAS_POST]->(this_posts0_disconnect0:Post)
OPTIONAL MATCH (this_posts0_disconnect0)<-[:HAS_POST]-(authorization__before_this0:User)
WITH *, count(authorization__before_this0) AS creatorCount
WHERE this_posts0_disconnect0.id = $updateUsers_args_update_posts0_disconnect0_where_Post_this_posts0_disconnect0param0 AND (($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)) AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub))))
CALL {
	WITH this_posts0_disconnect0, this_posts0_disconnect0_rel, this
	WITH collect(this_posts0_disconnect0) as this_posts0_disconnect0, this_posts0_disconnect0_rel, this
	UNWIND this_posts0_disconnect0 as x
	DELETE this_posts0_disconnect0_rel
}
RETURN count(*) AS disconnect_this_posts0_disconnect_Post
}

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Read Connection

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    postsConnection {
      edges {
        node {
          content
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    MATCH (this)-[this0:HAS_POST]->(this1:Post)
    OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
    WITH *, count(this2) AS creatorCount
    WITH *
    WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub)))
    WITH collect({ node: this1, relationship: this0 }) AS edges
    WITH edges, size(edges) AS totalCount
    CALL {
        WITH edges
        UNWIND edges AS edge
        WITH edge.node AS this1, edge.relationship AS this0
        RETURN collect({ node: { content: this1.content } }) AS var3
    }
    RETURN { edges: var3, totalCount: totalCount } AS var4
}
RETURN this { .id, postsConnection: var4 } AS this
----

'''

== Read Connection + User Defined Where

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    postsConnection(where: {node: {id: "some-id"}}) {
      edges {
        node {
          content
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "param2": "some-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    MATCH (this)-[this0:HAS_POST]->(this1:Post)
    OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
    WITH *, count(this2) AS creatorCount
    WITH *
    WHERE (this1.id = $param2 AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub))))
    WITH collect({ node: this1, relationship: this0 }) AS edges
    WITH edges, size(edges) AS totalCount
    CALL {
        WITH edges
        UNWIND edges AS edge
        WITH edge.node AS this1, edge.relationship AS this0
        RETURN collect({ node: { content: this1.content } }) AS var3
    }
    RETURN { edges: var3, totalCount: totalCount } AS var4
}
RETURN this { .id, postsConnection: var4 } AS this
----

'''

== Read Node

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN this { .id } AS this
----

'''

== Read Node + User Defined Where

.GraphQL-Query
[source,graphql]
----
{
  users(where: {name: "bob"}) {
    id
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "bob",
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE (this.name = $param0 AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))
RETURN this { .id } AS this
----

'''

== Read Relationship

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    posts {
      content
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    MATCH (this)-[this0:HAS_POST]->(this1:Post)
    OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
    WITH *, count(this2) AS creatorCount
    WITH *
    WITH *
    WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub)))
    WITH this1 { .content } AS this1
    RETURN collect(this1) AS var3
}
RETURN this { .id, posts: var3 } AS this
----

'''

== Read Union

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    content {
      ... on Post {
        id
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:HAS_POST]->(this1:Post)
        OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
        WITH *, count(this2) AS creatorCount
        WITH *
        WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub)))
        WITH this1 { .id, __resolveType: "Post", __id: id(this1) } AS this1
        RETURN this1 AS var3
    }
    WITH var3
    RETURN collect(var3) AS var3
}
RETURN this { .id, content: var3 } AS this
----

'''

== Read Union Relationship + User Defined Where

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    posts(where: {content: "cool"}) {
      content
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "param2": "cool"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    MATCH (this)-[this0:HAS_POST]->(this1:Post)
    OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
    WITH *, count(this2) AS creatorCount
    WITH *
    WITH *
    WHERE (this1.content = $param2 AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub))))
    WITH this1 { .content } AS this1
    RETURN collect(this1) AS var3
}
RETURN this { .id, posts: var3 } AS this
----

'''

== Read Union Using Connection

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    contentConnection {
      edges {
        node {
          ... on Post {
            id
          }
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:HAS_POST]->(this1:Post)
        OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
        WITH *, count(this2) AS creatorCount
        WITH *
        WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub)))
        WITH { node: { __resolveType: "Post", __id: id(this1), id: this1.id } } AS edge
        RETURN edge
    }
    WITH collect(edge) AS edges
    WITH edges, size(edges) AS totalCount
    RETURN { edges: edges, totalCount: totalCount } AS var3
}
RETURN this { .id, contentConnection: var3 } AS this
----

'''

== Read Union Using Connection + User Defined Where

.GraphQL-Query
[source,graphql]
----
{
  users {
    id
    contentConnection(where: {Post: {node: {id: "some-id"}}}) {
      edges {
        node {
          ... on Post {
            id
          }
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "param2": "some-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:HAS_POST]->(this1:Post)
        OPTIONAL MATCH (this1)<-[:HAS_POST]-(this2:User)
        WITH *, count(this2) AS creatorCount
        WITH *
        WHERE (this1.id = $param2 AND ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND this2.id = $jwt.sub))))
        WITH { node: { __resolveType: "Post", __id: id(this1), id: this1.id } } AS edge
        RETURN edge
    }
    WITH collect(edge) AS edges
    WITH edges, size(edges) AS totalCount
    RETURN { edges: edges, totalCount: totalCount } AS var3
}
RETURN this { .id, contentConnection: var3 } AS this
----

'''

== Update Nested Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {posts: {update: {node: {id: "new-id"}}}}) {
    users {
      id
      posts {
        id
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "this_update_posts0_id": "new-id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))


WITH this
CALL {
	WITH this
	MATCH (this)-[this_has_post0_relationship:HAS_POST]->(this_posts0:Post)
	OPTIONAL MATCH (this_posts0)<-[:HAS_POST]-(authorization__before_this0:User)
	WITH *, count(authorization__before_this0) AS creatorCount
	WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND authorization__before_this0.id = $jwt.sub)))
	
	
	SET this_posts0.id = $this_update_posts0_id
	
	WITH this, this_posts0
	CALL {
		WITH this_posts0
		MATCH (this_posts0)<-[this_posts0_creator_User_unique:HAS_POST]-(:User)
		WITH count(this_posts0_creator_User_unique) as c
		WHERE apoc.util.validatePredicate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDPost.creator required exactly once', [0])
		RETURN c AS this_posts0_creator_User_unique_ignored
	}
	RETURN count(*) AS update_this_posts0
}

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
CALL {
    WITH this
    MATCH (this)-[update_this0:HAS_POST]->(update_this1:Post)
    OPTIONAL MATCH (update_this1)<-[:HAS_POST]-(update_this2:User)
    WITH *, count(update_this2) AS creatorCount
    WITH *
    WITH *
    WHERE ($isAuthenticated = true AND (creatorCount <> 0 AND ($jwt.sub IS NOT NULL AND update_this2.id = $jwt.sub)))
    WITH update_this1 { .id } AS update_this1
    RETURN collect(update_this1) AS update_var3
}
RETURN collect(DISTINCT this { .id, posts: update_var3 }) AS data
----

'''

== Update Node

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {name: "Bob"}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "this_update_name": "Bob"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))


SET this.name = $this_update_name

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

== Update Node + User Defined Where

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {name: "bob"}, update: {name: "Bob"}) {
    users {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [
      "admin"
    ],
    "jwt": {
      "roles": [
        "admin"
      ],
      "sub": "id-01"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": [
      "admin"
    ],
    "sub": "id-01"
  },
  "param0": "bob",
  "this_update_name": "Bob"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE (this.name = $param0 AND ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub)))


SET this.name = $this_update_name

WITH *
WHERE ($isAuthenticated = true AND ($jwt.sub IS NOT NULL AND this.id = $jwt.sub))
RETURN collect(DISTINCT this { .id }) AS data
----

'''

