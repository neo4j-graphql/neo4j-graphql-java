// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= @customResolver directive

== Require fields on same type

=== Setup

.Schema
[source,graphql,schema=true]
----
type User {
  firstName: String!
  lastName: String!
  fullName: String! @customResolver(requires: "firstName lastName")
}
----

=== should not fetch required fields if @customResolver field is not selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    firstName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .firstName } AS this
----

=== should not over fetch when all required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    firstName
    lastName
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .firstName, .lastName, .fullName } AS this
----

=== should not over fetch when some required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    firstName
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .firstName, .fullName, .lastName } AS this
----

=== should not over fetch when no required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .fullName, .firstName, .lastName } AS this
----

== No required fields

=== Setup

.Schema
[source,graphql,schema=true]
----
type User {
  firstName: String!
  lastName: String!
  fullName: String! @customResolver
}
----

=== should not over fetch when other fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    firstName
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .firstName, .fullName } AS this
----

=== should not over fetch when no other fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .fullName } AS this
----

== Require fields on nested types

=== Setup

.Schema
[source,graphql,schema=true]
----
type City {
  name: String!
  population: Int
}

type Address {
  street: String!
  city: City! @relationship(type: "IN_CITY", direction: OUT)
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  address: Address @relationship(type: "LIVES_AT", direction: OUT)
  fullName: String @customResolver(requires: "firstName lastName address { city { name population } }")
}
----

=== should not over fetch when all required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    firstName
    lastName
    fullName
    address {
      city {
        name
        population
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    CALL {
        WITH this1
        MATCH (this1)-[this2:IN_CITY]->(this3:City)
        WITH this3 { .name, .population } AS this3
        RETURN head(collect(this3)) AS var4
    }
    WITH this1 { city: var4 } AS this1
    RETURN head(collect(this1)) AS var5
}
RETURN this { .firstName, .lastName, .fullName, address: var5 } AS this
----

=== should not fetch required fields if @customResolver field is not selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    firstName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
RETURN this { .firstName } AS this
----

=== should not over fetch when some required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    lastName
    fullName
    address {
      city {
        population
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    CALL {
        WITH this1
        MATCH (this1)-[this2:IN_CITY]->(this3:City)
        WITH this3 { .population, .name } AS this3
        RETURN head(collect(this3)) AS var4
    }
    WITH this1 { city: var4 } AS this1
    RETURN head(collect(this1)) AS var5
}
RETURN this { .lastName, .fullName, .firstName, address: var5 } AS this
----

=== should not over fetch when no required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  users {
    fullName
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
    WITH this
    MATCH (this)-[this0:LIVES_AT]->(this1:Address)
    CALL {
        WITH this1
        MATCH (this1)-[this2:IN_CITY]->(this3:City)
        WITH this3 { .name, .population } AS this3
        RETURN head(collect(this3)) AS var4
    }
    WITH this1 { city: var4 } AS this1
    RETURN head(collect(this1)) AS var5
}
RETURN this { .fullName, .firstName, .lastName, address: var5 } AS this
----

== Require fields on nested unions

=== Setup

.Schema
[source,graphql,schema=true]
----
union Publication = Book | Journal

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
  publicationsWithAuthor: [String!]! @customResolver(requires: "name publications { ...on Book { title } ... on Journal { subject } }")
}

type Book {
  title: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}

type Journal {
  subject: String!
  author: Author! @relationship(type: "WROTE", direction: IN)
}
----

=== should not over fetch when all required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    name
    publicationsWithAuthor
    publications {
      ... on Book {
        title
      }
      ... on Journal {
        subject
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .name, .publicationsWithAuthor, publications: var2 } AS this
----

=== should not fetch required fields if @customResolver field is not selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    name
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
RETURN this { .name } AS this
----

=== should not over fetch when some required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    publicationsWithAuthor
    publications {
      ... on Book {
        title
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .publicationsWithAuthor, .name, publications: var2 } AS this
----

=== should not over fetch when no required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    publicationsWithAuthor
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .publicationsWithAuthor, .name, publications: var2 } AS this
----

== Require fields on nested interfaces

=== Setup

.Schema
[source,graphql,schema=true]
----
interface Publication {
  publicationYear: Int!
}

type Author {
  name: String!
  publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
  publicationsWithAuthor: [String!]! @customResolver(requires: "name publications { publicationYear ...on Book { title } ... on Journal { subject } }")
}

type Book implements Publication {
  title: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
  subject: String!
  publicationYear: Int!
  author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

=== should not over fetch when all required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    name
    publicationsWithAuthor
    publications {
      publicationYear
      ... on Book {
        title
      }
      ... on Journal {
        subject
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .publicationYear, .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .publicationYear, .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .name, .publicationsWithAuthor, publications: var2 } AS this
----

=== should not fetch required fields if @customResolver field is not selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    name
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
RETURN this { .name } AS this
----

=== should not over fetch when some required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    publicationsWithAuthor
    publications {
      ... on Book {
        title
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .publicationYear, .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .publicationYear, .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .publicationsWithAuthor, .name, publications: var2 } AS this
----

=== should not over fetch when no required fields are manually selected

.GraphQL-Query
[source,graphql,request=true]
----
{
  authors {
    publicationsWithAuthor
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Author)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:WROTE]->(this1:Book)
        WITH this1 { .publicationYear, .title, __typename: "Book", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:WROTE]->(this4:Journal)
        WITH this4 { .publicationYear, .subject, __typename: "Journal", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
RETURN this { .publicationsWithAuthor, .name, publications: var2 } AS this
----
