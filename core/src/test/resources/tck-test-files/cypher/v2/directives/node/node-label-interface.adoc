:toc:

= Node directive with interface

== Source schema

[source,graphql,schema=true]
----
interface Search {
  name: String
}

type Genre implements Search @node(labels: ["Category", "ExtraLabel1", "ExtraLabel2"]) {
  name: String
}

type Movie implements Search @node(labels: ["Film"]) {
  name: String
  title: String
  search: [Search!]! @relationship(type: "SEARCH", direction: OUT)
}
----
== Read Interface

.GraphQL-Query
[source,graphql]
----
{
  movies(where: {title: "some title"}) {
    search(
      where: {_on: {Movie: {title: "The Matrix"}, Genre: {name: "Horror"}}}
      options: {offset: 1, limit: 10}
    ) {
      ... on Movie {
        title
      }
      ... on Genre {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some title",
  "param1": "Horror",
  "param2": "The Matrix",
  "param3": 1,
  "param4": 10
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Film)
WHERE this.title = $param0
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:SEARCH]->(this1:Category:ExtraLabel1:ExtraLabel2)
        WHERE this1.name = $param1
        WITH this1 { .name, __resolveType: "Genre", __id: id(this1) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:SEARCH]->(this4:Film)
        WHERE this4.title = $param2
        WITH this4 { .title, __resolveType: "Movie", __id: id(this4) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    
    SKIP $param3
    LIMIT $param4
    RETURN collect(var2) AS var2
}
RETURN this { search: var2 } AS this
----

'''

