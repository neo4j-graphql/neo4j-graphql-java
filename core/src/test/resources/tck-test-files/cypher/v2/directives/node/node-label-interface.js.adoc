// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= Node directive with interface

== Setup

.Schema
[source,graphql,schema=true]
----
interface Search {
  name: String
}

type Genre implements Search @node(labels: ["Category", "ExtraLabel1", "ExtraLabel2"]) {
  name: String
}

type Movie implements Search @node(labels: ["Film"]) {
  name: String
  title: String
  search: [Search!]! @relationship(type: "SEARCH", direction: OUT)
}
----

== Read Interface

.GraphQL-Query
[source,graphql,request=true]
----
{
  movies(where: {title: "some title"}) {
    search(where: {name: "Horror"}, options: {offset: 1, limit: 10}) {
      ... on Movie {
        title
      }
      ... on Genre {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some title",
  "param1": "Horror",
  "param2": "Horror",
  "param3": 1,
  "param4": 10
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Film)
WHERE this.title = $param0
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:SEARCH]->(this1:Category:ExtraLabel1:ExtraLabel2)
        WHERE this1.name = $param1
        WITH this1 { .name, __typename: "Genre", __id: toString(id(this1)) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)-[this3:SEARCH]->(this4:Film)
        WHERE this4.name = $param2
        WITH this4 { .title, __typename: "Movie", __id: toString(id(this4)) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    
    SKIP $param3
    LIMIT $param4
    RETURN collect(var2) AS var2
}
RETURN this { search: var2 } AS this
----
