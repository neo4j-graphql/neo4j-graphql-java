:toc:

= Interface Field Level Aggregations with Auth

== Source schema

[source,graphql,schema=true]
----
type JWT @jwt {
  roles: [String!]!
}

interface Production {
  title: String!
  cost: Float!
}

type Movie implements Production @authorization(filter: [{where: {jwt: {roles_INCLUDES: "movie_aggregator"}}}]) {
  title: String!
  cost: Float!
  runtime: Int!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}

type Series implements Production @authorization(filter: [{where: {jwt: {roles_INCLUDES: "series_aggregator"}}}]) {
  title: String! @authorization(filter: [{operations: [AGGREGATE], where: {jwt: {roles_INCLUDES: "series_title_aggregator"}}}])
  cost: Float!
  episodes: Int!
}

type ActedIn @relationshipProperties {
  screenTime: Int!
}

type Actor {
  name: String!
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----
== Count

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      count
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN count(node) AS this4
}
RETURN this { actedInAggregate: { count: this4 } } AS this
----

'''

== Count and Max

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      count
      node {
        cost {
          max
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator",
  "param4": "movie_aggregator",
  "param5": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN count(node) AS this4
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this5:ACTED_IN]->(this6:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param4 IN $jwt.roles))
        RETURN this6 AS node, this5 AS edge
        UNION
        WITH this
        MATCH (this)-[this7:ACTED_IN]->(this8:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param5 IN $jwt.roles))
        RETURN this8 AS node, this7 AS edge
    }
    RETURN { max: max(node.cost) } AS this9
}
RETURN this { actedInAggregate: { count: this4, node: { cost: this9 } } } AS this
----

'''

== Count with where

.GraphQL-Query
[source,graphql]
----
{
  actors(where: {name: "Keanu Reeves"}) {
    actedInAggregate {
      count
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Keanu Reeves",
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param3": "movie_aggregator",
  "param4": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
WHERE this.name = $param0
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param4 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN count(node) AS this4
}
RETURN this { actedInAggregate: { count: this4 } } AS this
----

'''

== Edge and node sum with count

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      count
      edge {
        screenTime {
          sum
        }
      }
      node {
        cost {
          sum
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator",
  "param4": "movie_aggregator",
  "param5": "series_aggregator",
  "param6": "movie_aggregator",
  "param7": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN count(node) AS this4
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this5:ACTED_IN]->(this6:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param4 IN $jwt.roles))
        RETURN this6 AS node, this5 AS edge
        UNION
        WITH this
        MATCH (this)-[this7:ACTED_IN]->(this8:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param5 IN $jwt.roles))
        RETURN this8 AS node, this7 AS edge
    }
    RETURN { sum: sum(node.cost) } AS this9
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this10:ACTED_IN]->(this11:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param6 IN $jwt.roles))
        RETURN this11 AS node, this10 AS edge
        UNION
        WITH this
        MATCH (this)-[this12:ACTED_IN]->(this13:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param7 IN $jwt.roles))
        RETURN this13 AS node, this12 AS edge
    }
    RETURN { sum: sum(edge.screenTime) } AS this14
}
RETURN this { actedInAggregate: { count: this4, node: { cost: this9 }, edge: { screenTime: this14 } } } AS this
----

'''

== Edge sum

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      edge {
        screenTime {
          sum
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN { sum: sum(edge.screenTime) } AS this4
}
RETURN this { actedInAggregate: { edge: { screenTime: this4 } } } AS this
----

'''

== Longest

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      node {
        title {
          longest
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator",
  "param4": "series_title_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE (($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles)) AND ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param4 IN $jwt.roles)))
        RETURN this3 AS node, this2 AS edge
    }
    WITH node
    ORDER BY size(node.title) DESC
    WITH collect(node.title) AS list
    RETURN { longest: head(list) } AS this4
}
RETURN this { actedInAggregate: { node: { title: this4 } } } AS this
----

'''

== Longest nested

.GraphQL-Query
[source,graphql]
----
{
  movies {
    actors {
      actedInAggregate {
        node {
          title {
            longest
          }
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "movie_aggregator",
  "param4": "series_aggregator",
  "param5": "series_title_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WITH *
WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
CALL {
    WITH this
    MATCH (this)<-[this0:ACTED_IN]-(this1:Actor)
    CALL {
        WITH this1
        CALL {
            WITH this1
            MATCH (this1)-[this2:ACTED_IN]->(this3:Movie)
            WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
            RETURN this3 AS node, this2 AS edge
            UNION
            WITH this1
            MATCH (this1)-[this4:ACTED_IN]->(this5:Series)
            WHERE (($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param4 IN $jwt.roles)) AND ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param5 IN $jwt.roles)))
            RETURN this5 AS node, this4 AS edge
        }
        WITH node
        ORDER BY size(node.title) DESC
        WITH collect(node.title) AS list
        RETURN { longest: head(list) } AS this6
    }
    WITH this1 { actedInAggregate: { node: { title: this6 } } } AS this1
    RETURN collect(this1) AS var7
}
RETURN this { actors: var7 } AS this
----

'''

== Max

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      node {
        cost {
          max
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN { max: max(node.cost) } AS this4
}
RETURN this { actedInAggregate: { node: { cost: this4 } } } AS this
----

'''

== Min

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate {
      node {
        cost {
          min
        }
      }
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": true,
  "jwt": {
    "roles": []
  },
  "param2": "movie_aggregator",
  "param3": "series_aggregator"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param2 IN $jwt.roles))
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        WHERE ($isAuthenticated = true AND ($jwt.roles IS NOT NULL AND $param3 IN $jwt.roles))
        RETURN this3 AS node, this2 AS edge
    }
    RETURN { min: min(node.cost) } AS this4
}
RETURN this { actedInAggregate: { node: { cost: this4 } } } AS this
----

'''

