:toc:

= Interface Field Level Aggregations

== Source schema

[source,graphql,schema=true]
----
interface Production {
  title: String!
  cost: Float!
}

type Movie implements Production {
  title: String!
  cost: Float!
  runtime: Int!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}

type Series implements Production {
  title: String!
  cost: Float!
  episodes: Int!
}

type ActedIn @relationshipProperties {
  screenTime: Int!
}

type Actor {
  name: String!
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----
== Count with OR operator and string aggregation

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate(
      where: {OR: [{title_STARTS_WITH: "The"}, {title_STARTS_WITH: "A"}]}
    ) {
      count
      edge {
        screenTime {
          min
          max
        }
      }
      node {
        title {
          longest
          shortest
        }
      }
    }
    name
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The",
  "param1": "A",
  "param2": "The",
  "param3": "A",
  "param4": "The",
  "param5": "A"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        RETURN this3 AS node, this2 AS edge
    }
    WITH *
    WHERE (node.title STARTS WITH $param0 OR node.title STARTS WITH $param1)
    RETURN count(node) AS this4
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this5:ACTED_IN]->(this6:Movie)
        RETURN this6 AS node, this5 AS edge
        UNION
        WITH this
        MATCH (this)-[this7:ACTED_IN]->(this8:Series)
        RETURN this8 AS node, this7 AS edge
    }
    WITH *
    WHERE (node.title STARTS WITH $param2 OR node.title STARTS WITH $param3)
    WITH node
    ORDER BY size(node.title) DESC
    WITH collect(node.title) AS list
    RETURN { longest: head(list), shortest: last(list) } AS this9
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this10:ACTED_IN]->(this11:Movie)
        RETURN this11 AS node, this10 AS edge
        UNION
        WITH this
        MATCH (this)-[this12:ACTED_IN]->(this13:Series)
        RETURN this13 AS node, this12 AS edge
    }
    WITH *
    WHERE (node.title STARTS WITH $param4 OR node.title STARTS WITH $param5)
    RETURN { min: min(edge.screenTime), max: max(edge.screenTime) } AS this14
}
RETURN this { .name, actedInAggregate: { count: this4, node: { title: this9 }, edge: { screenTime: this14 } } } AS this
----

'''

== Count with where

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate(where: {title: "The Matrix"}) {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Matrix"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        RETURN this3 AS node, this2 AS edge
    }
    WITH *
    WHERE node.title = $param0
    RETURN count(node) AS this4
}
RETURN this { actedInAggregate: { count: this4 } } AS this
----

'''

== Count with where and string aggregation

.GraphQL-Query
[source,graphql]
----
{
  actors {
    actedInAggregate(where: {title_STARTS_WITH: "The"}) {
      count
      edge {
        screenTime {
          min
          max
        }
      }
      node {
        title {
          longest
          shortest
        }
      }
    }
    name
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The",
  "param1": "The",
  "param2": "The"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this0:ACTED_IN]->(this1:Movie)
        RETURN this1 AS node, this0 AS edge
        UNION
        WITH this
        MATCH (this)-[this2:ACTED_IN]->(this3:Series)
        RETURN this3 AS node, this2 AS edge
    }
    WITH *
    WHERE node.title STARTS WITH $param0
    RETURN count(node) AS this4
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this5:ACTED_IN]->(this6:Movie)
        RETURN this6 AS node, this5 AS edge
        UNION
        WITH this
        MATCH (this)-[this7:ACTED_IN]->(this8:Series)
        RETURN this8 AS node, this7 AS edge
    }
    WITH *
    WHERE node.title STARTS WITH $param1
    WITH node
    ORDER BY size(node.title) DESC
    WITH collect(node.title) AS list
    RETURN { longest: head(list), shortest: last(list) } AS this9
}
CALL {
    WITH this
    CALL {
        WITH this
        MATCH (this)-[this10:ACTED_IN]->(this11:Movie)
        RETURN this11 AS node, this10 AS edge
        UNION
        WITH this
        MATCH (this)-[this12:ACTED_IN]->(this13:Series)
        RETURN this13 AS node, this12 AS edge
    }
    WITH *
    WHERE node.title STARTS WITH $param2
    RETURN { min: min(edge.screenTime), max: max(edge.screenTime) } AS this14
}
RETURN this { .name, actedInAggregate: { count: this4, node: { title: this9 }, edge: { screenTime: this14 } } } AS this
----

'''

