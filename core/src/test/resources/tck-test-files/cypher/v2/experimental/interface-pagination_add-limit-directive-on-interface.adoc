:toc:

= add @limit directive on interface

== Source schema

[source,graphql,schema=true]
----
type SomeNodeType implements MyOtherInterface & MyInterface {
  id: ID! @id @unique
  something: String
  somethingElse: String
  other: [OtherNodeType!]! @relationship(type: "HAS_OTHER_NODES", direction: OUT)
}

type OtherNodeType {
  id: ID! @id @unique
  interfaceField: MyInterface! @relationship(type: "HAS_INTERFACE_NODES", direction: OUT)
}

interface MyInterface {
  id: ID!
}

interface MyOtherInterface implements MyInterface {
  id: ID!
  something: String
}

type MyImplementationType implements MyInterface {
  id: ID! @id @unique
}

type MyOtherImplementationType implements MyInterface {
  id: ID! @id @unique
  someField: String
}

extend interface MyInterface @limit(default: 13, max: 15)
----
== Limit argument overwrites default if lower than max

.GraphQL-Query
[source,graphql]
----
{
  myInterfaces(options: {limit: 3}) {
    id
    ... on MyOtherImplementationType {
      someField
    }
    ... on MyOtherInterface {
      something
      ... on SomeNodeType {
        somethingElse
        other {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 3
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:MyImplementationType)
    WITH this0 { .id, __resolveType: "MyImplementationType", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:MyOtherImplementationType)
    WITH this1 { .id, .someField, __resolveType: "MyOtherImplementationType", __id: id(this1) } AS this1
    RETURN this1 AS this
    UNION
    MATCH (this2:SomeNodeType)
    CALL {
        WITH this2
        MATCH (this2)-[this3:HAS_OTHER_NODES]->(this4:OtherNodeType)
        WITH this4 { .id } AS this4
        RETURN collect(this4) AS var5
    }
    WITH this2 { .id, .something, .somethingElse, other: var5, __resolveType: "SomeNodeType", __id: id(this2) } AS this2
    RETURN this2 AS this
}
WITH this

LIMIT $param0
RETURN this AS this
----

'''

== Limit from directive on Interface

.GraphQL-Query
[source,graphql]
----
{
  myInterfaces {
    id
    ... on MyOtherImplementationType {
      someField
    }
    ... on MyOtherInterface {
      something
      ... on SomeNodeType {
        somethingElse
        other {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 13
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:MyImplementationType)
    WITH this0 { .id, __resolveType: "MyImplementationType", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:MyOtherImplementationType)
    WITH this1 { .id, .someField, __resolveType: "MyOtherImplementationType", __id: id(this1) } AS this1
    RETURN this1 AS this
    UNION
    MATCH (this2:SomeNodeType)
    CALL {
        WITH this2
        MATCH (this2)-[this3:HAS_OTHER_NODES]->(this4:OtherNodeType)
        WITH this4 { .id } AS this4
        RETURN collect(this4) AS var5
    }
    WITH this2 { .id, .something, .somethingElse, other: var5, __resolveType: "SomeNodeType", __id: id(this2) } AS this2
    RETURN this2 AS this
}
WITH this

LIMIT $param0
RETURN this AS this
----

'''

== Limit from directive on Interface when interface queried nested

.GraphQL-Query
[source,graphql]
----
{
  someNodeTypes {
    id
    other {
      id
      interfaceField {
        id
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 13
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:SomeNodeType)
CALL {
    WITH this
    MATCH (this)-[this0:HAS_OTHER_NODES]->(this1:OtherNodeType)
    CALL {
        WITH this1
        CALL {
            WITH *
            MATCH (this1)-[this2:HAS_INTERFACE_NODES]->(this3:MyImplementationType)
            WITH this3 { .id, __resolveType: "MyImplementationType", __id: id(this3) } AS this3
            RETURN this3 AS var4
            UNION
            WITH *
            MATCH (this1)-[this5:HAS_INTERFACE_NODES]->(this6:MyOtherImplementationType)
            WITH this6 { .id, __resolveType: "MyOtherImplementationType", __id: id(this6) } AS this6
            RETURN this6 AS var4
            UNION
            WITH *
            MATCH (this1)-[this7:HAS_INTERFACE_NODES]->(this8:SomeNodeType)
            WITH this8 { .id, __resolveType: "SomeNodeType", __id: id(this8) } AS this8
            RETURN this8 AS var4
        }
        WITH var4
        
        LIMIT $param0
        RETURN head(collect(var4)) AS var4
    }
    WITH this1 { .id, interfaceField: var4 } AS this1
    RETURN collect(this1) AS var9
}
RETURN this { .id, other: var9 } AS this
----

'''

== Max limit from directive on Interface overwrites the limit argument

.GraphQL-Query
[source,graphql]
----
{
  myInterfaces(options: {limit: 16}) {
    id
    ... on MyOtherImplementationType {
      someField
    }
    ... on MyOtherInterface {
      something
      ... on SomeNodeType {
        somethingElse
        other {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 15
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:MyImplementationType)
    WITH this0 { .id, __resolveType: "MyImplementationType", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:MyOtherImplementationType)
    WITH this1 { .id, .someField, __resolveType: "MyOtherImplementationType", __id: id(this1) } AS this1
    RETURN this1 AS this
    UNION
    MATCH (this2:SomeNodeType)
    CALL {
        WITH this2
        MATCH (this2)-[this3:HAS_OTHER_NODES]->(this4:OtherNodeType)
        WITH this4 { .id } AS this4
        RETURN collect(this4) AS var5
    }
    WITH this2 { .id, .something, .somethingElse, other: var5, __resolveType: "SomeNodeType", __id: id(this2) } AS this2
    RETURN this2 AS this
}
WITH this

LIMIT $param0
RETURN this AS this
----

'''

== Max limit from directive on Interface overwrites the limit argument - combines with sort

.GraphQL-Query
[source,graphql]
----
{
  myInterfaces(options: {limit: 16, sort: [{id: ASC}]}) {
    id
    ... on MyOtherImplementationType {
      someField
    }
    ... on MyOtherInterface {
      something
      ... on SomeNodeType {
        somethingElse
        other {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 15
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:MyImplementationType)
    WITH this0 { .id, __resolveType: "MyImplementationType", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:MyOtherImplementationType)
    WITH this1 { .id, .someField, __resolveType: "MyOtherImplementationType", __id: id(this1) } AS this1
    RETURN this1 AS this
    UNION
    MATCH (this2:SomeNodeType)
    CALL {
        WITH this2
        MATCH (this2)-[this3:HAS_OTHER_NODES]->(this4:OtherNodeType)
        WITH this4 { .id } AS this4
        RETURN collect(this4) AS var5
    }
    WITH this2 { .id, .something, .somethingElse, other: var5, __resolveType: "SomeNodeType", __id: id(this2) } AS this2
    RETURN this2 AS this
}
WITH this
ORDER BY this.id ASC
LIMIT $param0
RETURN this AS this
----

'''

