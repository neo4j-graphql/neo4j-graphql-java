:toc:

= Union top level operations

== Source schema

[source,graphql,schema=true]
----
union Search = Genre | Movie

type Genre {
  name: String
}

type Movie {
  title: String
  search: [Search!]! @relationship(type: "SEARCH", direction: OUT)
}
----

== Read union

.GraphQL-Query
[source,graphql]
----
{
  searches {
    ... on Movie {
      title
    }
    ... on Genre {
      name
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
CALL {
	MATCH (genre0:Genre)
	WITH genre0 {
		__resolveType: 'Genre',
		__id: elementId(genre0),
		.name
	} AS genre0
	RETURN genre0 AS this UNION
	MATCH (movie0:Movie)
	WITH movie0 {
		__resolveType: 'Movie',
		__id: elementId(movie0),
		.title
	} AS movie0
	RETURN movie0 AS this
}
WITH this
RETURN this AS this
----

'''

== Read union with relationship on member type

.GraphQL-Query
[source,graphql]
----
{
  searches {
    ... on Movie {
      title
      search {
        ... on Genre {
          name
        }
      }
    }
    ... on Genre {
      name
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
CALL {
	MATCH (genre0:Genre)
	WITH genre0 {
		__resolveType: 'Genre',
		__id: elementId(genre0),
		.name
	} AS genre0
	RETURN genre0 AS this UNION
	MATCH (movie0:Movie)
	CALL {
		WITH movie0
		CALL {
			WITH *
			MATCH (movie0)-[search1:SEARCH]->(genre1:Genre)
			WITH genre1 {
				__resolveType: 'Genre',
				__id: elementId(genre1),
				.name
			} AS genre1
			RETURN genre1 AS search0 UNION
			WITH *
			MATCH (movie0)-[search2:SEARCH]->(movie1:Movie)
			WITH movie1 {
				__resolveType: 'Movie',
				__id: elementId(movie1)
			} AS movie1
			RETURN movie1 AS search0
		}
		WITH search0
		RETURN collect(search0) AS search0
	}
	WITH movie0 {
		__resolveType: 'Movie',
		__id: elementId(movie0),
		.title,
		search: search0
	} AS movie0
	RETURN movie0 AS this
}
WITH this
RETURN this AS this
----

'''

