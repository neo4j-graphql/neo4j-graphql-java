:toc:

= Union top level operations

== Source schema

[source,graphql,schema=true]
----
union Search = Genre | Movie

type Genre {
  name: String
}

type Movie {
  title: String
  search: [Search!]! @relationship(type: "SEARCH", direction: OUT)
}
----
== Read union

.GraphQL-Query
[source,graphql]
----
{
  searches {
    ... on Movie {
      title
    }
    ... on Genre {
      name
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": [],
      "jwtAllowedNamesExample": "Horror"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Genre)
    WITH this0 { .name, __resolveType: "Genre", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:Movie)
    WITH this1 { .title, __resolveType: "Movie", __id: id(this1) } AS this1
    RETURN this1 AS this
}
WITH this
RETURN this AS this
----

'''

== Read union with filters  - only specifying a filter for one constituent automatically filters-out the other constituents from the return data

.GraphQL-Query
[source,graphql]
----
{
  searches(where: {Movie: {NOT: {title: "The Matrix"}}}) {
    ... on Movie {
      title
      search {
        ... on Genre {
          name
        }
      }
    }
    ... on Genre {
      name
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": [],
      "jwtAllowedNamesExample": "Horror"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Matrix"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Movie)
    WHERE NOT (this0.title = $param0)
    CALL {
        WITH this0
        CALL {
            WITH *
            MATCH (this0)-[this1:SEARCH]->(this2:Genre)
            WITH this2 { .name, __resolveType: "Genre", __id: id(this2) } AS this2
            RETURN this2 AS var3
            UNION
            WITH *
            MATCH (this0)-[this4:SEARCH]->(this5:Movie)
            WITH this5 { __resolveType: "Movie", __id: id(this5) } AS this5
            RETURN this5 AS var3
        }
        WITH var3
        RETURN collect(var3) AS var3
    }
    WITH this0 { .title, search: var3, __resolveType: "Movie", __id: id(this0) } AS this0
    RETURN this0 AS this
}
WITH this
RETURN this AS this
----

'''

== Read union with pagination and filter

.GraphQL-Query
[source,graphql]
----
{
  searches(
    options: {limit: 1, offset: 2}
    where: {Movie: {NOT: {title: "The Matrix"}}, Genre: {}}
  ) {
    ... on Movie {
      title
      search(options: {limit: 10}, where: {Genre: {name_STARTS_WITH: "d"}, Movie: {}}) {
        ... on Genre {
          name
        }
      }
    }
    ... on Genre {
      name
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": [],
      "jwtAllowedNamesExample": "Horror"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Matrix",
  "param1": "d",
  "param2": 10,
  "param3": 2,
  "param4": 1
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Genre)
    WITH this0 { .name, __resolveType: "Genre", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:Movie)
    WHERE NOT (this1.title = $param0)
    CALL {
        WITH this1
        CALL {
            WITH *
            MATCH (this1)-[this2:SEARCH]->(this3:Genre)
            WHERE this3.name STARTS WITH $param1
            WITH this3 { .name, __resolveType: "Genre", __id: id(this3) } AS this3
            RETURN this3 AS var4
            UNION
            WITH *
            MATCH (this1)-[this5:SEARCH]->(this6:Movie)
            WITH this6 { __resolveType: "Movie", __id: id(this6) } AS this6
            RETURN this6 AS var4
        }
        WITH var4
        
        LIMIT $param2
        RETURN collect(var4) AS var4
    }
    WITH this1 { .title, search: var4, __resolveType: "Movie", __id: id(this1) } AS this1
    RETURN this1 AS this
}
WITH this

SKIP $param3
LIMIT $param4
RETURN this AS this
----

'''

== Read union with relationship on member type

.GraphQL-Query
[source,graphql]
----
{
  searches {
    ... on Movie {
      title
      search {
        ... on Genre {
          name
        }
      }
    }
    ... on Genre {
      name
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": [],
      "jwtAllowedNamesExample": "Horror"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Genre)
    WITH this0 { .name, __resolveType: "Genre", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:Movie)
    CALL {
        WITH this1
        CALL {
            WITH *
            MATCH (this1)-[this2:SEARCH]->(this3:Genre)
            WITH this3 { .name, __resolveType: "Genre", __id: id(this3) } AS this3
            RETURN this3 AS var4
            UNION
            WITH *
            MATCH (this1)-[this5:SEARCH]->(this6:Movie)
            WITH this6 { __resolveType: "Movie", __id: id(this6) } AS this6
            RETURN this6 AS var4
        }
        WITH var4
        RETURN collect(var4) AS var4
    }
    WITH this1 { .title, search: var4, __resolveType: "Movie", __id: id(this1) } AS this1
    RETURN this1 AS this
}
WITH this
RETURN this AS this
----

'''

== Read union with relationship on member type with filters

.GraphQL-Query
[source,graphql]
----
{
  searches(where: {Movie: {NOT: {title: "The Matrix"}}, Genre: {}}) {
    ... on Movie {
      title
      search {
        ... on Genre {
          name
        }
      }
    }
    ... on Genre {
      name
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": [],
      "jwtAllowedNamesExample": "Horror"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "The Matrix"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Genre)
    WITH this0 { .name, __resolveType: "Genre", __id: id(this0) } AS this0
    RETURN this0 AS this
    UNION
    MATCH (this1:Movie)
    WHERE NOT (this1.title = $param0)
    CALL {
        WITH this1
        CALL {
            WITH *
            MATCH (this1)-[this2:SEARCH]->(this3:Genre)
            WITH this3 { .name, __resolveType: "Genre", __id: id(this3) } AS this3
            RETURN this3 AS var4
            UNION
            WITH *
            MATCH (this1)-[this5:SEARCH]->(this6:Movie)
            WITH this6 { __resolveType: "Movie", __id: id(this6) } AS this6
            RETURN this6 AS var4
        }
        WITH var4
        RETURN collect(var4) AS var4
    }
    WITH this1 { .title, search: var4, __resolveType: "Movie", __id: id(this1) } AS this1
    RETURN this1 AS this
}
WITH this
RETURN this AS this
----

'''

== Read union with relationship on member type with filters on related field

.GraphQL-Query
[source,graphql]
----
{
  searches(
    where: {Movie: {searchConnection_SOME: {Genre: {node: {name: "Action"}}}}}
  ) {
    ... on Movie {
      title
      search {
        ... on Genre {
          name
        }
      }
    }
    ... on Genre {
      name
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": [],
      "jwtAllowedNamesExample": "Horror"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Action"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
    MATCH (this0:Movie)
    WHERE EXISTS {
        MATCH (this0)-[this1:SEARCH]->(this2:Genre)
        WHERE this2.name = $param0
    }
    CALL {
        WITH this0
        CALL {
            WITH *
            MATCH (this0)-[this3:SEARCH]->(this4:Genre)
            WITH this4 { .name, __resolveType: "Genre", __id: id(this4) } AS this4
            RETURN this4 AS var5
            UNION
            WITH *
            MATCH (this0)-[this6:SEARCH]->(this7:Movie)
            WITH this7 { __resolveType: "Movie", __id: id(this7) } AS this7
            RETURN this7 AS var5
        }
        WITH var5
        RETURN collect(var5) AS var5
    }
    WITH this0 { .title, search: var5, __resolveType: "Movie", __id: id(this0) } AS this0
    RETURN this0 AS this
}
WITH this
RETURN this AS this
----

'''

