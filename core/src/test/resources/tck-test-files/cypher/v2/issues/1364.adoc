:toc:

= https://github.com/neo4j/graphql/issues/1364

== Source schema

[source,graphql,schema=true]
----
type Actor {
  id: ID
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
  id: ID
  title: String
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
  genres: [Genre!]! @relationship(type: "HAS_GENRE", direction: OUT)
  totalGenres: Int! @cypher(statement: """
  MATCH (this)-[:HAS_GENRE]->(genre:Genre)
  RETURN count(DISTINCT genre) as result
  """, columnName: "result")
  totalActors: Int! @cypher(statement: """
  MATCH (this)<-[:ACTED_IN]-(actor:Actor)
  RETURN count(DISTINCT actor) as result
  """, columnName: "result")
}

type Genre {
  id: ID
  name: String
  totalMovies: Int! @cypher(statement: """
  MATCH (this)<-[:HAS_GENRE]-(movie:Movie)
  RETURN count(DISTINCT movie) as result
  """, columnName: "result")
}
----
== Should project cypher fields after applying the sort when sorting on a non-cypher field on a root connection)

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(sort: [{title: ASC}]) {
    edges {
      node {
        title
        totalGenres
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    WITH *
    ORDER BY this0.title ASC
    CALL {
        WITH this0
        CALL {
            WITH this0
            WITH this0 AS this
            MATCH (this)-[:HAS_GENRE]->(genre:Genre)
            RETURN count(DISTINCT genre) as result
        }
        UNWIND result AS this1
        RETURN head(collect(this1)) AS this1
    }
    RETURN collect({ node: { title: this0.title, totalGenres: this1 } }) AS var2
}
RETURN { edges: var2, totalCount: totalCount } AS this
----

'''

== Should project cypher fields before the sort when sorting on a cypher field on a root connection

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(sort: [{totalGenres: ASC}]) {
    edges {
      node {
        title
        totalGenres
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    CALL {
        WITH this0
        CALL {
            WITH this0
            WITH this0 AS this
            MATCH (this)-[:HAS_GENRE]->(genre:Genre)
            RETURN count(DISTINCT genre) as result
        }
        UNWIND result AS this1
        RETURN head(collect(this1)) AS this1
    }
    WITH *
    ORDER BY this1 ASC
    RETURN collect({ node: { title: this0.title, totalGenres: this1 } }) AS var2
}
RETURN { edges: var2, totalCount: totalCount } AS this
----

'''

== Should sort properly on a root connection when multiple cypher fields are queried but only sorted on one

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(sort: [{totalGenres: ASC}]) {
    edges {
      node {
        title
        totalGenres
        totalActors
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    CALL {
        WITH this0
        CALL {
            WITH this0
            WITH this0 AS this
            MATCH (this)-[:HAS_GENRE]->(genre:Genre)
            RETURN count(DISTINCT genre) as result
        }
        UNWIND result AS this1
        RETURN head(collect(this1)) AS this1
    }
    WITH *
    ORDER BY this1 ASC
    CALL {
        WITH this0
        CALL {
            WITH this0
            WITH this0 AS this
            MATCH (this)<-[:ACTED_IN]-(actor:Actor)
            RETURN count(DISTINCT actor) as result
        }
        UNWIND result AS this2
        RETURN head(collect(this2)) AS this2
    }
    RETURN collect({ node: { title: this0.title, totalGenres: this1, totalActors: this2 } }) AS var3
}
RETURN { edges: var3, totalCount: totalCount } AS this
----

'''

