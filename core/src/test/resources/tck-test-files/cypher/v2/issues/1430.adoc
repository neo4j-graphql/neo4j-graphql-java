:toc:

= https://github.com/neo4j/graphql/issues/1430

== Source schema

[source,graphql,schema=true]
----
type ABCE {
  id: ID @id
  name: String
  interface: InterfaceMom @relationship(type: "HAS_INTERFACE", direction: OUT)
}

interface InterfaceMom {
  id: ID @id
  name: String
}

type ChildOne implements InterfaceMom {
  id: ID @id
  name: String
  feathur: String
}

type ChildTwo implements InterfaceMom {
  id: ID @id
  name: String
  sth: String
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== should not allow connecting a second node to an existing one-to-one relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateAbces(
    where: {id: "TestId"}
    connect: {interface: {where: {node: {name: "childone name connect"}}}}
  ) {
    abces {
      id
      interface {
        id
        name
        __typename
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "TestId",
  "this_connect_interface0_node_param0" : "childone name connect",
  "this_connect_interface1_node_param0" : "childone name connect"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:ABCE)
WHERE this.id = $param0 CALL apoc.util.validate(EXISTS((this)-[:HAS_INTERFACE]->(:ChildOne)), 'Relationship field \"%s.%s\" cannot have more than one node linked', ['ABCE', 'interface']) CALL apoc.util.validate(EXISTS((this)-[:HAS_INTERFACE]->(:ChildTwo)), 'Relationship field \"%s.%s\" cannot have more than one node linked', ['ABCE', 'interface'])
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_interface0_node:ChildOne)
	WHERE this_connect_interface0_node.name = $this_connect_interface0_node_param0
	CALL {
		WITH *
		WITH collect(this_connect_interface0_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_interface0_node
			MERGE (this)-[:HAS_INTERFACE]->(this_connect_interface0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_interface0_node
	RETURN count(*) AS connect_this_connect_interface_ChildOne
}
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_interface1_node:ChildTwo)
	WHERE this_connect_interface1_node.name = $this_connect_interface1_node_param0
	CALL {
		WITH *
		WITH collect(this_connect_interface1_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_interface1_node
			MERGE (this)-[:HAS_INTERFACE]->(this_connect_interface1_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_interface1_node
	RETURN count(*) AS connect_this_connect_interface_ChildTwo
}
WITH *
WITH *
CALL {
	WITH this
	MATCH (this)-[update_this0:HAS_INTERFACE]->(this_ChildOne:ChildOne)
	RETURN {
		__resolveType: 'ChildOne',
		id: this_ChildOne.id,
		name: this_ChildOne.name
	} AS this_interface UNION
	WITH this
	MATCH (this)-[update_this1:HAS_INTERFACE]->(this_ChildTwo:ChildTwo)
	RETURN {
		__resolveType: 'ChildTwo',
		id: this_ChildTwo.id,
		name: this_ChildTwo.name
	} AS this_interface
}
RETURN collect(DISTINCT this {
	.id,
	interface: this_interface
}) AS data
----

'''

== should not allow to create more than one node for a one-to-one relationship

.GraphQL-Query
[source,graphql]
----
mutation ddfs {
  updateAbces(
    where: {id: "TestID"}
    create: {interface: {node: {ChildOne: {name: "childone name2"}}}}
  ) {
    abces {
      id
      interface {
        id
        name
        __typename
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "TestID",
  "this_create_interface_ChildOne0_node_ChildOne_name" : "childone name2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:ABCE)
WHERE this.id = $param0 CALL apoc.util.validate(EXISTS((this)-[:HAS_INTERFACE]->(:ChildOne)), 'Relationship field \"%s.%s\" cannot have more than one node linked', ['ABCE', 'interface'])
CREATE (this_create_interface_ChildOne0_node_ChildOne:ChildOne)
SET this_create_interface_ChildOne0_node_ChildOne.id = randomUUID()
SET this_create_interface_ChildOne0_node_ChildOne.name = $this_create_interface_ChildOne0_node_ChildOne_name
MERGE (this)-[:HAS_INTERFACE]->(this_create_interface_ChildOne0_node_ChildOne)
WITH *
WITH *
CALL {
	WITH this
	MATCH (this)-[update_this0:HAS_INTERFACE]->(this_ChildOne:ChildOne)
	RETURN {
		__resolveType: 'ChildOne',
		id: this_ChildOne.id,
		name: this_ChildOne.name
	} AS this_interface UNION
	WITH this
	MATCH (this)-[update_this1:HAS_INTERFACE]->(this_ChildTwo:ChildTwo)
	RETURN {
		__resolveType: 'ChildTwo',
		id: this_ChildTwo.id,
		name: this_ChildTwo.name
	} AS this_interface
}
RETURN collect(DISTINCT this {
	.id,
	interface: this_interface
}) AS data
----

'''

