:toc:

= https://github.com/neo4j/graphql/issues/1430

== Source schema

[source,graphql,schema=true]
----
type ABCE {
  id: ID @id @unique
  name: String
  interface: InterfaceMom @relationship(type: "HAS_INTERFACE", direction: OUT)
}

interface InterfaceMom {
  id: ID @id
  name: String
}

type ChildOne implements InterfaceMom {
  id: ID @id @unique
  name: String
  feathur: String
}

type ChildTwo implements InterfaceMom {
  id: ID @id @unique
  name: String
  sth: String
}
----
== should not allow connecting a second node to an existing one-to-one relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateAbces(
    where: {id: "TestId"}
    connect: {interface: {where: {node: {name: "childone name connect"}}}}
  ) {
    abces {
      id
      interface {
        id
        name
        __typename
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "TestId",
  "this_connect_interface0_node_param0": "childone name connect",
  "this_connect_interface1_node_param0": "childone name connect"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:ABCE)
WHERE this.id = $param0
WITH *
WHERE apoc.util.validatePredicate(EXISTS((this)-[:HAS_INTERFACE]->(:ChildOne)) OR EXISTS((this)-[:HAS_INTERFACE]->(:ChildTwo)),'Relationship field "%s.%s" cannot have more than one node linked',["ABCE","interface"])
WITH *
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_interface0_node:ChildOne)
	WHERE this_connect_interface0_node.name = $this_connect_interface0_node_param0
	CALL {
		WITH *
		WITH collect(this_connect_interface0_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_connect_interface0_node
			MERGE (this)-[:HAS_INTERFACE]->(this_connect_interface0_node)
		}
	}
WITH this, this_connect_interface0_node
	RETURN count(*) AS connect_this_connect_interface_ChildOne0
}
CALL {
		WITH this
	OPTIONAL MATCH (this_connect_interface1_node:ChildTwo)
	WHERE this_connect_interface1_node.name = $this_connect_interface1_node_param0
	CALL {
		WITH *
		WITH collect(this_connect_interface1_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_connect_interface1_node
			MERGE (this)-[:HAS_INTERFACE]->(this_connect_interface1_node)
		}
	}
WITH this, this_connect_interface1_node
	RETURN count(*) AS connect_this_connect_interface_ChildTwo1
}
WITH *
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[update_this0:HAS_INTERFACE]->(update_this1:ChildOne)
        WITH update_this1 { .id, .name, __resolveType: "ChildOne", __id: id(update_this1) } AS update_this1
        RETURN update_this1 AS update_var2
        UNION
        WITH *
        MATCH (this)-[update_this3:HAS_INTERFACE]->(update_this4:ChildTwo)
        WITH update_this4 { .id, .name, __resolveType: "ChildTwo", __id: id(update_this4) } AS update_this4
        RETURN update_this4 AS update_var2
    }
    WITH update_var2
    RETURN head(collect(update_var2)) AS update_var2
}
RETURN collect(DISTINCT this { .id, interface: update_var2 }) AS data
----

'''

== should not allow to create more than one node for a one-to-one relationship

.GraphQL-Query
[source,graphql]
----
mutation ddfs {
  updateAbces(
    where: {id: "TestID"}
    create: {interface: {node: {ChildOne: {name: "childone name2"}}}}
  ) {
    abces {
      id
      interface {
        id
        name
        __typename
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "TestID",
  "this_create_interface_ChildOne0_node_ChildOne_name": "childone name2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:ABCE)
WHERE this.id = $param0
WITH *
WHERE apoc.util.validatePredicate(EXISTS((this)-[:HAS_INTERFACE]->(:ChildOne)) OR EXISTS((this)-[:HAS_INTERFACE]->(:ChildTwo)),'Relationship field "%s.%s" cannot have more than one node linked',["ABCE","interface"])
CREATE (this_create_interface_ChildOne0_node_ChildOne:ChildOne)
SET this_create_interface_ChildOne0_node_ChildOne.id = randomUUID()
SET this_create_interface_ChildOne0_node_ChildOne.name = $this_create_interface_ChildOne0_node_ChildOne_name
MERGE (this)-[:HAS_INTERFACE]->(this_create_interface_ChildOne0_node_ChildOne)
WITH *
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[update_this0:HAS_INTERFACE]->(update_this1:ChildOne)
        WITH update_this1 { .id, .name, __resolveType: "ChildOne", __id: id(update_this1) } AS update_this1
        RETURN update_this1 AS update_var2
        UNION
        WITH *
        MATCH (this)-[update_this3:HAS_INTERFACE]->(update_this4:ChildTwo)
        WITH update_this4 { .id, .name, __resolveType: "ChildTwo", __id: id(update_this4) } AS update_this4
        RETURN update_this4 AS update_var2
    }
    WITH update_var2
    RETURN head(collect(update_var2)) AS update_var2
}
RETURN collect(DISTINCT this { .id, interface: update_var2 }) AS data
----

'''

