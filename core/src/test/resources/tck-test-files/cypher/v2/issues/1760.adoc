:toc:

= https://github.com/neo4j/graphql/issues/1760

== Source schema

[source,graphql,schema=true]
----
interface BusinessObject {
  id: ID! @id(autogenerate: false)
  nameDetails: NameDetails
}

type ApplicationVariant implements BusinessObject @auth(rules: [{isAuthenticated: true, roles: ["ALL"]}]) @exclude(operations: [CREATE, UPDATE, DELETE]) {
  markets: [Market!]! @relationship(type: "HAS_MARKETS", direction: OUT)
  id: ID! @id(autogenerate: false)
  relatedId: ID @cypher(statement: "MATCH (this)<-[:HAS_BASE]-(n:BaseObject) RETURN n.id")
  baseObject: BaseObject! @relationship(type: "HAS_BASE", direction: IN)
  current: Boolean!
  nameDetails: NameDetails @relationship(type: "HAS_NAME", direction: OUT)
}

type NameDetails @auth(rules: [{isAuthenticated: true, roles: ["ALL"]}]) @exclude(operations: [CREATE, READ, UPDATE, DELETE]) {
  fullName: String!
}

type Market implements BusinessObject @auth(rules: [{isAuthenticated: true, roles: ["ALL"]}]) @exclude(operations: [CREATE, UPDATE, DELETE]) {
  id: ID! @id(autogenerate: false)
  nameDetails: NameDetails @relationship(type: "HAS_NAME", direction: OUT)
}

type BaseObject @auth(rules: [{isAuthenticated: true, roles: ["ALL"]}]) @exclude(operations: [CREATE, UPDATE, DELETE]) {
  id: ID! @id
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== Cypher fields should be calculated early in query if needed for sort, sort applied after initial match

.GraphQL-Query
[source,graphql]
----
query getApplicationVariants($where: ApplicationVariantWhere, $options: ApplicationVariantOptions) {
  applicationVariants(where: $where, options: $options) {
    relatedId
    nameDetailsConnection {
      edges {
        node {
          fullName
        }
      }
    }
    marketsConnection {
      edges {
        node {
          nameDetailsConnection {
            edges {
              node {
                fullName
              }
            }
          }
        }
      }
    }
    baseObjectConnection {
      edges {
        node {
          id
        }
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "current": true
  },
  "options": {
    "sort": {
      "relatedId": "ASC"
    },
    "offset": 0,
    "limit": 50
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth" : {
    "isAuthenticated" : false,
    "roles" : [ ]
  },
  "param0" : true,
  "param3" : 0,
  "param4" : 50
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:ApplicationVariant)
WHERE (this.current = $param0
	AND apoc.util.validatePredicate(NOT ((any(r IN ['ALL']
		WHERE any(rr IN $auth.roles
		WHERE rr = r))
		AND apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0]))), '@neo4j/graphql/FORBIDDEN', [0]))
CALL {
	WITH this
	UNWIND apoc.cypher.runFirstColumnSingle('MATCH (this)<-[:HAS_BASE]-(n:BaseObject) RETURN n.id', {
		this: this,
		auth: $auth
	}) AS this_relatedId
	RETURN head(collect(this_relatedId)) AS this_relatedId
}
WITH * ORDER BY this_relatedId ASC SKIP $param3 LIMIT $param4
CALL {
	WITH this
	MATCH (this)-[this_connection_nameDetailsConnectionthis0:HAS_NAME]->(this_NameDetails:NameDetails)
	WHERE apoc.util.validatePredicate(NOT ((any(r IN ['ALL']
		WHERE any(rr IN $auth.roles
		WHERE rr = r))
		AND apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0]))), '@neo4j/graphql/FORBIDDEN', [0])
	WITH {
		node: {
			fullName: this_NameDetails.fullName
		}
	} AS edge
	WITH collect(edge) AS edges
	WITH edges, size(edges) AS totalCount
	RETURN {
		edges: edges,
		totalCount: totalCount
	} AS this_nameDetailsConnection
}
CALL {
	WITH this
	MATCH (this)-[this_connection_marketsConnectionthis0:HAS_MARKETS]->(this_Market:Market)
	WHERE apoc.util.validatePredicate(NOT ((any(r IN ['ALL']
		WHERE any(rr IN $auth.roles
		WHERE rr = r))
		AND apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0]))), '@neo4j/graphql/FORBIDDEN', [0])
	CALL {
		WITH this_Market
		MATCH (this_Market)-[this_Market_connection_nameDetailsConnectionthis0:HAS_NAME]->(this_Market_NameDetails:NameDetails)
		WHERE apoc.util.validatePredicate(NOT ((any(r IN ['ALL']
			WHERE any(rr IN $auth.roles
			WHERE rr = r))
			AND apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0]))), '@neo4j/graphql/FORBIDDEN', [0])
		WITH {
			node: {
				fullName: this_Market_NameDetails.fullName
			}
		} AS edge
		WITH collect(edge) AS edges
		WITH edges, size(edges) AS totalCount
		RETURN {
			edges: edges,
			totalCount: totalCount
		} AS this_Market_nameDetailsConnection
	}
	WITH {
		node: {
			nameDetailsConnection: this_Market_nameDetailsConnection
		}
	} AS edge
	WITH collect(edge) AS edges
	WITH edges, size(edges) AS totalCount
	RETURN {
		edges: edges,
		totalCount: totalCount
	} AS this_marketsConnection
}
CALL {
	WITH this
	MATCH (this)<-[this_connection_baseObjectConnectionthis0:HAS_BASE]-(this_BaseObject:BaseObject)
	WHERE apoc.util.validatePredicate(NOT ((any(r IN ['ALL']
		WHERE any(rr IN $auth.roles
		WHERE rr = r))
		AND apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0]))), '@neo4j/graphql/FORBIDDEN', [0])
	WITH {
		node: {
			id: this_BaseObject.id
		}
	} AS edge
	WITH collect(edge) AS edges
	WITH edges, size(edges) AS totalCount
	RETURN {
		edges: edges,
		totalCount: totalCount
	} AS this_baseObjectConnection
}
RETURN this {
	relatedId: this_relatedId,
	nameDetailsConnection: this_nameDetailsConnection,
	marketsConnection: this_marketsConnection,
	baseObjectConnection: this_baseObjectConnection
} AS this
----

'''

