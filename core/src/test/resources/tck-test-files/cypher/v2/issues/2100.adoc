:toc:

= https://github.com/neo4j/graphql/issues/2100

== Source schema

[source,graphql,schema=true]
----
type ServiceLog {
  id: ID
  records: [Record!]! @relationship(type: "HAS_BUSSING", direction: OUT)
}

type BussingRecord implements Record {
  id: ID!
  attendance: Int
  markedAttendance: Boolean! @cypher(statement: """
  MATCH (this)<-[:PRESENT_AT_SERVICE|ABSENT_FROM_SERVICE]-(member:Member)
  RETURN COUNT(member) > 0 AS markedAttendance
  """, columnName: "markedAttendance")
  serviceDate: TimeGraph! @relationship(type: "BUSSED_ON", direction: OUT)
}

interface Church {
  id: ID @id
  name: String!
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
}

type Bacenta implements Church {
  id: ID @id @unique
  name: String!
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  bussing(limit: Int!): [BussingRecord!]! @cypher(statement: """
  MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(records:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
  WITH DISTINCT records, date LIMIT $limit
  RETURN records ORDER BY date.date DESC
  """, columnName: "records")
}

type TimeGraph {
  date: Date
}

interface Record {
  id: ID!
  attendance: Int
  markedAttendance: Boolean! @cypher(statement: """
  MATCH (this)<-[:PRESENT_AT_SERVICE|ABSENT_FROM_SERVICE]-(member:Member)
  RETURN COUNT(member) > 0 AS markedAttendance
  """, columnName: "markedAttendance")
  serviceDate: TimeGraph! @relationship(type: "BUSSED_ON", direction: OUT)
}
----
== query nested relations under a root connection field

.GraphQL-Query
[source,graphql]
----
{
  bacentas(where: {id: 1}) {
    id
    name
    bussing(limit: 10) {
      id
      attendance
      markedAttendance
      serviceDate {
        date
        __typename
      }
      __typename
    }
    __typename
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "1",
  "param1": 10
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Bacenta)
WHERE this.id = $param0
CALL {
    WITH this
    CALL {
        WITH this
        WITH this AS this
        MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(records:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
        WITH DISTINCT records, date LIMIT $param1
        RETURN records ORDER BY date.date DESC
    }
    WITH records AS this0
    CALL {
        WITH this0
        CALL {
            WITH this0
            WITH this0 AS this
            MATCH (this)<-[:PRESENT_AT_SERVICE|ABSENT_FROM_SERVICE]-(member:Member)
            RETURN COUNT(member) > 0 AS markedAttendance
        }
        UNWIND markedAttendance AS this1
        RETURN head(collect(this1)) AS this1
    }
    CALL {
        WITH this0
        MATCH (this0)-[this2:BUSSED_ON]->(this3:TimeGraph)
        WITH this3 { .date } AS this3
        RETURN head(collect(this3)) AS var4
    }
    RETURN collect(this0 { .id, .attendance, markedAttendance: this1, serviceDate: var4 }) AS this0
}
RETURN this { .id, .name, bussing: this0 } AS this
----

'''

