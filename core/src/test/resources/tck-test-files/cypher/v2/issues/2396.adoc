:toc:

= https://github.com/neo4j/graphql/issues/2396

== Source schema

[source,graphql,schema=true]
----
type PostalCode @mutation(operations: [CREATE, UPDATE]) {
  archivedAt: DateTime
  number: String! @unique
  address: [Address!]! @relationship(type: "HAS_POSTAL_CODE", direction: IN)
}

extend type PostalCode @authorization(filter: [{where: {node: {archivedAt: null}}}])

union AddressNode = Estate

type Address @mutation(operations: [CREATE, UPDATE]) {
  archivedAt: DateTime
  uuid: ID! @id @unique
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  address: String! @unique
  streetNumber: String
  route: String! @coalesce(value: "")
  postalCode: PostalCode! @relationship(type: "HAS_POSTAL_CODE", direction: OUT)
  locality: String! @coalesce(value: "")
  administrativeAreaLevel1: String! @coalesce(value: "")
  administrativeAreaLevel2: String
  country: String! @coalesce(value: "")
  location: Point!
  node: [AddressNode!]! @relationship(type: "HAS_ADDRESS", direction: IN)
}

extend type Address @authorization(filter: [{where: {node: {archivedAt: null}}}])

type Mandate @mutation(operations: [CREATE, UPDATE]) {
  archivedAt: DateTime
  number: String! @unique
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  price: Float!
  valuation: Valuation! @relationship(type: "HAS_VALUATION", direction: OUT)
}

extend type Mandate @authorization(filter: [{where: {node: {archivedAt: null}}}])

type Valuation @mutation(operations: [CREATE, UPDATE]) {
  archivedAt: DateTime
  uuid: ID! @id @unique
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  estate: Estate @relationship(type: "VALUATION_FOR", direction: OUT)
}

extend type Valuation @authorization(filter: [{where: {node: {archivedAt: null}}}])

enum EstateType {
  APARTMENT
  HOUSE_VILLA
  TOWNHOUSE
  LAND
  PARKING
  BOX
  BUILDING
  COMMERCIAL_PREMISE
  CHALET
  CASTLE
  OFFICE
  BUSINESS_FUND
}

type Estate @mutation(operations: [CREATE, UPDATE]) {
  archivedAt: DateTime
  uuid: ID! @id @unique
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  estateType: EstateType!
  area: Float!
  floor: Int
  address: Address @relationship(type: "HAS_ADDRESS", direction: OUT)
}

extend type Estate @authorization(filter: [{where: {node: {archivedAt: null}}}])
----

== nested relationship filter

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {},
  "where": {
    "valuation": {
      "estate": {
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 0,
  "isAuthenticated": true
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
OPTIONAL MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
WITH *, count(this0) AS valuationCount
WITH *
WITH *
WHERE ((valuationCount <> 0 AND single(this1 IN [(this0)-[:VALUATION_FOR]->(this1:Estate) WHERE this1.floor >= $param0 | 1] WHERE true)) AND ($isAuthenticated = true AND this.archivedAt IS NULL))
CALL {
    WITH this
    MATCH (this)-[this2:HAS_VALUATION]->(this3:Valuation)
    WITH *
    WHERE ($isAuthenticated = true AND this3.archivedAt IS NULL)
    CALL {
        WITH this3
        MATCH (this3)-[this4:VALUATION_FOR]->(this5:Estate)
        WITH *
        WHERE ($isAuthenticated = true AND this5.archivedAt IS NULL)
        WITH this5 { .uuid } AS this5
        RETURN head(collect(this5)) AS var6
    }
    WITH this3 { estate: var6 } AS this3
    RETURN head(collect(this3)) AS var7
}
RETURN this { valuation: var7 } AS this
----

'''

== nested relationship filter with AND

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {},
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 0,
  "param1": 0,
  "isAuthenticated": true
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
OPTIONAL MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
WITH *, count(this0) AS valuationCount
WITH *
WITH *
WHERE ((this.price >= $param0 AND (valuationCount <> 0 AND single(this1 IN [(this0)-[:VALUATION_FOR]->(this1:Estate) WHERE this1.floor >= $param1 | 1] WHERE true))) AND ($isAuthenticated = true AND this.archivedAt IS NULL))
CALL {
    WITH this
    MATCH (this)-[this2:HAS_VALUATION]->(this3:Valuation)
    WITH *
    WHERE ($isAuthenticated = true AND this3.archivedAt IS NULL)
    CALL {
        WITH this3
        MATCH (this3)-[this4:VALUATION_FOR]->(this5:Estate)
        WITH *
        WHERE ($isAuthenticated = true AND this5.archivedAt IS NULL)
        WITH this5 { .uuid } AS this5
        RETURN head(collect(this5)) AS var6
    }
    WITH this3 { estate: var6 } AS this3
    RETURN head(collect(this3)) AS var7
}
RETURN this { valuation: var7 } AS this
----

'''

== query should contain offset of 0 and limit of 20

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {
    "offset": 0,
    "limit": 20
  },
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "address": {
          "postalCode": {
            "number_IN": [
              "13001"
            ]
          }
        },
        "area_GTE": 0,
        "estateType_IN": [
          "APARTMENT"
        ],
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "13001"
  ],
  "param1": [
    "APARTMENT"
  ],
  "param2": 0,
  "param3": 0,
  "param4": 0,
  "isAuthenticated": true,
  "param6": 0,
  "param7": 20
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
CALL {
    WITH this
    MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
    CALL {
        WITH this0
        MATCH (this0)-[:VALUATION_FOR]->(this1:Estate)
        CALL {
            WITH this1
            MATCH (this1)-[:HAS_ADDRESS]->(this2:Address)
            OPTIONAL MATCH (this2)-[:HAS_POSTAL_CODE]->(this3:PostalCode)
            WITH *, count(this3) AS postalCodeCount
            WITH *
            WHERE (postalCodeCount <> 0 AND this3.number IN $param0)
            RETURN count(this2) = 1 AS var4
        }
        WITH *
        WHERE (this1.estateType IN $param1 AND this1.area >= $param2 AND this1.floor >= $param3 AND var4 = true)
        RETURN count(this1) = 1 AS var5
    }
    WITH *
    WHERE var5 = true
    RETURN count(this0) = 1 AS var6
}
WITH *
WHERE ((this.price >= $param4 AND var6 = true) AND ($isAuthenticated = true AND this.archivedAt IS NULL))
WITH *

SKIP $param6
LIMIT $param7
CALL {
    WITH this
    MATCH (this)-[this7:HAS_VALUATION]->(this8:Valuation)
    WITH *
    WHERE ($isAuthenticated = true AND this8.archivedAt IS NULL)
    CALL {
        WITH this8
        MATCH (this8)-[this9:VALUATION_FOR]->(this10:Estate)
        WITH *
        WHERE ($isAuthenticated = true AND this10.archivedAt IS NULL)
        WITH this10 { .uuid } AS this10
        RETURN head(collect(this10)) AS var11
    }
    WITH this8 { estate: var11 } AS this8
    RETURN head(collect(this8)) AS var12
}
RETURN this { valuation: var12 } AS this
----

'''

== query should contain offset of 20 and limit of 40

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {
    "offset": 20,
    "limit": 40
  },
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "address": {
          "postalCode": {
            "number_IN": [
              "13001"
            ]
          }
        },
        "area_GTE": 0,
        "estateType_IN": [
          "APARTMENT"
        ],
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "13001"
  ],
  "param1": [
    "APARTMENT"
  ],
  "param2": 0,
  "param3": 0,
  "param4": 0,
  "isAuthenticated": true,
  "param6": 20,
  "param7": 40
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
CALL {
    WITH this
    MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
    CALL {
        WITH this0
        MATCH (this0)-[:VALUATION_FOR]->(this1:Estate)
        CALL {
            WITH this1
            MATCH (this1)-[:HAS_ADDRESS]->(this2:Address)
            OPTIONAL MATCH (this2)-[:HAS_POSTAL_CODE]->(this3:PostalCode)
            WITH *, count(this3) AS postalCodeCount
            WITH *
            WHERE (postalCodeCount <> 0 AND this3.number IN $param0)
            RETURN count(this2) = 1 AS var4
        }
        WITH *
        WHERE (this1.estateType IN $param1 AND this1.area >= $param2 AND this1.floor >= $param3 AND var4 = true)
        RETURN count(this1) = 1 AS var5
    }
    WITH *
    WHERE var5 = true
    RETURN count(this0) = 1 AS var6
}
WITH *
WHERE ((this.price >= $param4 AND var6 = true) AND ($isAuthenticated = true AND this.archivedAt IS NULL))
WITH *

SKIP $param6
LIMIT $param7
CALL {
    WITH this
    MATCH (this)-[this7:HAS_VALUATION]->(this8:Valuation)
    WITH *
    WHERE ($isAuthenticated = true AND this8.archivedAt IS NULL)
    CALL {
        WITH this8
        MATCH (this8)-[this9:VALUATION_FOR]->(this10:Estate)
        WITH *
        WHERE ($isAuthenticated = true AND this10.archivedAt IS NULL)
        WITH this10 { .uuid } AS this10
        RETURN head(collect(this10)) AS var11
    }
    WITH this8 { estate: var11 } AS this8
    RETURN head(collect(this8)) AS var12
}
RETURN this { valuation: var12 } AS this
----

'''

== query should not contain skip or limit

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {},
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "address": {
          "postalCode": {
            "number_IN": [
              "13001"
            ]
          }
        },
        "area_GTE": 0,
        "estateType_IN": [
          "APARTMENT"
        ],
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "13001"
  ],
  "param1": [
    "APARTMENT"
  ],
  "param2": 0,
  "param3": 0,
  "param4": 0,
  "isAuthenticated": true
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
CALL {
    WITH this
    MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
    CALL {
        WITH this0
        MATCH (this0)-[:VALUATION_FOR]->(this1:Estate)
        CALL {
            WITH this1
            MATCH (this1)-[:HAS_ADDRESS]->(this2:Address)
            OPTIONAL MATCH (this2)-[:HAS_POSTAL_CODE]->(this3:PostalCode)
            WITH *, count(this3) AS postalCodeCount
            WITH *
            WHERE (postalCodeCount <> 0 AND this3.number IN $param0)
            RETURN count(this2) = 1 AS var4
        }
        WITH *
        WHERE (this1.estateType IN $param1 AND this1.area >= $param2 AND this1.floor >= $param3 AND var4 = true)
        RETURN count(this1) = 1 AS var5
    }
    WITH *
    WHERE var5 = true
    RETURN count(this0) = 1 AS var6
}
WITH *
WHERE ((this.price >= $param4 AND var6 = true) AND ($isAuthenticated = true AND this.archivedAt IS NULL))
CALL {
    WITH this
    MATCH (this)-[this7:HAS_VALUATION]->(this8:Valuation)
    WITH *
    WHERE ($isAuthenticated = true AND this8.archivedAt IS NULL)
    CALL {
        WITH this8
        MATCH (this8)-[this9:VALUATION_FOR]->(this10:Estate)
        WITH *
        WHERE ($isAuthenticated = true AND this10.archivedAt IS NULL)
        WITH this10 { .uuid } AS this10
        RETURN head(collect(this10)) AS var11
    }
    WITH this8 { estate: var11 } AS this8
    RETURN head(collect(this8)) AS var12
}
RETURN this { valuation: var12 } AS this
----

'''

