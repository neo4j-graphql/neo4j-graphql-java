:toc:

= https://github.com/neo4j/graphql/issues/2396

== Source schema

[source,graphql,schema=true]
----
type PostalCode @exclude(operations: [DELETE]) {
  archivedAt: DateTime
  number: String! @id(autogenerate: false)
  address: [Address!]! @relationship(type: "HAS_POSTAL_CODE", direction: IN)
}

extend type PostalCode @auth(rules: [{where: {archivedAt: null}}])

union AddressNode = Estate

type Address @exclude(operations: [DELETE]) {
  archivedAt: DateTime
  uuid: ID! @id
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  address: String! @unique
  streetNumber: String
  route: String! @coalesce(value: "")
  postalCode: PostalCode! @relationship(type: "HAS_POSTAL_CODE", direction: OUT)
  locality: String! @coalesce(value: "")
  administrativeAreaLevel1: String! @coalesce(value: "")
  administrativeAreaLevel2: String
  country: String! @coalesce(value: "")
  location: Point!
  node: [AddressNode!]! @relationship(type: "HAS_ADDRESS", direction: IN)
}

extend type Address @auth(rules: [{where: {archivedAt: null}}])

type Mandate @exclude(operations: [DELETE]) {
  archivedAt: DateTime
  number: String! @unique
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  price: Float!
  valuation: Valuation! @relationship(type: "HAS_VALUATION", direction: OUT)
}

extend type Mandate @auth(rules: [{where: {archivedAt: null}}])

type Valuation @exclude(operations: [DELETE]) {
  archivedAt: DateTime
  uuid: ID! @id
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  estate: Estate @relationship(type: "VALUATION_FOR", direction: OUT)
}

extend type Valuation @auth(rules: [{where: {archivedAt: null}}])

enum EstateType {
  APARTMENT
  HOUSE_VILLA
  TOWNHOUSE
  LAND
  PARKING
  BOX
  BUILDING
  COMMERCIAL_PREMISE
  CHALET
  CASTLE
  OFFICE
  BUSINESS_FUND
}

type Estate @exclude(operations: [DELETE]) {
  archivedAt: DateTime
  uuid: ID! @id
  createdAt: DateTime! @timestamp(operations: [CREATE])
  updatedAt: DateTime! @timestamp(operations: [CREATE, UPDATE])
  estateType: EstateType!
  area: Float!
  floor: Int
  address: Address @relationship(type: "HAS_ADDRESS", direction: OUT)
}

extend type Estate @auth(rules: [{where: {archivedAt: null}}])
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== query should contain offset of 0 and limit of 20

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {
    "offset": 0,
    "limit": 20
  },
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "address": {
          "postalCode": {
            "number_IN": [
              "13001"
            ]
          }
        },
        "area_GTE": 0,
        "estateType_IN": [
          "APARTMENT"
        ],
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 0,
  "param1": 0,
  "param2": 0,
  "param3": [
    "APARTMENT"
  ],
  "param4": [
    "13001"
  ],
  "param5": 0,
  "param6": 20
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
WHERE (this.price >= $param0
	AND EXISTS {
		MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
		WHERE EXISTS {
			MATCH (this0)-[:VALUATION_FOR]->(this1:Estate)
			WHERE (this1.area >= $param1
				AND this1.floor >= $param2
				AND this1.estateType IN $param3
				AND EXISTS {
					MATCH (this1)-[:HAS_ADDRESS]->(this2:Address)
					WHERE EXISTS {
						MATCH (this2)-[:HAS_POSTAL_CODE]->(this3:PostalCode)
						WHERE this3.number IN $param4
					}
				})
		}
	}
	AND this.archivedAt IS NULL)
WITH * SKIP $param5 LIMIT $param6
CALL {
	WITH this
	MATCH (this)-[this4:HAS_VALUATION]->(this_valuation:Valuation)
	WHERE this_valuation.archivedAt IS NULL
	CALL {
		WITH this_valuation
		MATCH (this_valuation)-[this5:VALUATION_FOR]->(this_valuation_estate:Estate)
		WHERE this_valuation_estate.archivedAt IS NULL
		WITH this_valuation_estate {
			.uuid
		} AS this_valuation_estate
		RETURN head(collect(this_valuation_estate)) AS this_valuation_estate
	}
	WITH this_valuation {
		estate: this_valuation_estate
	} AS this_valuation
	RETURN head(collect(this_valuation)) AS this_valuation
}
RETURN this {
	valuation: this_valuation
} AS this
----

'''

== query should contain offset of 20 and limit of 40

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {
    "offset": 20,
    "limit": 40
  },
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "address": {
          "postalCode": {
            "number_IN": [
              "13001"
            ]
          }
        },
        "area_GTE": 0,
        "estateType_IN": [
          "APARTMENT"
        ],
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 0,
  "param1": 0,
  "param2": 0,
  "param3": [
    "APARTMENT"
  ],
  "param4": [
    "13001"
  ],
  "param5": 20,
  "param6": 40
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
WHERE (this.price >= $param0
	AND EXISTS {
		MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
		WHERE EXISTS {
			MATCH (this0)-[:VALUATION_FOR]->(this1:Estate)
			WHERE (this1.area >= $param1
				AND this1.floor >= $param2
				AND this1.estateType IN $param3
				AND EXISTS {
					MATCH (this1)-[:HAS_ADDRESS]->(this2:Address)
					WHERE EXISTS {
						MATCH (this2)-[:HAS_POSTAL_CODE]->(this3:PostalCode)
						WHERE this3.number IN $param4
					}
				})
		}
	}
	AND this.archivedAt IS NULL)
WITH * SKIP $param5 LIMIT $param6
CALL {
	WITH this
	MATCH (this)-[this4:HAS_VALUATION]->(this_valuation:Valuation)
	WHERE this_valuation.archivedAt IS NULL
	CALL {
		WITH this_valuation
		MATCH (this_valuation)-[this5:VALUATION_FOR]->(this_valuation_estate:Estate)
		WHERE this_valuation_estate.archivedAt IS NULL
		WITH this_valuation_estate {
			.uuid
		} AS this_valuation_estate
		RETURN head(collect(this_valuation_estate)) AS this_valuation_estate
	}
	WITH this_valuation {
		estate: this_valuation_estate
	} AS this_valuation
	RETURN head(collect(this_valuation)) AS this_valuation
}
RETURN this {
	valuation: this_valuation
} AS this
----

'''

== query should not contain skip or limit

.GraphQL-Query
[source,graphql]
----
query Mandates($where: MandateWhere, $options: MandateOptions) {
  mandates(options: $options, where: $where) {
    valuation {
      estate {
        uuid
      }
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "options": {},
  "where": {
    "price_GTE": 0,
    "valuation": {
      "estate": {
        "address": {
          "postalCode": {
            "number_IN": [
              "13001"
            ]
          }
        },
        "area_GTE": 0,
        "estateType_IN": [
          "APARTMENT"
        ],
        "floor_GTE": 0
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 0,
  "param1": 0,
  "param2": 0,
  "param3": [
    "APARTMENT"
  ],
  "param4": [
    "13001"
  ]
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Mandate)
WHERE (this.price >= $param0
	AND EXISTS {
		MATCH (this)-[:HAS_VALUATION]->(this0:Valuation)
		WHERE EXISTS {
			MATCH (this0)-[:VALUATION_FOR]->(this1:Estate)
			WHERE (this1.area >= $param1
				AND this1.floor >= $param2
				AND this1.estateType IN $param3
				AND EXISTS {
					MATCH (this1)-[:HAS_ADDRESS]->(this2:Address)
					WHERE EXISTS {
						MATCH (this2)-[:HAS_POSTAL_CODE]->(this3:PostalCode)
						WHERE this3.number IN $param4
					}
				})
		}
	}
	AND this.archivedAt IS NULL)
CALL {
	WITH this
	MATCH (this)-[this4:HAS_VALUATION]->(this_valuation:Valuation)
	WHERE this_valuation.archivedAt IS NULL
	CALL {
		WITH this_valuation
		MATCH (this_valuation)-[this5:VALUATION_FOR]->(this_valuation_estate:Estate)
		WHERE this_valuation_estate.archivedAt IS NULL
		WITH this_valuation_estate {
			.uuid
		} AS this_valuation_estate
		RETURN head(collect(this_valuation_estate)) AS this_valuation_estate
	}
	WITH this_valuation {
		estate: this_valuation_estate
	} AS this_valuation
	RETURN head(collect(this_valuation)) AS this_valuation
}
RETURN this {
	valuation: this_valuation
} AS this
----

'''

