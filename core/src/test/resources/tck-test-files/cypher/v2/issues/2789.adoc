:toc:

= https://github.com/neo4j/graphql/issues/2789

== Source schema

[source,graphql,schema=true]
----
type User @authorization(validate: [{where: {node: {id: "Foo"}}}]) {
  id: ID
  password: String! @authorization(validate: [{where: {node: {id: "Bar"}}}])
}
----
== has no conflicting parameters when combining node and field auth

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(update: {password: "123"}) {
    users {
      password
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated": false,
  "update_param1": "Foo",
  "update_param2": "Bar",
  "param1": "Foo",
  "this_update_password": "123",
  "authorization__before_param1": "Bar",
  "authorization__after_param1": "Foo"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
WITH *
WHERE apoc.util.validatePredicate(NOT ($isAuthenticated = true AND ($param1 IS NOT NULL AND this.id = $param1)), "@neo4j/graphql/FORBIDDEN", [0])
WITH this
WHERE apoc.util.validatePredicate(NOT ($isAuthenticated = true AND ($authorization__before_param1 IS NOT NULL AND this.id = $authorization__before_param1)), "@neo4j/graphql/FORBIDDEN", [0])

SET this.password = $this_update_password
WITH this
WHERE apoc.util.validatePredicate(NOT ($isAuthenticated = true AND ($authorization__after_param1 IS NOT NULL AND this.id = $authorization__after_param1)), "@neo4j/graphql/FORBIDDEN", [0]) AND apoc.util.validatePredicate(NOT ($isAuthenticated = true AND ($authorization__after_param1 IS NOT NULL AND this.id = $authorization__after_param1)), "@neo4j/graphql/FORBIDDEN", [0])
WITH *
WHERE (apoc.util.validatePredicate(NOT ($isAuthenticated = true AND ($update_param1 IS NOT NULL AND this.id = $update_param1)), "@neo4j/graphql/FORBIDDEN", [0]) AND apoc.util.validatePredicate(NOT ($isAuthenticated = true AND ($update_param2 IS NOT NULL AND this.id = $update_param2)), "@neo4j/graphql/FORBIDDEN", [0]))
RETURN collect(DISTINCT this { .password }) AS data
----

'''

