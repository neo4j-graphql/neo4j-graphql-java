:toc:

= #288

== Source schema

[source,graphql,schema=true]
----
type USER {
  USERID: String
  COMPANYID: String
  COMPANY: [COMPANY!]! @relationship(type: "IS_PART_OF", direction: OUT)
}

type COMPANY {
  USERS: [USER!]! @relationship(type: "IS_PART_OF", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Can create a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(input: {USERID: "userid", COMPANYID: "companyid"}) {
    users {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "create_param0" : [ {
    "USERID" : "userid",
    "COMPANYID" : "companyid"
  } ]
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var1
CALL {
	WITH create_var1
	CREATE (create_this0:USER)
	SET create_this0.USERID = create_var1.USERID, create_this0.COMPANYID = create_var1.COMPANYID
	RETURN create_this0
}
RETURN collect(create_this0 {
	.USERID,
	.COMPANYID
}) AS data
----

'''

== Can update a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {USERID: "userid"}, update: {COMPANYID: "companyid2"}) {
    users {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "userid",
  "this_update_COMPANYID" : "companyid2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:USER)
WHERE this.USERID = $param0
SET this.COMPANYID = $this_update_COMPANYID
RETURN collect(DISTINCT this {
	.USERID,
	.COMPANYID
}) AS data
----

'''

