:toc:

= #288

== Source schema

[source,graphql,schema=true]
----
type USER {
  USERID: String
  COMPANYID: String
  COMPANY: [COMPANY!]! @relationship(type: "IS_PART_OF", direction: OUT)
}

type COMPANY {
  USERS: [USER!]! @relationship(type: "IS_PART_OF", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Can create a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(input: {USERID: "userid", COMPANYID: "companyid"}) {
    users {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "create_param0": [
    {
      "USERID": "userid",
      "COMPANYID": "companyid"
    }
  ],
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var1
CALL {
	WITH create_var1
	CREATE (create_this0:USER)
	SET create_this0.USERID = create_var1.USERID, create_this0.COMPANYID = create_var1.COMPANYID
	RETURN create_this0
}
RETURN collect(create_this0 {
	.USERID,
	.COMPANYID
}) AS data
----

'''

== Can update a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {USERID: "userid"}, update: {COMPANYID: "companyid2"}) {
    users {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "userid",
  "this_update_COMPANYID": "companyid2",
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:USER)
WHERE this.USERID = $param0
SET this.COMPANYID = $this_update_COMPANYID
RETURN collect(DISTINCT this {
	.USERID,
	.COMPANYID
}) AS data
----

'''

