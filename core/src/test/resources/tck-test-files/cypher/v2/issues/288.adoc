:toc:

= #288

== Source schema

[source,graphql,schema=true]
----
type USER {
  USERID: String
  COMPANYID: String
  COMPANY: [COMPANY!]! @relationship(type: "IS_PART_OF", direction: OUT)
}

type COMPANY {
  USERS: [USER!]! @relationship(type: "IS_PART_OF", direction: IN)
}
----
== Can create a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  createUsers(input: {USERID: "userid", COMPANYID: "companyid"}) {
    users {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "create_param0": [
    {
      "USERID": "userid",
      "COMPANYID": "companyid"
    }
  ]
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var0
CALL {
    WITH create_var0
    CREATE (create_this1:USER)
    SET
        create_this1.USERID = create_var0.USERID,
        create_this1.COMPANYID = create_var0.COMPANYID
    
    RETURN create_this1
}
RETURN collect(create_this1 { .USERID, .COMPANYID }) AS data
----

'''

== Can update a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUsers(where: {USERID: "userid"}, update: {COMPANYID: "companyid2"}) {
    users {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "userid",
  "this_update_COMPANYID": "companyid2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:USER)
WHERE this.USERID = $param0


SET this.COMPANYID = $this_update_COMPANYID

RETURN collect(DISTINCT this { .USERID, .COMPANYID }) AS data
----

'''

