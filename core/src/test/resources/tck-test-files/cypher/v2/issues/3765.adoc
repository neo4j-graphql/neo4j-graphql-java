:toc:

= https://github.com/neo4j/graphql/issues/3765

== Source schema

[source,graphql,schema=true]
----
type User {
  name: String!
  otherName: String
}

type Post {
  content: String!
  alternateContent: String!
  likes: [User!]! @relationship(type: "LIKES", direction: IN, properties: "likesProperties")
}

interface likesProperties @relationshipProperties {
  someProp: String!
}
----
== aggregation

=== count

==== filter + explicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, AND: [{count_GT: 25}, {count_LT: 33}]}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 33
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND (count(this1) > $param1 AND count(this1) < $param2)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== filter + explicit OR

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, OR: [{count_GT: 25}, {count_LT: 33}]}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 33
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND (count(this1) > $param1 OR count(this1) < $param2)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== filter + explicit OR which contains an explicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, OR: [{AND: [{count_GT: 25}, {count_LTE: 99}]}, {count_LT: 33}]}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 99,
  "param3": 33
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND ((count(this1) > $param1 AND count(this1) <= $param2) OR count(this1) < $param3)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== filter + explicit OR which contains an implicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, OR: [{count_GT: 25, count_LTE: 99}, {count_LT: 33}]}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 99,
  "param2": 25,
  "param3": 33
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND ((count(this1) <= $param1 AND count(this1) > $param2) OR count(this1) < $param3)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== filter + implicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, AND: [{count_GT: 25, count_LT: 33}]}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 33,
  "param2": 25
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND (count(this1) < $param1 AND count(this1) > $param2)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''


=== node/edge

==== count filter + complex mixing between edge/node filter

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, OR: [{edge: {someProp_LONGEST_GT: 4, someProp_SHORTEST_LT: 10}, node: {name_AVERAGE_GT: 3782}}, {node: {name_SHORTEST_GT: 25}}], edge: {someProp_LONGEST_LT: 12, someProp_SHORTEST_GT: 20}}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 3782,
  "param2": 4,
  "param3": 10,
  "param4": 25,
  "param5": 20,
  "param6": 12
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND ((avg(size(this1.name)) > $param1 AND (max(size(this0.someProp)) > $param2 AND min(size(this0.someProp)) < $param3)) OR min(size(this1.name)) > $param4) AND (min(size(this0.someProp)) > $param5 AND max(size(this0.someProp)) < $param6)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== count filter + explicit node AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, node: {AND: [{name_SHORTEST_GT: 25}, {name_SHORTEST_LT: 80}]}}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 80
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND (min(size(this1.name)) > $param1 AND min(size(this1.name)) < $param2)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== count filter + explicit node OR

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, node: {OR: [{name_SHORTEST_GT: 25}, {name_SHORTEST_LT: 80}]}}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 80
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND (min(size(this1.name)) > $param1 OR min(size(this1.name)) < $param2)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== count filter + explicit node OR which contains an explicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, node: {OR: [{name_SHORTEST_GT: 25, name_SHORTEST_LT: 40}, {name_SHORTEST_GTE: 1233}]}}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 40,
  "param3": 1233
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND ((min(size(this1.name)) > $param1 AND min(size(this1.name)) < $param2) OR min(size(this1.name)) >= $param3)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

==== count filter + implicit node AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {likesAggregate: {count_GT: 10, node: {AND: [{name_SHORTEST_GT: 25, name_SHORTEST_LT: 80}]}}}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 10,
  "param1": 25,
  "param2": 80
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
CALL {
    WITH this
    MATCH (this)<-[this0:LIKES]-(this1:User)
    RETURN (count(this1) > $param0 AND (min(size(this1.name)) > $param1 AND min(size(this1.name)) < $param2)) AS var2
}
WITH *
WHERE var2 = true
RETURN this { .content } AS this
----

'''

== property filters

=== explicit NOT with an implicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(where: {NOT: {content: "stuff", alternateContent: "stuff2"}}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE NOT (this.content = $param0 AND this.alternateContent = $param1)
RETURN this { .content } AS this
----

'''

=== explicit OR with an implicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {OR: [{content: "stuff", alternateContent: "stuff2"}, {content: "stuff3"}]}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2",
  "param2": "stuff3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE ((this.content = $param0 AND this.alternateContent = $param1) OR this.content = $param2)
RETURN this { .content } AS this
----

'''

=== implicit AND

.GraphQL-Query
[source,graphql]
----
{
  posts(where: {content: "stuff", alternateContent: "stuff2"}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE (this.content = $param0 AND this.alternateContent = $param1)
RETURN this { .content } AS this
----

'''


== relationship filters

=== explicit OR outside relationship filters

.GraphQL-Query
[source,graphql]
----
{
  posts(
    where: {OR: [{likes_SOME: {name: "stuff"}}, {likes_ALL: {otherName: "stuff2"}}, {likes_SOME: {otherName: "stuff3"}}]}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2",
  "param2": "stuff3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE (EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE this0.name = $param0
} OR (EXISTS {
    MATCH (this)<-[:LIKES]-(this1:User)
    WHERE this1.otherName = $param1
} AND NOT (EXISTS {
    MATCH (this)<-[:LIKES]-(this1:User)
    WHERE NOT (this1.otherName = $param1)
})) OR EXISTS {
    MATCH (this)<-[:LIKES]-(this2:User)
    WHERE this2.otherName = $param2
})
RETURN this { .content } AS this
----

'''

=== implicit AND  inside relationship filter

.GraphQL-Query
[source,graphql]
----
{
  posts(where: {likes_SOME: {name: "stuff", otherName: "stuff2"}}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE (this0.name = $param0 AND this0.otherName = $param1)
}
RETURN this { .content } AS this
----

'''

=== implicit AND outside relationship filters

.GraphQL-Query
[source,graphql]
----
{
  posts(where: {likes_SOME: {name: "stuff"}, likes_ALL: {otherName: "stuff2"}}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff2",
  "param1": "stuff"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE ((EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE this0.otherName = $param0
} AND NOT (EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE NOT (this0.otherName = $param0)
})) AND EXISTS {
    MATCH (this)<-[:LIKES]-(this1:User)
    WHERE this1.name = $param1
})
RETURN this { .content } AS this
----

'''


