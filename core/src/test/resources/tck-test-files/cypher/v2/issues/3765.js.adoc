// This file was generated by the Test-Case extractor of neo4j-graphql
:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/3765

== Setup

.Schema
[source,graphql,schema=true]
----
type User {
  name: String!
  otherName: String
}

type Post {
  content: String!
  alternateContent: String!
  likes: [User!]! @relationship(type: "LIKES", direction: IN, properties: "likesProperties")
}

type likesProperties @relationshipProperties {
  someProp: String!
}
----

== property filters

=== implicit AND

.GraphQL-Query
[source,graphql,request=true]
----
{
  posts(where: {content: "stuff", alternateContent: "stuff2"}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE (this.content = $param0 AND this.alternateContent = $param1)
RETURN this { .content } AS this
----

=== explicit OR with an implicit AND

.GraphQL-Query
[source,graphql,request=true]
----
{
  posts(
    where: {OR: [{content: "stuff", alternateContent: "stuff2"}, {content: "stuff3"}]}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2",
  "param2": "stuff3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE ((this.content = $param0 AND this.alternateContent = $param1) OR this.content = $param2)
RETURN this { .content } AS this
----

=== explicit NOT with an implicit AND

.GraphQL-Query
[source,graphql,request=true]
----
{
  posts(where: {NOT: {content: "stuff", alternateContent: "stuff2"}}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE NOT (this.content = $param0 AND this.alternateContent = $param1)
RETURN this { .content } AS this
----

== relationship filters

=== implicit AND  inside relationship filter

.GraphQL-Query
[source,graphql,request=true]
----
{
  posts(where: {likes_SOME: {name: "stuff", otherName: "stuff2"}}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE (this0.name = $param0 AND this0.otherName = $param1)
}
RETURN this { .content } AS this
----

=== implicit AND outside relationship filters

.GraphQL-Query
[source,graphql,request=true]
----
{
  posts(where: {likes_SOME: {name: "stuff"}, likes_ALL: {otherName: "stuff2"}}) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff2",
  "param1": "stuff"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE ((EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE this0.otherName = $param0
} AND NOT (EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE NOT (this0.otherName = $param0)
})) AND EXISTS {
    MATCH (this)<-[:LIKES]-(this1:User)
    WHERE this1.name = $param1
})
RETURN this { .content } AS this
----

=== explicit OR outside relationship filters

.GraphQL-Query
[source,graphql,request=true]
----
{
  posts(
    where: {OR: [{likes_SOME: {name: "stuff"}}, {likes_ALL: {otherName: "stuff2"}}, {likes_SOME: {otherName: "stuff3"}}]}
  ) {
    content
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "stuff",
  "param1": "stuff2",
  "param2": "stuff3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Post)
WHERE (EXISTS {
    MATCH (this)<-[:LIKES]-(this0:User)
    WHERE this0.name = $param0
} OR (EXISTS {
    MATCH (this)<-[:LIKES]-(this1:User)
    WHERE this1.otherName = $param1
} AND NOT (EXISTS {
    MATCH (this)<-[:LIKES]-(this1:User)
    WHERE NOT (this1.otherName = $param1)
})) OR EXISTS {
    MATCH (this)<-[:LIKES]-(this2:User)
    WHERE this2.otherName = $param2
})
RETURN this { .content } AS this
----
