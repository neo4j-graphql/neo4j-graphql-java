:toc:

= https://github.com/neo4j/graphql/issues/3929

== Source schema

[source,graphql,schema=true]
----
type User @authorization(filter: [{where: {node: {id: "$jwt.uid"}}}]) {
  id: ID! @unique
  email: String!
  name: String
}

type Group @authorization(validate: [{where: {node: {creator: {id: "$jwt.uid"}}}}]) {
  id: ID! @id @unique
  name: String
  members: [Person!]! @relationship(type: "MEMBER_OF", direction: IN)
  creator: User! @relationship(type: "CREATOR_OF", direction: IN, nestedOperations: [CONNECT])
}

type Person @authorization(validate: [{where: {node: {creator: {id: "$jwt.uid"}}}}]) {
  id: ID! @id @unique
  name: String!
  creator: User! @relationship(type: "CREATOR_OF", direction: IN)
  group: Group! @relationship(type: "MEMBER_OF", direction: OUT)
}

extend schema @authentication {
  query: Query
  mutation: Mutation
}
----

== should not add an authorization check for connects coming from create

.GraphQL-Query
[source,graphql]
----
mutation UpdateGroups($where: GroupWhere, $delete: GroupDeleteInput) {
  updateGroups(where: $where, delete: $delete) {
    info {
      nodesDeleted
      relationshipsDeleted
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "id": "group1_id"
  },
  "delete": {
    "members": [
      {
        "where": {
          "node": {
            "id": "member1_id"
          }
        }
      }
    ]
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated" : true,
  "jwt" : {
    "roles" : [ ],
    "sub" : "michel"
  },
  "param0" : "group1_id",
  "updateGroups" : {
    "args" : {
      "delete" : {
        "members" : [ {
          "where" : {
            "node" : {
              "id" : "member1_id"
            }
          }
        } ]
      }
    }
  },
  "updateGroups_args_delete_members0_where_this_delete_members0param0" : "member1_id"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Group)
OPTIONAL MATCH (this)<-[:CREATOR_OF]-(this0:User)
WITH *, count(this0) AS creatorCount
WITH *
WHERE (this.id = $param0
	AND apoc.util.validatePredicate(NOT (($isAuthenticated = true
		AND creatorCount <> 0
		AND $jwt.uid IS NOT NULL
		AND this0.id = $jwt.uid)), '@neo4j/graphql/FORBIDDEN', [0]))
WITH *
CALL {
	WITH *
	OPTIONAL MATCH (this)<-[this_delete_members0_relationship:MEMBER_OF]-(this_delete_members0:Person)
	OPTIONAL MATCH (this_delete_members0)<-[:CREATOR_OF]-(authorization__before_this0:User)
	WITH *, count(authorization__before_this0) AS creatorCount
	WHERE (this_delete_members0.id = $updateGroups_args_delete_members0_where_this_delete_members0param0
		AND apoc.util.validatePredicate(NOT (($isAuthenticated = true
			AND creatorCount <> 0
			AND $jwt.uid IS NOT NULL
			AND authorization__before_this0.id = $jwt.uid)), '@neo4j/graphql/FORBIDDEN', [0]))
	WITH this_delete_members0_relationship, collect(DISTINCT this_delete_members0) AS this_delete_members0_to_delete
	CALL {
		WITH this_delete_members0_to_delete
		UNWIND this_delete_members0_to_delete AS x DETACH DELETE x
	}
}
WITH *
WITH *
CALL {
	WITH this
	MATCH (this)<-[this_creator_User_unique:CREATOR_OF]-(:User)
	WITH count(this_creator_User_unique) AS c
	WHERE apoc.util.validatePredicate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDGroup.creator required exactly once', [0])
	RETURN c AS this_creator_User_unique_ignored
}
RETURN 'Query cannot conclude with CALL'
----

'''

