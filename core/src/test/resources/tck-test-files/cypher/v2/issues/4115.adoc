:toc:

= https://github.com/neo4j/graphql/issues/4115

== Source schema

[source,graphql,schema=true]
----
type User {
  id: ID! @unique
  roles: [String!]!
}

type Family {
  id: ID! @id @unique
  members: [Person!]! @relationship(type: "MEMBER_OF", direction: IN)
  creator: User! @relationship(type: "CREATOR_OF", direction: IN)
}

type Person @authorization(filter: [{where: {AND: [{node: {creator: {id: "$jwt.uid"}}}, {node: {family: {creator: {roles_INCLUDES: "plan:paid"}}}}]}}]) {
  id: ID! @id @unique
  creator: User! @relationship(type: "CREATOR_OF", direction: IN, nestedOperations: [CONNECT])
  family: Family! @relationship(type: "MEMBER_OF", direction: OUT)
}

type JWT @jwt {
  roles: [String!]!
}

extend schema @authentication {
  query: Query
  mutation: Mutation
}
----

== should generate valid cypher on nested aggregation with combined rules

.GraphQL-Query
[source,graphql]
----
query Family {
  families {
    id
    membersAggregate {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated" : true,
  "jwt" : {
    "roles" : [ "admin" ],
    "sub" : "michel"
  },
  "param0" : "plan:paid"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Family)
CALL {
	WITH this
	MATCH (this)<-[this0:MEMBER_OF]-(this1:Person)
	OPTIONAL MATCH (this1)<-[:CREATOR_OF]-(this2:User)
	WITH *, count(this2) AS creatorCount
	CALL {
		WITH this1
		MATCH (this1)-[:MEMBER_OF]->(this3:Family)
		OPTIONAL MATCH (this3)<-[:CREATOR_OF]-(this4:User)
		WITH *, count(this4) AS creatorCount
		WITH *
		WHERE (creatorCount <> 0
			AND $param0 IS NOT NULL
			AND $param0 IN this4.roles)
		RETURN count(this3) = 1 AS var5
	}
	WITH *
	WHERE ($isAuthenticated = true
		AND creatorCount <> 0
		AND $jwt.uid IS NOT NULL
		AND this2.id = $jwt.uid
		AND var5 = true)
	RETURN count(this1) AS var6
}
RETURN this {
	.id,
	membersAggregate: {
		count: var6
	}
} AS this
----

'''

