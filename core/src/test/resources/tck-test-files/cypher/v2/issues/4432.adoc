:toc:
:toclevels: 42

= https://github.com/neo4j/graphql/issues/4532

== connections to interfaces with sort

.Schema
[source,graphql,schema=true]
----
type Inventory {
  id: ID
  children: [Scenario!]! @relationship(type: "HasChildren", properties: "InventoryChildRelation", direction: OUT)
}

interface Scenario {
  id: ID
}

type Image implements Scenario {
  id: ID
}

type Video implements Scenario {
  id: ID
}

type InventoryChildRelation @relationshipProperties {
  order: Int
}
----

.GraphQL-Query
[source,graphql]
----
{
  inventories {
    id
    childrenConnection(sort: {edge: {order: ASC}}) {
      edges {
        properties {
          order
        }
        node {
          id
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Inventory)
CALL {
	WITH this
	CALL {
		WITH this
		MATCH (this)-[haschildren0:HasChildren]->(image0:Image)
		WITH {
			properties: {
				__typename: 'InventoryChildRelation',
				order: haschildren0.order
			},
			node: {
				__typename: 'Image',
				id: image0.id,
				__id: elementId(image0)
			}
		} AS edge
		RETURN edge UNION
		WITH this
		MATCH (this)-[haschildren1:HasChildren]->(video0:Video)
		WITH {
			properties: {
				__typename: 'InventoryChildRelation',
				order: haschildren1.order
			},
			node: {
				__typename: 'Video',
				id: video0.id,
				__id: elementId(video0)
			}
		} AS edge
		RETURN edge
	}
	WITH collect(edge) AS edges
	WITH edges, size(edges) AS totalCount
	CALL {
		WITH edges
		UNWIND edges AS edge
		WITH edge ORDER BY edge.properties.order ASC
		RETURN collect(edge) AS sortedEdges0
	}
	RETURN {
		edges: sortedEdges0,
		totalCount: totalCount
	} AS childrenConnection
}
RETURN this {
	.id,
	childrenConnection: childrenConnection
} AS this
----

'''

