:toc:

= #582

== Source schema

[source,graphql,schema=true]
----
type Entity {
  children: [Entity!]! @relationship(type: "EDGE", properties: "Edge", direction: OUT)
  parents: [Entity!]! @relationship(type: "EDGE", properties: "Edge", direction: IN)
  type: String!
}

interface Edge @relationshipProperties {
  type: String!
}
----
== should be able to nest connection where inputs

.GraphQL-Query
[source,graphql]
----
query ($where: EntityWhere) {
  entities(where: $where) {
    type
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "type": "Cat",
    "childrenConnection": {
      "node": {
        "type": "Dog",
        "parentsConnection": {
          "node": {
            "type": "Bird"
          }
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "Cat",
  "param1" : "Dog",
  "param2" : "Bird"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Entity)
WHERE (this.type = $param0
	AND EXISTS {
		MATCH (this)-[this0:EDGE]->(this1:Entity)
		WHERE (this1.type = $param1
			AND EXISTS {
				MATCH (this1)<-[this2:EDGE]-(this3:Entity)
				WHERE this3.type = $param2
			})
	})
RETURN this {
	.type
} AS this
----

'''

== should be able to nest connection where inputs down more levels

.GraphQL-Query
[source,graphql]
----
query ($where: EntityWhere) {
  entities(where: $where) {
    type
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "type": "Cat",
    "childrenConnection": {
      "node": {
        "type": "Dog",
        "parentsConnection": {
          "node": {
            "type": "Bird",
            "childrenConnection": {
              "node": {
                "type": "Fish"
              }
            }
          }
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "Cat",
  "param1" : "Dog",
  "param2" : "Bird",
  "param3" : "Fish"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Entity)
WHERE (this.type = $param0
	AND EXISTS {
		MATCH (this)-[this0:EDGE]->(this1:Entity)
		WHERE (this1.type = $param1
			AND EXISTS {
				MATCH (this1)<-[this2:EDGE]-(this3:Entity)
				WHERE (this3.type = $param2
					AND EXISTS {
						MATCH (this3)-[this4:EDGE]->(this5:Entity)
						WHERE this5.type = $param3
					})
			})
	})
RETURN this {
	.type
} AS this
----

'''

