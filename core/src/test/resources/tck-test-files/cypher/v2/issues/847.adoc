:toc:

= https://github.com/neo4j/graphql/issues/847

== Source schema

[source,graphql,schema=true]
----
interface Entity {
  id: String!
}

type Person implements Entity {
  id: String! @unique
  name: String!
}

type Place implements Entity {
  id: String! @unique
  location: Point!
}

type Interaction {
  id: ID! @id @unique
  kind: String!
  subjects: [Entity!]! @relationship(type: "ACTED_IN", direction: IN)
  objects: [Entity!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----
== should be able to query multiple interface relations

.GraphQL-Query
[source,graphql]
----
{
  interactions {
    id
    subjects {
      id
    }
    objects {
      id
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Interaction)
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)<-[this0:ACTED_IN]-(this1:Person)
        WITH this1 { .id, __resolveType: "Person", __id: id(this1) } AS this1
        RETURN this1 AS var2
        UNION
        WITH *
        MATCH (this)<-[this3:ACTED_IN]-(this4:Place)
        WITH this4 { .id, __resolveType: "Place", __id: id(this4) } AS this4
        RETURN this4 AS var2
    }
    WITH var2
    RETURN collect(var2) AS var2
}
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this5:ACTED_IN]->(this6:Person)
        WITH this6 { .id, __resolveType: "Person", __id: id(this6) } AS this6
        RETURN this6 AS var7
        UNION
        WITH *
        MATCH (this)-[this8:ACTED_IN]->(this9:Place)
        WITH this9 { .id, __resolveType: "Place", __id: id(this9) } AS this9
        RETURN this9 AS var7
    }
    WITH var7
    RETURN collect(var7) AS var7
}
RETURN this { .id, subjects: var2, objects: var7 } AS this
----

'''

