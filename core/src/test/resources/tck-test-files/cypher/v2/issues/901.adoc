:toc:

= https://github.com/neo4j/graphql/issues/901

== Source schema

[source,graphql,schema=true]
----
type Series {
  id: ID! @id @unique
  name: String!
  brand: Series @relationship(type: "HAS_BRAND", direction: OUT, properties: "Properties")
  manufacturer: Series @relationship(type: "HAS_MANUFACTURER", direction: OUT, properties: "Properties")
}

interface Properties @relationshipProperties {
  current: Boolean
}
----
== conjuctions

.GraphQL-Query
[source,graphql]
----
query ($where: SeriesWhere) {
  series(where: $where) {
    name
    brand {
      name
    }
    manufacturer {
      name
    }
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "where": {
    "OR": [
      {
        "manufacturerConnection": {
          "edge": {
            "current": true
          },
          "node": {
            "name": "abc"
          }
        }
      },
      {
        "brandConnection": {
          "edge": {
            "current": true
          },
          "node": {
            "name": "smart"
          }
        }
      }
    ]
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "abc",
  "param1" : true,
  "param2" : "smart",
  "param3" : true
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Series)
WHERE (single(this0 IN [(this)-[this1:HAS_MANUFACTURER]->(this0)
	WHERE (this0.name = $param0
		AND this1.current = $param1) | 1]
	WHERE true)
	OR single(this2 IN [(this)-[this3:HAS_BRAND]->(this2)
	WHERE (this2.name = $param2
		AND this3.current = $param3) | 1]
	WHERE true))
CALL {
	WITH this
	MATCH (this)-[this4:HAS_BRAND]->(this5:Series)
	WITH this5 {
		.name
	} AS this5
	RETURN head(collect(this5)) AS var6
}
CALL {
	WITH this
	MATCH (this)-[this7:HAS_MANUFACTURER]->(this8:Series)
	WITH this8 {
		.name
	} AS this8
	RETURN head(collect(this8)) AS var9
}
RETURN this {
	.name,
	brand: var6,
	manufacturer: var9
} AS this
----

'''

