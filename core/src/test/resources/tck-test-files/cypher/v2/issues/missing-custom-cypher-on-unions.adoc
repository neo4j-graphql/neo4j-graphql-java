:toc:

= Missing custom Cypher on unions

== Source schema

[source,graphql,schema=true]
----
type Fragment @node(labels: ["Fragment", "$context.tenant", "Resource"]) @mutation(operations: []) @limit(default: 100, max: 1000) {
  iri: ID! @id @alias(property: "uri")
}

union hierarchicalNodeTarget = HierarchicalRoot | HierarchicalComponent | Expression | Work | Fragment

type HierarchicalRoot @node(labels: ["HierarchicalRoot", "Resource"]) @mutation(operations: []) @limit(default: 100, max: 300) {
  iri: ID! @id @alias(property: "uri")
}

type Expression @node(labels: ["Expression", "$context.tenant", "Resource"]) @mutation(operations: []) @limit(default: 100, max: 300) {
  iri: ID! @id @alias(property: "uri")
}

type Work @node(labels: ["Work", "$context.tenant", "Resource"]) @mutation(operations: []) @limit(default: 100, max: 300) {
  iri: ID! @id @alias(property: "uri")
}

type HierarchicalComponent @node(labels: ["HierarchicalComponent", "Resource"]) @mutation(operations: []) @limit(default: 100, max: 300) {
  iri: ID! @id @alias(property: "uri")
  relatesToChild: [hierarchicalNodeTarget!]! @relationship(type: "relatesToChild", properties: "RelateProps", direction: OUT)
  isContained: HierarchicalRoot! @relationship(type: "isContained", properties: "RelateProps", direction: OUT)
  hierarchicalPathNodes: [choNode] @cypher(statement: """
  MATCH p=(this)<-[:relatesToChild*..10]-(parent:HierarchicalRoot)
  WITH p, parent
  OPTIONAL MATCH (parent) - [:type] -> (parentType)
  WITH p, parent, parentType
  UNWIND nodes(p) as pathNode
  WITH pathNode, relationships(p) as rels, parent, parentType
  WITH pathNode, head([r in rels where endNode(r) = pathNode]) as relation, parent, parentType
  OPTIONAL MATCH (pathNode) - [:identifier] -> (pathNodeIdentifier)
  OPTIONAL MATCH (pathNode) - [:title] -> (pathNodeTitle)
  WITH pathNode, relation, parent, parentType, pathNodeIdentifier, collect({value: pathNodeTitle.value, language: pathNodeTitle.language}) as pathNodeTitles
  WITH {
  uri: pathNode.uri,
  identifier: pathNodeIdentifier.value,
  title: pathNodeTitles,
  hasSortKey: relation.hasSortKey,
  labels: labels(pathNode),
  partOf: parent.uri,
  partOfType: parentType.uri
  } AS obj
  RETURN DISTINCT obj as result
  """, columnName: "result")
}

type choNode @mutation(operations: []) {
  iri: ID! @id @alias(property: "uri")
  identifier: String
  title: [title]
  hasSortKey: String
  labels: [String]
  partOf: ID
  partOfType: String
}

type title @mutation(operations: []) {
  value: String
  language: String
}

union relatesToChildTarget = Expression | Work | Fragment | HierarchicalRoot

type RelateProps @relationshipProperties {
  hasSortKey: String
  isIdentifiedBy: ID
}
----
== should include checks for auth jwt param is not null

.GraphQL-Query
[source,graphql]
----
query browseHierarchicalComponents($hierarchicalRootId: ID!, $choNodeIris: [ID!]!) {
  hierarchicalComponents(
    where: {isContained: {iri: $hierarchicalRootId}, iri_IN: $choNodeIris}
  ) {
    relatesToChild {
      ...hierarchicalComponentFields
    }
  }
}

fragment hierarchicalComponentFields on HierarchicalComponent {
  hierarchicalPathNodes {
    iri
    hasSortKey
  }
}
----

.GraphQL params input
[source,json,request=true]
----
{
  "hierarchicalRootId": "aaa:bbb::cc::dd/111-111-111",
  "choNodeIris": [
    "aaa:bbb::cc::dd/222-22-22"
  ]
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": [
    "aaa:bbb::cc::dd/222-22-22"
  ],
  "param1": "aaa:bbb::cc::dd/111-111-111",
  "param2": 100
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:HierarchicalComponent:Resource)
OPTIONAL MATCH (this)-[:isContained]->(this0:HierarchicalRoot:Resource)
WITH *, count(this0) AS isContainedCount
WITH *
WHERE (this.uri IN $param0 AND (isContainedCount <> 0 AND this0.uri = $param1))
WITH *

LIMIT $param2
CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this1:relatesToChild]->(this2:Expression:MyTenant:Resource)
        WITH this2 { __resolveType: "Expression", __id: id(this2) } AS this2
        RETURN this2 AS var3
        UNION
        WITH *
        MATCH (this)-[this4:relatesToChild]->(this5:Fragment:MyTenant:Resource)
        WITH this5 { __resolveType: "Fragment", __id: id(this5) } AS this5
        RETURN this5 AS var3
        UNION
        WITH *
        MATCH (this)-[this6:relatesToChild]->(this7:HierarchicalComponent:Resource)
        CALL {
            WITH this7
            CALL {
                WITH this7
                WITH this7 AS this
                MATCH p=(this)<-[:relatesToChild*..10]-(parent:HierarchicalRoot)
                WITH p, parent
                OPTIONAL MATCH (parent) - [:type] -> (parentType)
                WITH p, parent, parentType
                UNWIND nodes(p) as pathNode
                WITH pathNode, relationships(p) as rels, parent, parentType
                WITH pathNode, head([r in rels where endNode(r) = pathNode]) as relation, parent, parentType
                OPTIONAL MATCH (pathNode) - [:identifier] -> (pathNodeIdentifier)
                OPTIONAL MATCH (pathNode) - [:title] -> (pathNodeTitle)
                WITH pathNode, relation, parent, parentType, pathNodeIdentifier, collect({value: pathNodeTitle.value, language: pathNodeTitle.language}) as pathNodeTitles
                WITH {
                uri: pathNode.uri,
                identifier: pathNodeIdentifier.value,
                title: pathNodeTitles,
                hasSortKey: relation.hasSortKey,
                labels: labels(pathNode),
                partOf: parent.uri,
                partOfType: parentType.uri
                } AS obj
                RETURN DISTINCT obj as result
            }
            WITH result AS this8
            WITH this8 { .hasSortKey, iri: this8.uri } AS this8
            RETURN collect(this8) AS var9
        }
        WITH this7 { hierarchicalPathNodes: var9, __resolveType: "HierarchicalComponent", __id: id(this7) } AS this7
        RETURN this7 AS var3
        UNION
        WITH *
        MATCH (this)-[this10:relatesToChild]->(this11:HierarchicalRoot:Resource)
        WITH this11 { __resolveType: "HierarchicalRoot", __id: id(this11) } AS this11
        RETURN this11 AS var3
        UNION
        WITH *
        MATCH (this)-[this12:relatesToChild]->(this13:Work:MyTenant:Resource)
        WITH this13 { __resolveType: "Work", __id: id(this13) } AS this13
        RETURN this13 AS var3
    }
    WITH var3
    RETURN collect(var3) AS var3
}
RETURN this { relatesToChild: var3 } AS this
----

'''

