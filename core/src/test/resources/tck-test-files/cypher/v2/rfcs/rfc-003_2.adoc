:toc:

= create

== Source schema

[source,graphql,schema=true]
----
type Address {
  street: String!
}

type Director {
  id: ID!
  address: Address @relationship(type: "HAS_ADDRESS", direction: OUT)
}

type Movie {
  id: ID!
  director: Director @relationship(type: "DIRECTED", direction: IN)
}
----
== nested mutations

=== should add length validation when creating a node with a non required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  createMovies(
    input: [{id: "movieId-2", director: {create: {node: {id: "directorId-2"}}}}]
  ) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "create_param0": [
    {
      "id": "movieId-2",
      "director": {
        "create": {
          "node": {
            "id": "directorId-2"
          }
        }
      }
    }
  ]
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var0
CALL {
    WITH create_var0
    CREATE (create_this1:Movie)
    SET
        create_this1.id = create_var0.id
    WITH create_this1, create_var0
    CALL {
        WITH create_this1, create_var0
        UNWIND create_var0.director.create AS create_var2
        WITH create_var2.node AS create_var3, create_var2.edge AS create_var4, create_this1
        CREATE (create_this5:Director)
        SET
            create_this5.id = create_var3.id
        MERGE (create_this1)<-[create_this6:DIRECTED]-(create_this5)
        WITH create_this5
        CALL {
        	WITH create_this5
        	MATCH (create_this5)-[create_this5_address_Address_unique:HAS_ADDRESS]->(:Address)
        	WITH count(create_this5_address_Address_unique) as c
        	WHERE apoc.util.validatePredicate(NOT (c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDDirector.address must be less than or equal to one', [0])
        	RETURN c AS create_this5_address_Address_unique_ignored
        }
        RETURN collect(NULL) AS create_var7
    }
    WITH create_this1
    CALL {
    	WITH create_this1
    	MATCH (create_this1)<-[create_this1_director_Director_unique:DIRECTED]-(:Director)
    	WITH count(create_this1_director_Director_unique) as c
    	WHERE apoc.util.validatePredicate(NOT (c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director must be less than or equal to one', [0])
    	RETURN c AS create_this1_director_Director_unique_ignored
    }
    RETURN create_this1
}
RETURN "Query cannot conclude with CALL"
----

'''


== update

=== nested mutations

==== should add length validation when updating a nested node with a non required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {id: "movieId-4"}
    update: {director: {update: {node: {id: "directorId-3"}}}}
  ) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "movieId-4",
  "this_update_director0_id": "directorId-3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0


WITH this
CALL {
	WITH this
	MATCH (this)<-[this_directed0_relationship:DIRECTED]-(this_director0:Director)
	
	
	SET this_director0.id = $this_update_director0_id
	
	WITH this, this_director0
	CALL {
		WITH this_director0
		MATCH (this_director0)-[this_director0_address_Address_unique:HAS_ADDRESS]->(:Address)
		WITH count(this_director0_address_Address_unique) as c
		WHERE apoc.util.validatePredicate(NOT (c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDDirector.address must be less than or equal to one', [0])
		RETURN c AS this_director0_address_Address_unique_ignored
	}
	RETURN count(*) AS update_this_director0
}

WITH *
CALL {
	WITH this
	MATCH (this)<-[this_director_Director_unique:DIRECTED]-(:Director)
	WITH count(this_director_Director_unique) as c
	WHERE apoc.util.validatePredicate(NOT (c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director must be less than or equal to one', [0])
	RETURN c AS this_director_Director_unique_ignored
}
RETURN 'Query cannot conclude with CALL'
----

'''



