:toc:

= create

== Source schema

[source,graphql,schema=true]
----
type Director {
  id: ID!
}

type Movie {
  id: ID!
  director: Director! @relationship(type: "DIRECTED", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== should add validation when creating node with a required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  createMovies(input: [{id: "movieId-1"}]) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "create_param0" : [ {
    "id" : "movieId-1"
  } ]
}
----

.Expected Cypher output
[source,cypher]
----
UNWIND $create_param0 AS create_var1
CALL {
	WITH create_var1
	CREATE (create_this0:Movie)
	SET create_this0.id = create_var1.id
	WITH create_this0
	CALL {
		WITH create_this0
		MATCH (create_this0)<-[create_this0_director_Director_unique:DIRECTED]-(:Director)
		WITH count(create_this0_director_Director_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director required exactly once', [0])
		RETURN c AS create_this0_director_Director_unique_ignored
	}
	RETURN create_this0
}
RETURN 'Query cannot conclude with CALL'
----

'''

== connect

=== should add validation when connecting to a required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  createMovies(
    input: [{id: "movieId-4", director: {connect: {where: {node: {id: "directorId-4"}}}}}]
  ) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_director_connect0_node_param0" : "directorId-4",
  "this0_id" : "movieId-4"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
	CREATE (this0:Movie)
	SET this0.id = $this0_id
	WITH this0
	CALL {
		WITH this0
		OPTIONAL MATCH (this0_director_connect0_node:Director)
		WHERE this0_director_connect0_node.id = $this0_director_connect0_node_param0
		CALL {
			WITH *
			WITH collect(this0_director_connect0_node) AS connectedNodes, collect(this0) AS parentNodes
			CALL {
				WITH connectedNodes, parentNodes
				UNWIND parentNodes AS this0
				UNWIND connectedNodes AS this0_director_connect0_node
				MERGE (this0)<-[:DIRECTED]-(this0_director_connect0_node)
				RETURN count(*) AS _
			}
			RETURN count(*) AS _
		}
		WITH this0, this0_director_connect0_node
		RETURN count(*) AS connect_this0_director_connect_Director
	}
	WITH this0
	CALL {
		WITH this0
		MATCH (this0)<-[this0_director_Director_unique:DIRECTED]-(:Director)
		WITH count(this0_director_Director_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director required exactly once', [0])
		RETURN c AS this0_director_Director_unique_ignored
	}
	RETURN this0
}
RETURN 'Query cannot conclude with CALL'
----

'''


== disconnect

=== should add validation when disconnecting from a required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {id: "movieId-5"}
    disconnect: {director: {where: {node: {id: "directorId-5"}}}}
  ) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "movieId-5",
  "updateMovies" : {
    "args" : {
      "disconnect" : {
        "director" : {
          "where" : {
            "node" : {
              "id" : "directorId-5"
            }
          }
        }
      }
    }
  },
  "updateMovies_args_disconnect_director_where_Directorparam0" : "directorId-5"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this)<-[this_disconnect_director0_rel:DIRECTED]-(this_disconnect_director0:Director)
	WHERE this_disconnect_director0.id = $updateMovies_args_disconnect_director_where_Directorparam0
	CALL {
		WITH this_disconnect_director0, this_disconnect_director0_rel, this
		WITH collect(this_disconnect_director0) AS this_disconnect_director0, this_disconnect_director0_rel, this
		UNWIND this_disconnect_director0 AS x DELETE this_disconnect_director0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_director_Director
}
WITH *
WITH *
CALL {
	WITH this
	MATCH (this)<-[this_director_Director_unique:DIRECTED]-(:Director)
	WITH count(this_director_Director_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director required exactly once', [0])
	RETURN c AS this_director_Director_unique_ignored
}
RETURN 'Query cannot conclude with CALL'
----

'''


== reconnect

=== should add validation after disconnecting and connecting with a required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {id: "movieId-6"}
    disconnect: {director: {where: {node: {id: "directorId-6"}}}}
    connect: {director: {where: {node: {id: "directorId2-6"}}}}
  ) {
    movies {
      id
      director {
        id
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "movieId-6",
  "this_connect_director0_node_param0" : "directorId2-6",
  "updateMovies" : {
    "args" : {
      "disconnect" : {
        "director" : {
          "where" : {
            "node" : {
              "id" : "directorId-6"
            }
          }
        }
      }
    }
  },
  "updateMovies_args_disconnect_director_where_Directorparam0" : "directorId-6"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_director0_node:Director)
	WHERE this_connect_director0_node.id = $this_connect_director0_node_param0
	CALL {
		WITH *
		WITH collect(this_connect_director0_node) AS connectedNodes, collect(this) AS parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes AS this
			UNWIND connectedNodes AS this_connect_director0_node
			MERGE (this)<-[:DIRECTED]-(this_connect_director0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
	WITH this, this_connect_director0_node
	RETURN count(*) AS connect_this_connect_director_Director
}
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this)<-[this_disconnect_director0_rel:DIRECTED]-(this_disconnect_director0:Director)
	WHERE this_disconnect_director0.id = $updateMovies_args_disconnect_director_where_Directorparam0
	CALL {
		WITH this_disconnect_director0, this_disconnect_director0_rel, this
		WITH collect(this_disconnect_director0) AS this_disconnect_director0, this_disconnect_director0_rel, this
		UNWIND this_disconnect_director0 AS x DELETE this_disconnect_director0_rel
		RETURN count(*) AS _
	}
	RETURN count(*) AS disconnect_this_disconnect_director_Director
}
WITH *
CALL {
	WITH this
	MATCH (this_director:Director)-[update_this0:DIRECTED]->(this)
	WITH this_director {
		.id
	} AS this_director
	RETURN head(collect(this_director)) AS this_director
}
WITH *
CALL {
	WITH this
	MATCH (this)<-[this_director_Director_unique:DIRECTED]-(:Director)
	WITH count(this_director_Director_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director required exactly once', [0])
	RETURN c AS this_director_Director_unique_ignored
}
RETURN collect(DISTINCT this {
	.id,
	director: this_director
}) AS data
----

'''


== update

=== should add validation when updating a node with a required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(where: {id: "movieId-3"}, update: {id: "movieId-3"}) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "movieId-3",
  "this_update_id" : "movieId-3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0
SET this.id = $this_update_id
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_director_Director_unique:DIRECTED]-(:Director)
	WITH count(this_director_Director_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director required exactly once', [0])
	RETURN c AS this_director_Director_unique_ignored
}
RETURN 'Query cannot conclude with CALL'
----

'''


