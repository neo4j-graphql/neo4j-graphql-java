:toc:

= nested mutations

== Source schema

[source,graphql,schema=true]
----
type Address {
  id: ID!
}

type Director {
  id: ID!
  address: Address! @relationship(type: "HAS_ADDRESS", direction: OUT)
}

type CoDirector {
  id: ID!
}

type Movie {
  id: ID!
  director: Director! @relationship(type: "DIRECTED", direction: IN)
  coDirector: CoDirector @relationship(type: "CO_DIRECTED", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== should add validation when deleting a required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {id: "movieId-4"}
    delete: {director: {where: {node: {id: "directorId-3"}}, delete: {address: {where: {node: {id: "some-address"}}}}}}
  ) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "movieId-4",
  "updateMovies" : {
    "args" : {
      "delete" : {
        "director" : {
          "where" : {
            "node" : {
              "id" : "directorId-3"
            }
          },
          "delete" : {
            "address" : {
              "where" : {
                "node" : {
                  "id" : "some-address"
                }
              }
            }
          }
        }
      }
    }
  },
  "updateMovies_args_delete_director_delete_address_where_Addressparam0" : "some-address",
  "updateMovies_args_delete_director_where_Directorparam0" : "directorId-3"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $param0
WITH this
OPTIONAL MATCH (this)<-[this_delete_director0_relationship:DIRECTED]-(this_delete_director0:Director)
WHERE this_delete_director0.id = $updateMovies_args_delete_director_where_Directorparam0
WITH this, this_delete_director0
OPTIONAL MATCH (this_delete_director0)-[this_delete_director0_address0_relationship:HAS_ADDRESS]->(this_delete_director0_address0:Address)
WHERE this_delete_director0_address0.id = $updateMovies_args_delete_director_delete_address_where_Addressparam0
WITH this, this_delete_director0, collect(DISTINCT this_delete_director0_address0) AS this_delete_director0_address0_to_delete
CALL {
	WITH this_delete_director0_address0_to_delete
	UNWIND this_delete_director0_address0_to_delete AS x DETACH DELETE x
	RETURN count(*) AS _
}
WITH this, collect(DISTINCT this_delete_director0) AS this_delete_director0_to_delete
CALL {
	WITH this_delete_director0_to_delete
	UNWIND this_delete_director0_to_delete AS x DETACH DELETE x
	RETURN count(*) AS _
}
WITH *
WITH *
CALL {
	WITH this
	MATCH (this)<-[this_director_Director_unique:DIRECTED]-(:Director)
	WITH count(this_director_Director_unique) AS c CALL apoc.util.validate(NOT (c = 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director required exactly once', [0])
	RETURN c AS this_director_Director_unique_ignored
}
CALL {
	WITH this
	MATCH (this)<-[this_coDirector_CoDirector_unique:CO_DIRECTED]-(:CoDirector)
	WITH count(this_coDirector_CoDirector_unique) AS c CALL apoc.util.validate(NOT (c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.coDirector must be less than or equal to one', [0])
	RETURN c AS this_coDirector_CoDirector_unique_ignored
}
RETURN 'Query cannot conclude with CALL'
----

'''

