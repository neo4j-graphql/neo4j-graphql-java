:toc:

= With auth

== Source schema

[source,graphql,schema=true]
----
type JWT @jwt {
  roles: [String!]!
}

type Movie {
  title: String!
  released: Int
  actors: [Person!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}

type Person @authorization(filter: [{where: {node: {name: "The Matrix"}}}], validate: [{when: [BEFORE], where: {node: {name: "$jwt.test"}, jwt: {roles_INCLUDES: "admin"}}}]) {
  name: String!
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}

interface ActedIn @relationshipProperties {
  year: Int
}
----
== Nested query

.GraphQL-Query
[source,graphql]
----
query Query {
  movies(where: {released: 1999}) {
    title
    actors(where: {name: "Keanu Reeves"}) {
      name
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "isAuthenticated" : true,
  "jwt" : {
    "roles" : [ ],
    "test" : "my-test"
  },
  "param0" : 1999,
  "param1" : "Keanu Reeves",
  "param3" : "The Matrix",
  "param5" : "admin"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.released = $param0
CALL {
	WITH this
	MATCH (this)<-[this0:ACTED_IN]-(this1:Person)
	WITH *
	WHERE (this1.name = $param1
		AND $isAuthenticated = true
		AND $param3 IS NOT NULL
		AND this1.name = $param3
		AND apoc.util.validatePredicate(NOT (($isAuthenticated = true
			AND $jwt.test IS NOT NULL
			AND this1.name = $jwt.test
			AND $jwt.roles IS NOT NULL
			AND $param5 IN $jwt.roles)), '@neo4j/graphql/FORBIDDEN', [0]))
	WITH this1 {
		.name
	} AS this1
	RETURN collect(this1) AS var2
}
RETURN this {
	.title,
	actors: var2
} AS this
----

'''

