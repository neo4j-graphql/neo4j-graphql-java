:toc:

= Root Connection Query tests

== Source schema

[source,graphql,schema=true]
----
type Movie {
  id: ID
  title: String
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
}

type Actor {
  name: String
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----
== should apply limit and sort before return

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(first: 20, sort: [{title: ASC}]) {
    edges {
      node {
        title
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 20
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    WITH *
    ORDER BY this0.title ASC
    LIMIT $param0
    RETURN collect({ node: { title: this0.title } }) AS var1
}
RETURN { edges: var1, totalCount: totalCount } AS this
----

'''

== should apply limit, sort, and filter correctly when all three are used

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(
    first: 20
    where: {title_CONTAINS: "Matrix"}
    sort: [{title: ASC}]
  ) {
    edges {
      node {
        title
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Matrix",
  "param1": 20
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WHERE this0.title CONTAINS $param0
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    WITH *
    ORDER BY this0.title ASC
    LIMIT $param1
    RETURN collect({ node: { title: this0.title } }) AS var1
}
RETURN { edges: var1, totalCount: totalCount } AS this
----

'''

== should correctly place any connection strings

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(first: 20, sort: [{title: ASC}]) {
    edges {
      node {
        title
        actorsConnection {
          totalCount
          edges {
            node {
              name
            }
          }
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": 20
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    WITH *
    ORDER BY this0.title ASC
    LIMIT $param0
    CALL {
        WITH this0
        MATCH (this0)<-[this1:ACTED_IN]-(this2:Actor)
        WITH collect({ node: this2, relationship: this1 }) AS edges
        WITH edges, size(edges) AS totalCount
        CALL {
            WITH edges
            UNWIND edges AS edge
            WITH edge.node AS this2, edge.relationship AS this1
            RETURN collect({ node: { name: this2.name } }) AS var3
        }
        RETURN { edges: var3, totalCount: totalCount } AS var4
    }
    RETURN collect({ node: { title: this0.title, actorsConnection: var4 } }) AS var5
}
RETURN { edges: var5, totalCount: totalCount } AS this
----

'''

== Simple selection, Movie by title

.GraphQL-Query
[source,graphql]
----
{
  moviesConnection(where: {title: "River Runs Through It, A"}) {
    totalCount
    edges {
      node {
        title
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "River Runs Through It, A"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this0:Movie)
WHERE this0.title = $param0
WITH collect({ node: this0 }) AS edges
WITH edges, size(edges) AS totalCount
CALL {
    WITH edges
    UNWIND edges AS edge
    WITH edge.node AS this0
    RETURN collect({ node: { title: this0.title } }) AS var1
}
RETURN { edges: var1, totalCount: totalCount } AS this
----

'''

