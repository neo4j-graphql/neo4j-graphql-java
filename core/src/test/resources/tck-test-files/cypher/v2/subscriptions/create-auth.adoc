:toc:

= Subscriptions metadata on create

== Source schema

[source,graphql,schema=true]
----
type Actor {
  id: String!
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
  id: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
}

extend type Actor @auth(rules: [{bind: {id: "$jwt.sub"}}])
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Multi Create

.GraphQL-Query
[source,graphql]
----
mutation {
  createActors(input: [{id: "1"}, {id: "2"}]) {
    actors {
      id
    }
  }
}
----

.Query Context
[source,json,query-config=true]
----
{
  "contextParams": {
    "jwt": {
      "sub": "super_admin"
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "resolvedCallbacks" : { },
  "this0_id" : "1",
  "this0auth_param0" : "super_admin",
  "this1_id" : "2",
  "this1auth_param0" : "super_admin"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
	WITH [] AS meta
	CREATE (this0:Actor)
	SET this0.id = $this0_id
	WITH (meta + {
		event: 'create',
		id: id(this0),
		properties: {
			old: NULL,
			new: this0 {
				.*
			}
		},
		timestamp: timestamp(),
		typename: 'Actor'
	}) AS meta, this0
	WITH this0, meta
	CALL apoc.util.validate(NOT ((this0.id IS NOT NULL
		AND this0.id = $this0auth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
	RETURN this0, meta AS this0_meta
}
CALL {
	WITH [] AS meta
	CREATE (this1:Actor)
	SET this1.id = $this1_id
	WITH (meta + {
		event: 'create',
		id: id(this1),
		properties: {
			old: NULL,
			new: this1 {
				.*
			}
		},
		timestamp: timestamp(),
		typename: 'Actor'
	}) AS meta, this1
	WITH this1, meta
	CALL apoc.util.validate(NOT ((this1.id IS NOT NULL
		AND this1.id = $this1auth_param0)), '@neo4j/graphql/FORBIDDEN', [0])
	RETURN this1, meta AS this1_meta
}
WITH this0, this1, (this0_meta + this1_meta) AS meta
RETURN [this0 {
	.id
}, this1 {
	.id
}] AS data, meta
----

'''

