:toc:

= Subscriptions metadata on update

== Source schema

[source,graphql,schema=true]
----
type Actor {
  name: String!
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
  id: ID!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
}
----
== Nested update with subscriptions

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {id: "1"}
    update: {id: "2", actors: [{where: {node: {name: "arthur"}}, update: {node: {name: "ford"}}}]}
  ) {
    movies {
      id
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "1",
  "this_update_id": "2",
  "updateMovies_args_update_actors0_where_this_actors0param0": "arthur",
  "this_update_actors0_name": "ford",
  "updateMovies": {
    "args": {
      "update": {
        "id": "2",
        "actors": [
          {
            "where": {
              "node": {
                "name": "arthur"
              }
            },
            "update": {
              "node": {
                "name": "ford"
              }
            }
          }
        ]
      }
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
WITH [] AS meta
MATCH (this:Movie)
WHERE this.id = $param0


WITH this { .* } AS oldProps, this, meta
CALL {
	WITH *
	SET this.id = $this_update_id
	WITH this, meta
CALL {
	WITH this, meta
	MATCH (this)<-[this_acted_in0_relationship:ACTED_IN]-(this_actors0:Actor)
	WHERE this_actors0.name = $updateMovies_args_update_actors0_where_this_actors0param0
	
	
	WITH this_actors0 { .* } AS oldProps, this, meta, this_actors0
	CALL {
		WITH *
		SET this_actors0.name = $this_update_actors0_name
		RETURN meta as update_meta
	}
	WITH *, update_meta as meta
	WITH this, this_actors0, meta + { event: "update", id: id(this_actors0), properties: { old: oldProps, new: this_actors0 { .* } }, timestamp: timestamp(), typename: "Actor" } AS meta
	
	RETURN collect(meta) as update_meta
}
WITH this, REDUCE(m=meta, n IN update_meta | m + n) AS meta
	RETURN meta as update_meta
}
WITH *, update_meta as meta
WITH this, meta + { event: "update", id: id(this), properties: { old: oldProps, new: this { .* } }, timestamp: timestamp(), typename: "Movie" } AS meta

WITH *
UNWIND (CASE meta WHEN [] then [null] else meta end) AS m
RETURN collect(DISTINCT this { .id }) AS data
, 
collect(DISTINCT m) as meta
----

'''

== Simple update with subscriptions

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(where: {id: "1"}, update: {id: "2"}) {
    movies {
      id
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "1",
  "this_update_id": "2"
}
----

.Expected Cypher output
[source,cypher]
----
WITH [] AS meta
MATCH (this:Movie)
WHERE this.id = $param0


WITH this { .* } AS oldProps, this, meta
CALL {
	WITH *
	SET this.id = $this_update_id
	RETURN meta as update_meta
}
WITH *, update_meta as meta
WITH this, meta + { event: "update", id: id(this), properties: { old: oldProps, new: this { .* } }, timestamp: timestamp(), typename: "Movie" } AS meta

WITH *
UNWIND (CASE meta WHEN [] then [null] else meta end) AS m
RETURN collect(DISTINCT this { .id }) AS data
, 
collect(DISTINCT m) as meta
----

'''

