:toc:
:toclevels: 42

= Undirected relationships

== query with directed and undirected relationships

.Schema
[source,graphql,schema=true]
----
type User {
  name: String!
  friends: [User!]! @relationship(type: "FRIENDS_WITH", direction: OUT)
}
----

.GraphQL-Query
[source,graphql]
----
{
  users {
    name
    friends: friends(directed: false) {
      name
    }
    directedFriends: friends {
      name
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	MATCH (this)-[friendsWith0:FRIENDS_WITH]-(user0:User)
	WITH user0 {
		.name
	} AS friends
	RETURN collect(friends) AS friends
}
CALL {
	WITH this
	MATCH (this)-[friendsWith1:FRIENDS_WITH]->(user1:User)
	WITH user1 {
		.name
	} AS directedFriends
	RETURN collect(directedFriends) AS directedFriends
}
RETURN this {
	.name,
	friends: friends,
	directedFriends: directedFriends
} AS this
----

'''

== undirected with unions

.Schema
[source,graphql,schema=true]
----
union Content = Blog | Post

type Blog {
  title: String
  posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}

type Post {
  content: String
}

type User {
  name: String
  content: [Content!]! @relationship(type: "HAS_CONTENT", direction: OUT)
}
----

.GraphQL-Query
[source,graphql]
----
query Users {
  users {
    content(directed: false) {
      ... on Blog {
        title
      }
      ... on Post {
        content
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:User)
CALL {
	WITH this
	CALL {
		WITH *
		MATCH (this)-[hasContent0:HAS_CONTENT]-(blog0:Blog)
		WITH blog0 {
			__typename: 'Blog',
			__id: elementId(blog0),
			.title
		} AS blog0
		RETURN blog0 AS content0 UNION
		WITH *
		MATCH (this)-[hasContent1:HAS_CONTENT]-(post0:Post)
		WITH post0 {
			__typename: 'Post',
			__id: elementId(post0),
			.content
		} AS post0
		RETURN post0 AS content0
	}
	WITH content0
	RETURN collect(content0) AS content0
}
RETURN this {
	content: content0
} AS this
----

'''

== undirected with interfaces

.Schema
[source,graphql,schema=true]
----
interface Production {
  title: String!
  actors: [Actor!]!
}

type Movie implements Production {
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
  runtime: Int!
}

type Series implements Production {
  title: String!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
  episodes: Int!
}

type ActedIn @relationshipProperties {
  role: String!
}

type Actor {
  name: String!
  actedIn: [Production!]! @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}
----

.GraphQL-Query
[source,graphql]
----
query Actors {
  actors {
    actedIn(directed: false) {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{ }
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Actor)
CALL {
	WITH this
	CALL {
		WITH *
		MATCH (this)-[actedIn0:ACTED_IN]-(movie0:Movie)
		WITH movie0 {
			__typename: 'Movie',
			__id: elementId(movie0),
			.title
		} AS movie0
		RETURN movie0 AS actedIn UNION
		WITH *
		MATCH (this)-[actedIn1:ACTED_IN]-(series0:Series)
		WITH series0 {
			__typename: 'Series',
			__id: elementId(series0),
			.title
		} AS series0
		RETURN series0 AS actedIn
	}
	WITH actedIn
	RETURN collect(actedIn) AS actedIn
}
RETURN this {
	actedIn: actedIn
} AS this
----

'''

