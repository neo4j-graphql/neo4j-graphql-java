:toc:

= Schema @ignore directive

Tests that the @ignore directive works as expected.


== Inputs

[source,graphql,schema=true]
----
type User {
    id: ID!
    username: String!
    password: String!
    nickname: String! @ignore
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "queryOptionStyle": "INPUT_TYPE",
  "useWhereFilter": true,
  "pluralizeFields": true
}
----

== Output

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if`'argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @relation(direction: RelationDirection = OUT, from: String = "from", name: String, to: String = "to") on OBJECT | FIELD_DEFINITION

directive @cypher(
    """
     if true, passes the sole responsibility for the nested query result for the field to your Cypher query.
     You will have to provide all data/structure required by client queries.
     Otherwise, we assume if you return object-types that you will return the appropriate nodes from your statement.
    """
    passThrough: Boolean = false,
    " a cypher statement fields or top level queries and mutations. The current node is passed to the statement as `this`"
    statement: String
  ) on FIELD_DEFINITION

directive @property(name: String) on FIELD_DEFINITION

directive @dynamic(prefix: String = "properties.") on FIELD_DEFINITION

directive @ignore on FIELD_DEFINITION

"Marks the field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
  ) on FIELD_DEFINITION | ENUM_VALUE

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

type Mutation {
  createUser(id: ID!, password: String!, username: String!): User!
  "Deletes User and returns the type itself"
  deleteUser(id: ID!): User
  mergeUser(id: ID!, password: String!, username: String!): User!
  updateUser(id: ID!, password: String!, username: String!): User
}

type Query {
  users(options: UserOptions, where: UserWhere): [User!]!
}

type User {
  id: ID!
  nickname: String! @ignore
  password: String!
  username: String!
}

type _Neo4jDate {
  day: Int
  formatted: String
  month: Int
  year: Int
}

type _Neo4jDateTime {
  day: Int
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  month: Int
  nanosecond: Int
  second: Int
  timezone: String
  year: Int
}

type _Neo4jLocalDateTime {
  day: Int
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  month: Int
  nanosecond: Int
  second: Int
  year: Int
}

type _Neo4jLocalTime {
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  nanosecond: Int
  second: Int
}

type _Neo4jPoint {
  """
   The coordinate reference systems (CRS)
   -------------------------------------
   posible values:
   * `wgs-84`: A 2D geographic point in the WGS 84 CRS is specified in one of two ways:
     * longitude and latitude (if these are specified, and the crs is not, then the crs is assumed to be WGS-84)
     * x and y (in this case the crs must be specified, or will be assumed to be Cartesian)
   * `wgs-84-3d`: A 3D geographic point in the WGS 84 CRS is specified one of in two ways:
     * longitude, latitude and either height or z (if these are specified, and the crs is not, then the crs is assumed to be WGS-84-3D)
     * x, y and z (in this case the crs must be specified, or will be assumed to be Cartesian-3D)
   * `cartesian`: A 2D point in the Cartesian CRS is specified with a map containing x and y coordinate values
   * `cartesian-3d`: A 3D point in the Cartesian CRS is specified with a map containing x, y and z coordinate values
  """
  crs: String
  " The third element of the Coordinate for geographic CRS, meters above the ellipsoid defined by the datum (WGS-84)"
  height: Float
  """
   The second element of the Coordinate for geographic CRS, degrees North of the equator
   Range -90.0 to 90.0
  """
  latitude: Float
  """
   The first element of the Coordinate for geographic CRS, degrees East of the prime meridian
   Range -180.0 to 180.0
  """
  longitude: Float
  """
   The internal Neo4j ID for the CRS
   One of:
   * `4326`: represents CRS `wgs-84`
   * `4979`: represents CRS `wgs-84-3d`
   * `7203`: represents CRS `cartesian`
   * `9157`: represents CRS `cartesian-3d`
  """
  srid: Int
  " The first element of the Coordinate"
  x: Float
  " The second element of the Coordinate"
  y: Float
  " The third element of the Coordinate"
  z: Float
}

type _Neo4jTime {
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  nanosecond: Int
  second: Int
  timezone: String
}

enum RelationDirection {
  BOTH
  IN
  OUT
}

enum SortDirection {
  "Sort by field values in ascending order."
  ASC
  "Sort by field values in descending order."
  DESC
}

scalar DynamicProperties

input UserOptions {
  "Defines the maximum amount of records returned"
  limit: Int
  "Defines the amount of records to be skipped"
  skip: Int
  "Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [UserSort!]
}

"Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one MovieSort object."
input UserSort {
  id: SortDirection
  password: SortDirection
  username: SortDirection
}

input UserWhere {
  AND: [UserWhere!]
  NOT: [UserWhere!]
  OR: [UserWhere!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID]
  id_lt: ID
  id_lte: ID
  id_matches: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID]
  id_not_starts_with: ID
  id_starts_with: ID
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String]
  password_lt: String
  password_lte: String
  password_matches: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String]
  password_not_starts_with: String
  password_starts_with: String
  username: String
  username_contains: String
  username_ends_with: String
  username_gt: String
  username_gte: String
  username_in: [String]
  username_lt: String
  username_lte: String
  username_matches: String
  username_not: String
  username_not_contains: String
  username_not_ends_with: String
  username_not_in: [String]
  username_not_starts_with: String
  username_starts_with: String
}

input _Neo4jDateInput {
  day: Int
  formatted: String
  month: Int
  year: Int
}

input _Neo4jDateTimeInput {
  day: Int
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  month: Int
  nanosecond: Int
  second: Int
  timezone: String
  year: Int
}

input _Neo4jLocalDateTimeInput {
  day: Int
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  month: Int
  nanosecond: Int
  second: Int
  year: Int
}

input _Neo4jLocalTimeInput {
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  nanosecond: Int
  second: Int
}

input _Neo4jPointInput {
  crs: String
  height: Float
  latitude: Float
  longitude: Float
  srid: Int
  x: Float
  y: Float
  z: Float
}

input _Neo4jTimeInput {
  formatted: String
  hour: Int
  microsecond: Int
  millisecond: Int
  minute: Int
  nanosecond: Int
  second: Int
  timezone: String
}
----
