:toc:

= Directive-preserve -> Directives on unions preserved

== Source schema

[source,graphql,schema=true]
----
union Content = Blog | Post

type Blog {
  title: String
  posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}

type Post {
  content: String @deprecated(reason: "Do not use post.content")
}

type User {
  name: String
  content: [Content!]! @relationship(type: "HAS_CONTENT", direction: OUT) @deprecated(reason: "Do not use user.content")
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
}

union Content = Blog | Post

type Blog {
  posts(directed: Boolean = true, options: PostOptions, where: PostWhere): [Post!]!
  postsConnection(after: String, directed: Boolean = true, first: Int, sort: [BlogPostsConnectionSort!], where: BlogPostsConnectionWhere): BlogPostsConnection!
  title: String
}

type BlogEdge {
  cursor: String!
  node: Blog!
}

type BlogPostsConnection {
  edges: [BlogPostsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BlogPostsRelationship {
  cursor: String!
  node: Post!
}

type BlogsConnection {
  edges: [BlogEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"Pagination information (Relay)"
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Post {
  content: String @deprecated(reason : "Do not use post.content")
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PostsConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Query {
  blogs(options: BlogOptions, where: BlogWhere): [Blog!]!
  blogsConnection(after: String, first: Int, sort: [BlogSort], where: BlogWhere): BlogsConnection!
  contents(options: QueryOptions, where: ContentWhere): [Content!]!
  posts(options: PostOptions, where: PostWhere): [Post!]!
  postsConnection(after: String, first: Int, sort: [PostSort], where: PostWhere): PostsConnection!
  users(options: UserOptions, where: UserWhere): [User!]!
  usersConnection(after: String, first: Int, sort: [UserSort], where: UserWhere): UsersConnection!
}

type User {
  content(directed: Boolean = true, options: QueryOptions, where: ContentWhere): [Content!]! @deprecated(reason : "Do not use user.content")
  contentConnection(after: String, directed: Boolean = true, first: Int, where: UserContentConnectionWhere): UserContentConnection! @deprecated(reason : "Do not use user.content")
  name: String
}

type UserContentConnection {
  edges: [UserContentRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserContentRelationship {
  cursor: String!
  node: Content!
}

type UserEdge {
  cursor: String!
  node: User!
}

type UsersConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"An enum for sorting in either ascending or descending order."
enum SortDirection {
  "Sort by field values in ascending order."
  ASC
  "Sort by field values in descending order."
  DESC
}

input BlogOptions {
  limit: Int
  offset: Int
  "Specify one or more BlogSort objects to sort Blogs by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [BlogSort!]
}

input BlogPostsConnectionSort {
  node: PostSort
}

input BlogPostsConnectionWhere {
  AND: [BlogPostsConnectionWhere!]
  NOT: BlogPostsConnectionWhere
  OR: [BlogPostsConnectionWhere!]
  node: PostWhere
}

"Fields to sort Blogs by. The order in which sorts are applied is not guaranteed when specifying many fields in one BlogSort object."
input BlogSort {
  title: SortDirection
}

input BlogWhere {
  AND: [BlogWhere!]
  NOT: BlogWhere
  OR: [BlogWhere!]
  "Return Blogs where all of the related BlogPostsConnections match this filter"
  postsConnection_ALL: BlogPostsConnectionWhere
  "Return Blogs where none of the related BlogPostsConnections match this filter"
  postsConnection_NONE: BlogPostsConnectionWhere
  "Return Blogs where one of the related BlogPostsConnections match this filter"
  postsConnection_SINGLE: BlogPostsConnectionWhere
  "Return Blogs where some of the related BlogPostsConnections match this filter"
  postsConnection_SOME: BlogPostsConnectionWhere
  "Return Blogs where all of the related Posts match this filter"
  posts_ALL: PostWhere
  "Return Blogs where none of the related Posts match this filter"
  posts_NONE: PostWhere
  "Return Blogs where one of the related Posts match this filter"
  posts_SINGLE: PostWhere
  "Return Blogs where some of the related Posts match this filter"
  posts_SOME: PostWhere
  title: String
  title_CONTAINS: String
  title_ENDS_WITH: String
  title_IN: [String]
  title_STARTS_WITH: String
}

input ContentWhere {
  Blog: BlogWhere
  Post: PostWhere
}

input PostOptions {
  limit: Int
  offset: Int
  "Specify one or more PostSort objects to sort Posts by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [PostSort!]
}

"Fields to sort Posts by. The order in which sorts are applied is not guaranteed when specifying many fields in one PostSort object."
input PostSort {
  content: SortDirection @deprecated(reason : "Do not use post.content")
}

input PostWhere {
  AND: [PostWhere!]
  NOT: PostWhere
  OR: [PostWhere!]
  content: String @deprecated(reason : "Do not use post.content")
  content_CONTAINS: String @deprecated(reason : "Do not use post.content")
  content_ENDS_WITH: String @deprecated(reason : "Do not use post.content")
  content_IN: [String] @deprecated(reason : "Do not use post.content")
  content_STARTS_WITH: String @deprecated(reason : "Do not use post.content")
}

"Input type for options that can be specified on a query operation."
input QueryOptions {
  limit: Int
  offset: Int
}

input UserContentBlogConnectionWhere {
  AND: [UserContentBlogConnectionWhere!]
  NOT: UserContentBlogConnectionWhere
  OR: [UserContentBlogConnectionWhere!]
  node: BlogWhere
}

input UserContentConnectionWhere {
  Blog: UserContentBlogConnectionWhere
  Post: UserContentPostConnectionWhere
}

input UserContentPostConnectionWhere {
  AND: [UserContentPostConnectionWhere!]
  NOT: UserContentPostConnectionWhere
  OR: [UserContentPostConnectionWhere!]
  node: PostWhere
}

input UserOptions {
  limit: Int
  offset: Int
  "Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [UserSort!]
}

"Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object."
input UserSort {
  name: SortDirection
}

input UserWhere {
  AND: [UserWhere!]
  NOT: UserWhere
  OR: [UserWhere!]
  "Return Users where all of the related UserContentConnections match this filter"
  contentConnection_ALL: UserContentConnectionWhere @deprecated(reason : "Do not use user.content")
  "Return Users where none of the related UserContentConnections match this filter"
  contentConnection_NONE: UserContentConnectionWhere @deprecated(reason : "Do not use user.content")
  "Return Users where one of the related UserContentConnections match this filter"
  contentConnection_SINGLE: UserContentConnectionWhere @deprecated(reason : "Do not use user.content")
  "Return Users where some of the related UserContentConnections match this filter"
  contentConnection_SOME: UserContentConnectionWhere @deprecated(reason : "Do not use user.content")
  "Return Users where all of the related Contents match this filter"
  content_ALL: ContentWhere @deprecated(reason : "Do not use user.content")
  "Return Users where none of the related Contents match this filter"
  content_NONE: ContentWhere @deprecated(reason : "Do not use user.content")
  "Return Users where one of the related Contents match this filter"
  content_SINGLE: ContentWhere @deprecated(reason : "Do not use user.content")
  "Return Users where some of the related Contents match this filter"
  content_SOME: ContentWhere @deprecated(reason : "Do not use user.content")
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_STARTS_WITH: String
}

----

'''
