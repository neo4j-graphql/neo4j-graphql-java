:toc:

= Interface Relationships -> Interface Relationships - nested relationships

== Source schema

[source,graphql,schema=true]
----
interface Content {
  id: ID
  content: String
  creator: User! @declareRelationship
}

type Comment implements Content {
  id: ID
  content: String
  creator: User! @relationship(type: "HAS_CONTENT", direction: IN)
  post: Post! @relationship(type: "HAS_COMMENT", direction: IN)
}

type Post implements Content {
  id: ID
  content: String
  creator: User! @relationship(type: "HAS_CONTENT", direction: IN)
  comments: [Comment!]! @relationship(type: "HAS_COMMENT", direction: OUT)
}

type User {
  id: ID
  name: String
  content: [Content!]! @relationship(type: "HAS_CONTENT", direction: OUT)
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

type Comment implements Content {
  content: String
  creator(directed: Boolean = true, options: UserOptions, where: UserWhere): User!
  creatorAggregate(directed: Boolean = true, where: UserWhere): CommentUserCreatorAggregationSelection
  creatorConnection(after: String, directed: Boolean = true, first: Int, sort: [ContentCreatorConnectionSort!], where: ContentCreatorConnectionWhere): ContentCreatorConnection!
  id: ID
  post(directed: Boolean = true, options: PostOptions, where: PostWhere): Post!
  postAggregate(directed: Boolean = true, where: PostWhere): CommentPostPostAggregationSelection
  postConnection(after: String, directed: Boolean = true, first: Int, sort: [CommentPostConnectionSort!], where: CommentPostConnectionWhere): CommentPostConnection!
}

type CommentAggregateSelection {
  content: StringAggregateSelection!
  count: Int!
  id: IDAggregateSelection!
}

input CommentConnectInput {
  creator: CommentCreatorConnectFieldInput
  post: CommentPostConnectFieldInput
}

input CommentConnectWhere {
  node: CommentWhere!
}

input CommentCreateInput {
  content: String
  creator: CommentCreatorFieldInput
  id: ID
  post: CommentPostFieldInput
}

input CommentCreatorAggregateInput {
  AND: [CommentCreatorAggregateInput!]
  NOT: CommentCreatorAggregateInput
  OR: [CommentCreatorAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: CommentCreatorNodeAggregationWhereInput
}

input CommentCreatorConnectFieldInput {
  connect: UserConnectInput
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: UserConnectWhere
}

input CommentCreatorCreateFieldInput {
  node: UserCreateInput!
}

input CommentCreatorFieldInput {
  connect: CommentCreatorConnectFieldInput
  create: CommentCreatorCreateFieldInput
}

input CommentCreatorNodeAggregationWhereInput {
  AND: [CommentCreatorNodeAggregationWhereInput!]
  NOT: CommentCreatorNodeAggregationWhereInput
  OR: [CommentCreatorNodeAggregationWhereInput!]
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

input CommentCreatorUpdateConnectionInput {
  node: UserUpdateInput
}

input CommentCreatorUpdateFieldInput {
  connect: CommentCreatorConnectFieldInput
  create: CommentCreatorCreateFieldInput
  delete: ContentCreatorDeleteFieldInput
  disconnect: ContentCreatorDisconnectFieldInput
  update: CommentCreatorUpdateConnectionInput
  where: ContentCreatorConnectionWhere
}

input CommentDeleteInput {
  creator: ContentCreatorDeleteFieldInput
  post: CommentPostDeleteFieldInput
}

input CommentDisconnectInput {
  creator: ContentCreatorDisconnectFieldInput
  post: CommentPostDisconnectFieldInput
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentOptions {
  limit: Int
  offset: Int
  """
  Specify one or more CommentSort objects to sort Comments by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [CommentSort!]
}

input CommentPostAggregateInput {
  AND: [CommentPostAggregateInput!]
  NOT: CommentPostAggregateInput
  OR: [CommentPostAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: CommentPostNodeAggregationWhereInput
}

input CommentPostConnectFieldInput {
  connect: PostConnectInput
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: PostConnectWhere
}

type CommentPostConnection {
  edges: [CommentPostRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input CommentPostConnectionSort {
  node: PostSort
}

input CommentPostConnectionWhere {
  AND: [CommentPostConnectionWhere!]
  NOT: CommentPostConnectionWhere
  OR: [CommentPostConnectionWhere!]
  node: PostWhere
}

input CommentPostCreateFieldInput {
  node: PostCreateInput!
}

input CommentPostDeleteFieldInput {
  delete: PostDeleteInput
  where: CommentPostConnectionWhere
}

input CommentPostDisconnectFieldInput {
  disconnect: PostDisconnectInput
  where: CommentPostConnectionWhere
}

input CommentPostFieldInput {
  connect: CommentPostConnectFieldInput
  create: CommentPostCreateFieldInput
}

input CommentPostNodeAggregationWhereInput {
  AND: [CommentPostNodeAggregationWhereInput!]
  NOT: CommentPostNodeAggregationWhereInput
  OR: [CommentPostNodeAggregationWhereInput!]
  content_AVERAGE_LENGTH_EQUAL: Float
  content_AVERAGE_LENGTH_GT: Float
  content_AVERAGE_LENGTH_GTE: Float
  content_AVERAGE_LENGTH_LT: Float
  content_AVERAGE_LENGTH_LTE: Float
  content_LONGEST_LENGTH_EQUAL: Int
  content_LONGEST_LENGTH_GT: Int
  content_LONGEST_LENGTH_GTE: Int
  content_LONGEST_LENGTH_LT: Int
  content_LONGEST_LENGTH_LTE: Int
  content_SHORTEST_LENGTH_EQUAL: Int
  content_SHORTEST_LENGTH_GT: Int
  content_SHORTEST_LENGTH_GTE: Int
  content_SHORTEST_LENGTH_LT: Int
  content_SHORTEST_LENGTH_LTE: Int
}

type CommentPostPostAggregationSelection {
  count: Int!
  node: CommentPostPostNodeAggregateSelection
}

type CommentPostPostNodeAggregateSelection {
  content: StringAggregateSelection!
  id: IDAggregateSelection!
}

type CommentPostRelationship {
  cursor: String!
  node: Post!
}

input CommentPostUpdateConnectionInput {
  node: PostUpdateInput
}

input CommentPostUpdateFieldInput {
  connect: CommentPostConnectFieldInput
  create: CommentPostCreateFieldInput
  delete: CommentPostDeleteFieldInput
  disconnect: CommentPostDisconnectFieldInput
  update: CommentPostUpdateConnectionInput
  where: CommentPostConnectionWhere
}

input CommentRelationInput {
  creator: CommentCreatorCreateFieldInput
  post: CommentPostCreateFieldInput
}

"""
Fields to sort Comments by. The order in which sorts are applied is not guaranteed when specifying many fields in one CommentSort object.
"""
input CommentSort {
  content: SortDirection
  id: SortDirection
}

input CommentUpdateInput {
  content: String
  creator: CommentCreatorUpdateFieldInput
  id: ID
  post: CommentPostUpdateFieldInput
}

type CommentUserCreatorAggregationSelection {
  count: Int!
  node: CommentUserCreatorNodeAggregateSelection
}

type CommentUserCreatorNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input CommentWhere {
  AND: [CommentWhere!]
  NOT: CommentWhere
  OR: [CommentWhere!]
  content: String
  content_CONTAINS: String
  content_ENDS_WITH: String
  content_IN: [String]
  content_STARTS_WITH: String
  creator: UserWhere
  creatorAggregate: CommentCreatorAggregateInput
  creatorConnection: ContentCreatorConnectionWhere
  creatorConnection_NOT: ContentCreatorConnectionWhere
  creator_NOT: UserWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  post: PostWhere
  postAggregate: CommentPostAggregateInput
  postConnection: CommentPostConnectionWhere
  postConnection_NOT: CommentPostConnectionWhere
  post_NOT: PostWhere
}

type CommentsConnection {
  edges: [CommentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

interface Content {
  content: String
  creator(options: UserOptions, where: UserWhere): User!
  creatorConnection(after: String, first: Int, sort: [ContentCreatorConnectionSort!], where: ContentCreatorConnectionWhere): ContentCreatorConnection!
  id: ID
}

type ContentAggregateSelection {
  content: StringAggregateSelection!
  count: Int!
  id: IDAggregateSelection!
}

input ContentConnectInput {
  creator: ContentCreatorConnectFieldInput
}

input ContentConnectWhere {
  node: ContentWhere!
}

input ContentCreateInput {
  Comment: CommentCreateInput
  Post: PostCreateInput
}

input ContentCreatorAggregateInput {
  AND: [ContentCreatorAggregateInput!]
  NOT: ContentCreatorAggregateInput
  OR: [ContentCreatorAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ContentCreatorNodeAggregationWhereInput
}

input ContentCreatorConnectFieldInput {
  connect: UserConnectInput
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: UserConnectWhere
}

type ContentCreatorConnection {
  edges: [ContentCreatorRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ContentCreatorConnectionSort {
  node: UserSort
}

input ContentCreatorConnectionWhere {
  AND: [ContentCreatorConnectionWhere!]
  NOT: ContentCreatorConnectionWhere
  OR: [ContentCreatorConnectionWhere!]
  node: UserWhere
}

input ContentCreatorCreateFieldInput {
  node: UserCreateInput!
}

input ContentCreatorDeleteFieldInput {
  delete: UserDeleteInput
  where: ContentCreatorConnectionWhere
}

input ContentCreatorDisconnectFieldInput {
  disconnect: UserDisconnectInput
  where: ContentCreatorConnectionWhere
}

input ContentCreatorNodeAggregationWhereInput {
  AND: [ContentCreatorNodeAggregationWhereInput!]
  NOT: ContentCreatorNodeAggregationWhereInput
  OR: [ContentCreatorNodeAggregationWhereInput!]
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

type ContentCreatorRelationship {
  cursor: String!
  node: User!
}

input ContentCreatorUpdateConnectionInput {
  node: UserUpdateInput
}

input ContentCreatorUpdateFieldInput {
  connect: ContentCreatorConnectFieldInput
  create: ContentCreatorCreateFieldInput
  delete: ContentCreatorDeleteFieldInput
  disconnect: ContentCreatorDisconnectFieldInput
  update: ContentCreatorUpdateConnectionInput
  where: ContentCreatorConnectionWhere
}

input ContentDeleteInput {
  creator: ContentCreatorDeleteFieldInput
}

input ContentDisconnectInput {
  creator: ContentCreatorDisconnectFieldInput
}

type ContentEdge {
  cursor: String!
  node: Content!
}

enum ContentImplementation {
  Comment
  Post
}

input ContentOptions {
  limit: Int
  offset: Int
  """
  Specify one or more ContentSort objects to sort Contents by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ContentSort]
}

"""
Fields to sort Contents by. The order in which sorts are applied is not guaranteed when specifying many fields in one ContentSort object.
"""
input ContentSort {
  content: SortDirection
  id: SortDirection
}

input ContentUpdateInput {
  content: String
  creator: ContentCreatorUpdateFieldInput
  id: ID
}

input ContentWhere {
  AND: [ContentWhere!]
  NOT: ContentWhere
  OR: [ContentWhere!]
  content: String
  content_CONTAINS: String
  content_ENDS_WITH: String
  content_IN: [String]
  content_STARTS_WITH: String
  creator: UserWhere
  creatorAggregate: ContentCreatorAggregateInput
  creatorConnection: ContentCreatorConnectionWhere
  creatorConnection_NOT: ContentCreatorConnectionWhere
  creator_NOT: UserWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  typename_IN: [ContentImplementation!]
}

type ContentsConnection {
  edges: [ContentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreateCommentsMutationResponse {
  comments: [Comment!]!
  info: CreateInfo!
}

"""
Information about the number of nodes and relationships created during a create mutation
"""
type CreateInfo {
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreatePostsMutationResponse {
  info: CreateInfo!
  posts: [Post!]!
}

type CreateUsersMutationResponse {
  info: CreateInfo!
  users: [User!]!
}

"""
Information about the number of nodes and relationships deleted during a delete mutation
"""
type DeleteInfo {
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type IDAggregateSelection {
  longest: ID
  shortest: ID
}

type Mutation {
  createComments(input: [CommentCreateInput!]!): CreateCommentsMutationResponse!
  createPosts(input: [PostCreateInput!]!): CreatePostsMutationResponse!
  createUsers(input: [UserCreateInput!]!): CreateUsersMutationResponse!
  deleteComments(delete: CommentDeleteInput, where: CommentWhere): DeleteInfo!
  deletePosts(delete: PostDeleteInput, where: PostWhere): DeleteInfo!
  deleteUsers(delete: UserDeleteInput, where: UserWhere): DeleteInfo!
  updateComments(connect: CommentConnectInput, create: CommentRelationInput, delete: CommentDeleteInput, disconnect: CommentDisconnectInput, update: CommentUpdateInput, where: CommentWhere): UpdateCommentsMutationResponse!
  updatePosts(connect: PostConnectInput, create: PostRelationInput, delete: PostDeleteInput, disconnect: PostDisconnectInput, update: PostUpdateInput, where: PostWhere): UpdatePostsMutationResponse!
  updateUsers(connect: UserConnectInput, create: UserRelationInput, delete: UserDeleteInput, disconnect: UserDisconnectInput, update: UserUpdateInput, where: UserWhere): UpdateUsersMutationResponse!
}

"""Pagination information (Relay)"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Post implements Content {
  comments(directed: Boolean = true, options: CommentOptions, where: CommentWhere): [Comment!]!
  commentsAggregate(directed: Boolean = true, where: CommentWhere): PostCommentCommentsAggregationSelection
  commentsConnection(after: String, directed: Boolean = true, first: Int, sort: [PostCommentsConnectionSort!], where: PostCommentsConnectionWhere): PostCommentsConnection!
  content: String
  creator(directed: Boolean = true, options: UserOptions, where: UserWhere): User!
  creatorAggregate(directed: Boolean = true, where: UserWhere): PostUserCreatorAggregationSelection
  creatorConnection(after: String, directed: Boolean = true, first: Int, sort: [ContentCreatorConnectionSort!], where: ContentCreatorConnectionWhere): ContentCreatorConnection!
  id: ID
}

type PostAggregateSelection {
  content: StringAggregateSelection!
  count: Int!
  id: IDAggregateSelection!
}

type PostCommentCommentsAggregationSelection {
  count: Int!
  node: PostCommentCommentsNodeAggregateSelection
}

type PostCommentCommentsNodeAggregateSelection {
  content: StringAggregateSelection!
  id: IDAggregateSelection!
}

input PostCommentsAggregateInput {
  AND: [PostCommentsAggregateInput!]
  NOT: PostCommentsAggregateInput
  OR: [PostCommentsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PostCommentsNodeAggregationWhereInput
}

input PostCommentsConnectFieldInput {
  connect: [CommentConnectInput!]
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: CommentConnectWhere
}

type PostCommentsConnection {
  edges: [PostCommentsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PostCommentsConnectionSort {
  node: CommentSort
}

input PostCommentsConnectionWhere {
  AND: [PostCommentsConnectionWhere!]
  NOT: PostCommentsConnectionWhere
  OR: [PostCommentsConnectionWhere!]
  node: CommentWhere
}

input PostCommentsCreateFieldInput {
  node: CommentCreateInput!
}

input PostCommentsDeleteFieldInput {
  delete: CommentDeleteInput
  where: PostCommentsConnectionWhere
}

input PostCommentsDisconnectFieldInput {
  disconnect: CommentDisconnectInput
  where: PostCommentsConnectionWhere
}

input PostCommentsFieldInput {
  connect: [PostCommentsConnectFieldInput!]
  create: [PostCommentsCreateFieldInput!]
}

input PostCommentsNodeAggregationWhereInput {
  AND: [PostCommentsNodeAggregationWhereInput!]
  NOT: PostCommentsNodeAggregationWhereInput
  OR: [PostCommentsNodeAggregationWhereInput!]
  content_AVERAGE_LENGTH_EQUAL: Float
  content_AVERAGE_LENGTH_GT: Float
  content_AVERAGE_LENGTH_GTE: Float
  content_AVERAGE_LENGTH_LT: Float
  content_AVERAGE_LENGTH_LTE: Float
  content_LONGEST_LENGTH_EQUAL: Int
  content_LONGEST_LENGTH_GT: Int
  content_LONGEST_LENGTH_GTE: Int
  content_LONGEST_LENGTH_LT: Int
  content_LONGEST_LENGTH_LTE: Int
  content_SHORTEST_LENGTH_EQUAL: Int
  content_SHORTEST_LENGTH_GT: Int
  content_SHORTEST_LENGTH_GTE: Int
  content_SHORTEST_LENGTH_LT: Int
  content_SHORTEST_LENGTH_LTE: Int
}

type PostCommentsRelationship {
  cursor: String!
  node: Comment!
}

input PostCommentsUpdateConnectionInput {
  node: CommentUpdateInput
}

input PostCommentsUpdateFieldInput {
  connect: [PostCommentsConnectFieldInput!]
  create: [PostCommentsCreateFieldInput!]
  delete: [PostCommentsDeleteFieldInput!]
  disconnect: [PostCommentsDisconnectFieldInput!]
  update: PostCommentsUpdateConnectionInput
  where: PostCommentsConnectionWhere
}

input PostConnectInput {
  comments: [PostCommentsConnectFieldInput!]
  creator: PostCreatorConnectFieldInput
}

input PostConnectWhere {
  node: PostWhere!
}

input PostCreateInput {
  comments: PostCommentsFieldInput
  content: String
  creator: PostCreatorFieldInput
  id: ID
}

input PostCreatorAggregateInput {
  AND: [PostCreatorAggregateInput!]
  NOT: PostCreatorAggregateInput
  OR: [PostCreatorAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PostCreatorNodeAggregationWhereInput
}

input PostCreatorConnectFieldInput {
  connect: UserConnectInput
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: UserConnectWhere
}

input PostCreatorCreateFieldInput {
  node: UserCreateInput!
}

input PostCreatorFieldInput {
  connect: PostCreatorConnectFieldInput
  create: PostCreatorCreateFieldInput
}

input PostCreatorNodeAggregationWhereInput {
  AND: [PostCreatorNodeAggregationWhereInput!]
  NOT: PostCreatorNodeAggregationWhereInput
  OR: [PostCreatorNodeAggregationWhereInput!]
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

input PostCreatorUpdateConnectionInput {
  node: UserUpdateInput
}

input PostCreatorUpdateFieldInput {
  connect: PostCreatorConnectFieldInput
  create: PostCreatorCreateFieldInput
  delete: ContentCreatorDeleteFieldInput
  disconnect: ContentCreatorDisconnectFieldInput
  update: PostCreatorUpdateConnectionInput
  where: ContentCreatorConnectionWhere
}

input PostDeleteInput {
  comments: [PostCommentsDeleteFieldInput!]
  creator: ContentCreatorDeleteFieldInput
}

input PostDisconnectInput {
  comments: [PostCommentsDisconnectFieldInput!]
  creator: ContentCreatorDisconnectFieldInput
}

type PostEdge {
  cursor: String!
  node: Post!
}

input PostOptions {
  limit: Int
  offset: Int
  """
  Specify one or more PostSort objects to sort Posts by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PostSort!]
}

input PostRelationInput {
  comments: [PostCommentsCreateFieldInput!]
  creator: PostCreatorCreateFieldInput
}

"""
Fields to sort Posts by. The order in which sorts are applied is not guaranteed when specifying many fields in one PostSort object.
"""
input PostSort {
  content: SortDirection
  id: SortDirection
}

input PostUpdateInput {
  comments: [PostCommentsUpdateFieldInput!]
  content: String
  creator: PostCreatorUpdateFieldInput
  id: ID
}

type PostUserCreatorAggregationSelection {
  count: Int!
  node: PostUserCreatorNodeAggregateSelection
}

type PostUserCreatorNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PostWhere {
  AND: [PostWhere!]
  NOT: PostWhere
  OR: [PostWhere!]
  commentsAggregate: PostCommentsAggregateInput
  """
  Return Posts where all of the related PostCommentsConnections match this filter
  """
  commentsConnection_ALL: PostCommentsConnectionWhere
  """
  Return Posts where none of the related PostCommentsConnections match this filter
  """
  commentsConnection_NONE: PostCommentsConnectionWhere
  """
  Return Posts where one of the related PostCommentsConnections match this filter
  """
  commentsConnection_SINGLE: PostCommentsConnectionWhere
  """
  Return Posts where some of the related PostCommentsConnections match this filter
  """
  commentsConnection_SOME: PostCommentsConnectionWhere
  """Return Posts where all of the related Comments match this filter"""
  comments_ALL: CommentWhere
  """Return Posts where none of the related Comments match this filter"""
  comments_NONE: CommentWhere
  """Return Posts where one of the related Comments match this filter"""
  comments_SINGLE: CommentWhere
  """Return Posts where some of the related Comments match this filter"""
  comments_SOME: CommentWhere
  content: String
  content_CONTAINS: String
  content_ENDS_WITH: String
  content_IN: [String]
  content_STARTS_WITH: String
  creator: UserWhere
  creatorAggregate: PostCreatorAggregateInput
  creatorConnection: ContentCreatorConnectionWhere
  creatorConnection_NOT: ContentCreatorConnectionWhere
  creator_NOT: UserWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
}

type PostsConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Query {
  comments(options: CommentOptions, where: CommentWhere): [Comment!]!
  commentsAggregate(where: CommentWhere): CommentAggregateSelection!
  commentsConnection(after: String, first: Int, sort: [CommentSort], where: CommentWhere): CommentsConnection!
  contents(options: ContentOptions, where: ContentWhere): [Content!]!
  contentsAggregate(where: ContentWhere): ContentAggregateSelection!
  contentsConnection(after: String, first: Int, sort: [ContentSort], where: ContentWhere): ContentsConnection!
  posts(options: PostOptions, where: PostWhere): [Post!]!
  postsAggregate(where: PostWhere): PostAggregateSelection!
  postsConnection(after: String, first: Int, sort: [PostSort], where: PostWhere): PostsConnection!
  users(options: UserOptions, where: UserWhere): [User!]!
  usersAggregate(where: UserWhere): UserAggregateSelection!
  usersConnection(after: String, first: Int, sort: [UserSort], where: UserWhere): UsersConnection!
}

"""An enum for sorting in either ascending or descending order."""
enum SortDirection {
  """Sort by field values in ascending order."""
  ASC
  """Sort by field values in descending order."""
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type UpdateCommentsMutationResponse {
  comments: [Comment!]!
  info: UpdateInfo!
}

"""
Information about the number of nodes and relationships created and deleted during an update mutation
"""
type UpdateInfo {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdatePostsMutationResponse {
  info: UpdateInfo!
  posts: [Post!]!
}

type UpdateUsersMutationResponse {
  info: UpdateInfo!
  users: [User!]!
}

type User {
  content(directed: Boolean = true, options: ContentOptions, where: ContentWhere): [Content!]!
  contentAggregate(directed: Boolean = true, where: ContentWhere): UserContentContentAggregationSelection
  contentConnection(after: String, directed: Boolean = true, first: Int, sort: [UserContentConnectionSort!], where: UserContentConnectionWhere): UserContentConnection!
  id: ID
  name: String
}

type UserAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input UserConnectInput {
  content: [UserContentConnectFieldInput!]
}

input UserConnectWhere {
  node: UserWhere!
}

input UserContentAggregateInput {
  AND: [UserContentAggregateInput!]
  NOT: UserContentAggregateInput
  OR: [UserContentAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: UserContentNodeAggregationWhereInput
}

input UserContentConnectFieldInput {
  connect: ContentConnectInput
  where: ContentConnectWhere
}

type UserContentConnection {
  edges: [UserContentRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input UserContentConnectionSort {
  node: ContentSort
}

input UserContentConnectionWhere {
  AND: [UserContentConnectionWhere!]
  NOT: UserContentConnectionWhere
  OR: [UserContentConnectionWhere!]
  node: ContentWhere
}

type UserContentContentAggregationSelection {
  count: Int!
  node: UserContentContentNodeAggregateSelection
}

type UserContentContentNodeAggregateSelection {
  content: StringAggregateSelection!
  id: IDAggregateSelection!
}

input UserContentCreateFieldInput {
  node: ContentCreateInput!
}

input UserContentDeleteFieldInput {
  delete: ContentDeleteInput
  where: UserContentConnectionWhere
}

input UserContentDisconnectFieldInput {
  disconnect: ContentDisconnectInput
  where: UserContentConnectionWhere
}

input UserContentFieldInput {
  connect: [UserContentConnectFieldInput!]
  create: [UserContentCreateFieldInput!]
}

input UserContentNodeAggregationWhereInput {
  AND: [UserContentNodeAggregationWhereInput!]
  NOT: UserContentNodeAggregationWhereInput
  OR: [UserContentNodeAggregationWhereInput!]
  content_AVERAGE_LENGTH_EQUAL: Float
  content_AVERAGE_LENGTH_GT: Float
  content_AVERAGE_LENGTH_GTE: Float
  content_AVERAGE_LENGTH_LT: Float
  content_AVERAGE_LENGTH_LTE: Float
  content_LONGEST_LENGTH_EQUAL: Int
  content_LONGEST_LENGTH_GT: Int
  content_LONGEST_LENGTH_GTE: Int
  content_LONGEST_LENGTH_LT: Int
  content_LONGEST_LENGTH_LTE: Int
  content_SHORTEST_LENGTH_EQUAL: Int
  content_SHORTEST_LENGTH_GT: Int
  content_SHORTEST_LENGTH_GTE: Int
  content_SHORTEST_LENGTH_LT: Int
  content_SHORTEST_LENGTH_LTE: Int
}

type UserContentRelationship {
  cursor: String!
  node: Content!
}

input UserContentUpdateConnectionInput {
  node: ContentUpdateInput
}

input UserContentUpdateFieldInput {
  connect: [UserContentConnectFieldInput!]
  create: [UserContentCreateFieldInput!]
  delete: [UserContentDeleteFieldInput!]
  disconnect: [UserContentDisconnectFieldInput!]
  update: UserContentUpdateConnectionInput
  where: UserContentConnectionWhere
}

input UserCreateInput {
  content: UserContentFieldInput
  id: ID
  name: String
}

input UserDeleteInput {
  content: [UserContentDeleteFieldInput!]
}

input UserDisconnectInput {
  content: [UserContentDisconnectFieldInput!]
}

type UserEdge {
  cursor: String!
  node: User!
}

input UserOptions {
  limit: Int
  offset: Int
  """
  Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [UserSort!]
}

input UserRelationInput {
  content: [UserContentCreateFieldInput!]
}

"""
Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object.
"""
input UserSort {
  id: SortDirection
  name: SortDirection
}

input UserUpdateInput {
  content: [UserContentUpdateFieldInput!]
  id: ID
  name: String
}

input UserWhere {
  AND: [UserWhere!]
  NOT: UserWhere
  OR: [UserWhere!]
  contentAggregate: UserContentAggregateInput
  """
  Return Users where all of the related UserContentConnections match this filter
  """
  contentConnection_ALL: UserContentConnectionWhere
  """
  Return Users where none of the related UserContentConnections match this filter
  """
  contentConnection_NONE: UserContentConnectionWhere
  """
  Return Users where one of the related UserContentConnections match this filter
  """
  contentConnection_SINGLE: UserContentConnectionWhere
  """
  Return Users where some of the related UserContentConnections match this filter
  """
  contentConnection_SOME: UserContentConnectionWhere
  """Return Users where all of the related Contents match this filter"""
  content_ALL: ContentWhere
  """Return Users where none of the related Contents match this filter"""
  content_NONE: ContentWhere
  """Return Users where one of the related Contents match this filter"""
  content_SINGLE: ContentWhere
  """Return Users where some of the related Contents match this filter"""
  content_SOME: ContentWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_STARTS_WITH: String
}

type UsersConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
----

'''
