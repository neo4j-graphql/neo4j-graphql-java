:toc:

= Algebraic -> Operators should be presents in nested updates

== Source schema

[source,graphql,schema=true]
----
type Movie {
  id: ID
  viewers: Int!
  directedBy: Director @relationship(type: "DIRECTS", direction: IN)
}

type Director {
  lastName: String!
  directs: [Movie!]! @relationship(type: "DIRECTS", direction: OUT)
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

type CreateDirectorsMutationResponse {
  directors: [Director!]!
  info: CreateInfo!
}

"""
Information about the number of nodes and relationships created during a create mutation
"""
type CreateInfo {
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateMoviesMutationResponse {
  info: CreateInfo!
  movies: [Movie!]!
}

"""
Information about the number of nodes and relationships deleted during a delete mutation
"""
type DeleteInfo {
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type Director {
  directs(directed: Boolean = true, options: MovieOptions, where: MovieWhere): [Movie!]!
  directsAggregate(directed: Boolean = true, where: MovieWhere): DirectorMovieDirectsAggregationSelection
  directsConnection(after: String, directed: Boolean = true, first: Int, sort: [DirectorDirectsConnectionSort!], where: DirectorDirectsConnectionWhere): DirectorDirectsConnection!
  lastName: String!
}

type DirectorAggregateSelection {
  count: Int!
  lastName: StringAggregateSelection!
}

input DirectorConnectInput {
  directs: [DirectorDirectsConnectFieldInput!]
}

input DirectorConnectWhere {
  node: DirectorWhere!
}

input DirectorCreateInput {
  directs: DirectorDirectsFieldInput
  lastName: String!
}

input DirectorDeleteInput {
  directs: [DirectorDirectsDeleteFieldInput!]
}

input DirectorDirectsAggregateInput {
  AND: [DirectorDirectsAggregateInput!]
  NOT: DirectorDirectsAggregateInput
  OR: [DirectorDirectsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: DirectorDirectsNodeAggregationWhereInput
}

input DirectorDirectsConnectFieldInput {
  connect: [MovieConnectInput!]
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: MovieConnectWhere
}

type DirectorDirectsConnection {
  edges: [DirectorDirectsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input DirectorDirectsConnectionSort {
  node: MovieSort
}

input DirectorDirectsConnectionWhere {
  AND: [DirectorDirectsConnectionWhere!]
  NOT: DirectorDirectsConnectionWhere
  OR: [DirectorDirectsConnectionWhere!]
  node: MovieWhere
}

input DirectorDirectsCreateFieldInput {
  node: MovieCreateInput!
}

input DirectorDirectsDeleteFieldInput {
  delete: MovieDeleteInput
  where: DirectorDirectsConnectionWhere
}

input DirectorDirectsDisconnectFieldInput {
  disconnect: MovieDisconnectInput
  where: DirectorDirectsConnectionWhere
}

input DirectorDirectsFieldInput {
  connect: [DirectorDirectsConnectFieldInput!]
  create: [DirectorDirectsCreateFieldInput!]
}

input DirectorDirectsNodeAggregationWhereInput {
  AND: [DirectorDirectsNodeAggregationWhereInput!]
  NOT: DirectorDirectsNodeAggregationWhereInput
  OR: [DirectorDirectsNodeAggregationWhereInput!]
  viewers_AVERAGE_EQUAL: Float
  viewers_AVERAGE_GT: Float
  viewers_AVERAGE_GTE: Float
  viewers_AVERAGE_LT: Float
  viewers_AVERAGE_LTE: Float
  viewers_MAX_EQUAL: Int
  viewers_MAX_GT: Int
  viewers_MAX_GTE: Int
  viewers_MAX_LT: Int
  viewers_MAX_LTE: Int
  viewers_MIN_EQUAL: Int
  viewers_MIN_GT: Int
  viewers_MIN_GTE: Int
  viewers_MIN_LT: Int
  viewers_MIN_LTE: Int
  viewers_SUM_EQUAL: Int
  viewers_SUM_GT: Int
  viewers_SUM_GTE: Int
  viewers_SUM_LT: Int
  viewers_SUM_LTE: Int
}

type DirectorDirectsRelationship {
  cursor: String!
  node: Movie!
}

input DirectorDirectsUpdateConnectionInput {
  node: MovieUpdateInput
}

input DirectorDirectsUpdateFieldInput {
  connect: [DirectorDirectsConnectFieldInput!]
  create: [DirectorDirectsCreateFieldInput!]
  delete: [DirectorDirectsDeleteFieldInput!]
  disconnect: [DirectorDirectsDisconnectFieldInput!]
  update: DirectorDirectsUpdateConnectionInput
  where: DirectorDirectsConnectionWhere
}

input DirectorDisconnectInput {
  directs: [DirectorDirectsDisconnectFieldInput!]
}

type DirectorEdge {
  cursor: String!
  node: Director!
}

type DirectorMovieDirectsAggregationSelection {
  count: Int!
  node: DirectorMovieDirectsNodeAggregateSelection
}

type DirectorMovieDirectsNodeAggregateSelection {
  id: IDAggregateSelection!
  viewers: IntAggregateSelection!
}

input DirectorOptions {
  limit: Int
  offset: Int
  """
  Specify one or more DirectorSort objects to sort Directors by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [DirectorSort!]
}

input DirectorRelationInput {
  directs: [DirectorDirectsCreateFieldInput!]
}

"""
Fields to sort Directors by. The order in which sorts are applied is not guaranteed when specifying many fields in one DirectorSort object.
"""
input DirectorSort {
  lastName: SortDirection
}

input DirectorUpdateInput {
  directs: [DirectorDirectsUpdateFieldInput!]
  lastName: String
}

input DirectorWhere {
  AND: [DirectorWhere!]
  NOT: DirectorWhere
  OR: [DirectorWhere!]
  directsAggregate: DirectorDirectsAggregateInput
  """
  Return Directors where all of the related DirectorDirectsConnections match this filter
  """
  directsConnection_ALL: DirectorDirectsConnectionWhere
  """
  Return Directors where none of the related DirectorDirectsConnections match this filter
  """
  directsConnection_NONE: DirectorDirectsConnectionWhere
  """
  Return Directors where one of the related DirectorDirectsConnections match this filter
  """
  directsConnection_SINGLE: DirectorDirectsConnectionWhere
  """
  Return Directors where some of the related DirectorDirectsConnections match this filter
  """
  directsConnection_SOME: DirectorDirectsConnectionWhere
  """Return Directors where all of the related Movies match this filter"""
  directs_ALL: MovieWhere
  """Return Directors where none of the related Movies match this filter"""
  directs_NONE: MovieWhere
  """Return Directors where one of the related Movies match this filter"""
  directs_SINGLE: MovieWhere
  """Return Directors where some of the related Movies match this filter"""
  directs_SOME: MovieWhere
  lastName: String
  lastName_CONTAINS: String
  lastName_ENDS_WITH: String
  lastName_IN: [String!]
  lastName_STARTS_WITH: String
}

type DirectorsConnection {
  edges: [DirectorEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IDAggregateSelection {
  longest: ID
  shortest: ID
}

type IntAggregateSelection {
  average: Float
  max: Int
  min: Int
  sum: Int
}

type Movie {
  directedBy(directed: Boolean = true, options: DirectorOptions, where: DirectorWhere): Director
  directedByAggregate(directed: Boolean = true, where: DirectorWhere): MovieDirectorDirectedByAggregationSelection
  directedByConnection(after: String, directed: Boolean = true, first: Int, sort: [MovieDirectedByConnectionSort!], where: MovieDirectedByConnectionWhere): MovieDirectedByConnection!
  id: ID
  viewers: Int!
}

type MovieAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  viewers: IntAggregateSelection!
}

input MovieConnectInput {
  directedBy: MovieDirectedByConnectFieldInput
}

input MovieConnectWhere {
  node: MovieWhere!
}

input MovieCreateInput {
  directedBy: MovieDirectedByFieldInput
  id: ID
  viewers: Int!
}

input MovieDeleteInput {
  directedBy: MovieDirectedByDeleteFieldInput
}

input MovieDirectedByAggregateInput {
  AND: [MovieDirectedByAggregateInput!]
  NOT: MovieDirectedByAggregateInput
  OR: [MovieDirectedByAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: MovieDirectedByNodeAggregationWhereInput
}

input MovieDirectedByConnectFieldInput {
  connect: DirectorConnectInput
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: DirectorConnectWhere
}

type MovieDirectedByConnection {
  edges: [MovieDirectedByRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input MovieDirectedByConnectionSort {
  node: DirectorSort
}

input MovieDirectedByConnectionWhere {
  AND: [MovieDirectedByConnectionWhere!]
  NOT: MovieDirectedByConnectionWhere
  OR: [MovieDirectedByConnectionWhere!]
  node: DirectorWhere
}

input MovieDirectedByCreateFieldInput {
  node: DirectorCreateInput!
}

input MovieDirectedByDeleteFieldInput {
  delete: DirectorDeleteInput
  where: MovieDirectedByConnectionWhere
}

input MovieDirectedByDisconnectFieldInput {
  disconnect: DirectorDisconnectInput
  where: MovieDirectedByConnectionWhere
}

input MovieDirectedByFieldInput {
  connect: MovieDirectedByConnectFieldInput
  create: MovieDirectedByCreateFieldInput
}

input MovieDirectedByNodeAggregationWhereInput {
  AND: [MovieDirectedByNodeAggregationWhereInput!]
  NOT: MovieDirectedByNodeAggregationWhereInput
  OR: [MovieDirectedByNodeAggregationWhereInput!]
  lastName_AVERAGE_LENGTH_EQUAL: Float
  lastName_AVERAGE_LENGTH_GT: Float
  lastName_AVERAGE_LENGTH_GTE: Float
  lastName_AVERAGE_LENGTH_LT: Float
  lastName_AVERAGE_LENGTH_LTE: Float
  lastName_LONGEST_LENGTH_EQUAL: Int
  lastName_LONGEST_LENGTH_GT: Int
  lastName_LONGEST_LENGTH_GTE: Int
  lastName_LONGEST_LENGTH_LT: Int
  lastName_LONGEST_LENGTH_LTE: Int
  lastName_SHORTEST_LENGTH_EQUAL: Int
  lastName_SHORTEST_LENGTH_GT: Int
  lastName_SHORTEST_LENGTH_GTE: Int
  lastName_SHORTEST_LENGTH_LT: Int
  lastName_SHORTEST_LENGTH_LTE: Int
}

type MovieDirectedByRelationship {
  cursor: String!
  node: Director!
}

input MovieDirectedByUpdateConnectionInput {
  node: DirectorUpdateInput
}

input MovieDirectedByUpdateFieldInput {
  connect: MovieDirectedByConnectFieldInput
  create: MovieDirectedByCreateFieldInput
  delete: MovieDirectedByDeleteFieldInput
  disconnect: MovieDirectedByDisconnectFieldInput
  update: MovieDirectedByUpdateConnectionInput
  where: MovieDirectedByConnectionWhere
}

type MovieDirectorDirectedByAggregationSelection {
  count: Int!
  node: MovieDirectorDirectedByNodeAggregateSelection
}

type MovieDirectorDirectedByNodeAggregateSelection {
  lastName: StringAggregateSelection!
}

input MovieDisconnectInput {
  directedBy: MovieDirectedByDisconnectFieldInput
}

type MovieEdge {
  cursor: String!
  node: Movie!
}

input MovieOptions {
  limit: Int
  offset: Int
  """
  Specify one or more MovieSort objects to sort Movies by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [MovieSort!]
}

input MovieRelationInput {
  directedBy: MovieDirectedByCreateFieldInput
}

"""
Fields to sort Movies by. The order in which sorts are applied is not guaranteed when specifying many fields in one MovieSort object.
"""
input MovieSort {
  id: SortDirection
  viewers: SortDirection
}

input MovieUpdateInput {
  directedBy: MovieDirectedByUpdateFieldInput
  id: ID
  viewers: Int
  viewers_DECREMENT: Int
  viewers_INCREMENT: Int
}

input MovieWhere {
  AND: [MovieWhere!]
  NOT: MovieWhere
  OR: [MovieWhere!]
  directedBy: DirectorWhere
  directedByAggregate: MovieDirectedByAggregateInput
  directedByConnection: MovieDirectedByConnectionWhere
  directedByConnection_NOT: MovieDirectedByConnectionWhere
  directedBy_NOT: DirectorWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  viewers: Int
  viewers_GT: Int
  viewers_GTE: Int
  viewers_IN: [Int!]
  viewers_LT: Int
  viewers_LTE: Int
}

type MoviesConnection {
  edges: [MovieEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Mutation {
  createDirectors(input: [DirectorCreateInput!]!): CreateDirectorsMutationResponse!
  createMovies(input: [MovieCreateInput!]!): CreateMoviesMutationResponse!
  deleteDirectors(delete: DirectorDeleteInput, where: DirectorWhere): DeleteInfo!
  deleteMovies(delete: MovieDeleteInput, where: MovieWhere): DeleteInfo!
  updateDirectors(connect: DirectorConnectInput, create: DirectorRelationInput, delete: DirectorDeleteInput, disconnect: DirectorDisconnectInput, update: DirectorUpdateInput, where: DirectorWhere): UpdateDirectorsMutationResponse!
  updateMovies(connect: MovieConnectInput, create: MovieRelationInput, delete: MovieDeleteInput, disconnect: MovieDisconnectInput, update: MovieUpdateInput, where: MovieWhere): UpdateMoviesMutationResponse!
}

"""Pagination information (Relay)"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  directors(options: DirectorOptions, where: DirectorWhere): [Director!]!
  directorsAggregate(where: DirectorWhere): DirectorAggregateSelection!
  directorsConnection(after: String, first: Int, sort: [DirectorSort], where: DirectorWhere): DirectorsConnection!
  movies(options: MovieOptions, where: MovieWhere): [Movie!]!
  moviesAggregate(where: MovieWhere): MovieAggregateSelection!
  moviesConnection(after: String, first: Int, sort: [MovieSort], where: MovieWhere): MoviesConnection!
}

"""An enum for sorting in either ascending or descending order."""
enum SortDirection {
  """Sort by field values in ascending order."""
  ASC
  """Sort by field values in descending order."""
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type UpdateDirectorsMutationResponse {
  directors: [Director!]!
  info: UpdateInfo!
}

"""
Information about the number of nodes and relationships created and deleted during an update mutation
"""
type UpdateInfo {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateMoviesMutationResponse {
  info: UpdateInfo!
  movies: [Movie!]!
}
----

'''
