:toc:

= https://github.com/neo4j/graphql/issues/3439 -> Simple type definitions implementing just one interface - relationship to union type

== Source schema

[source,graphql,schema=true]
----
interface IProduct {
  id: String!
  name: String!
  genre: UGenre! @declareRelationship
}

type Movie implements IProduct {
  id: String!
  name: String!
  genre: UGenre! @relationship(type: "HAS_GENRE", direction: OUT, properties: "MovieProps")
}

type Series implements IProduct {
  id: String!
  name: String!
  genre: UGenre! @relationship(type: "HAS_GENRE", direction: OUT, properties: "SeriesProps")
}

type MovieProps @relationshipProperties {
  year: Int!
}

type SeriesProps @relationshipProperties {
  episodes: Int
}

union UGenre = Genre | Rating

type Genre {
  name: String! @unique
  product: [IProduct!]! @relationship(type: "HAS_GENRE", direction: IN)
}

type Rating {
  number: Int! @unique
  product: [IProduct!]! @relationship(type: "HAS_RATING", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "features": {
    "subscriptions": true
  }
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type CreateGenresMutationResponse {
  genres: [Genre!]!
  info: CreateInfo!
}

"""
Information about the number of nodes and relationships created during a create mutation
"""
type CreateInfo {
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateMoviesMutationResponse {
  info: CreateInfo!
  movies: [Movie!]!
}

type CreateRatingsMutationResponse {
  info: CreateInfo!
  ratings: [Rating!]!
}

type CreateSeriesMutationResponse {
  info: CreateInfo!
  series: [Series!]!
}

"""
Information about the number of nodes and relationships deleted during a delete mutation
"""
type DeleteInfo {
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

enum EventType {
  CREATE
  CREATE_RELATIONSHIP
  DELETE
  DELETE_RELATIONSHIP
  UPDATE
}

type Genre {
  name: String!
  product(directed: Boolean = true, options: IProductOptions, where: IProductWhere): [IProduct!]!
  productAggregate(directed: Boolean = true, where: IProductWhere): GenreIProductProductAggregationSelection
  productConnection(after: String, directed: Boolean = true, first: Int, sort: [GenreProductConnectionSort!], where: GenreProductConnectionWhere): GenreProductConnection!
}

type GenreAggregateSelection {
  count: Int!
  name: StringAggregateSelection!
}

input GenreConnectInput {
  product: [GenreProductConnectFieldInput!]
}

input GenreConnectOrCreateWhere {
  node: GenreUniqueWhere!
}

input GenreConnectWhere {
  node: GenreWhere!
}

type GenreConnectedRelationships {
  product: GenreProductConnectedRelationship
}

input GenreCreateInput {
  name: String!
  product: GenreProductFieldInput
}

type GenreCreatedEvent {
  createdGenre: GenreEventPayload!
  event: EventType!
  timestamp: Float!
}

input GenreDeleteInput {
  product: [GenreProductDeleteFieldInput!]
}

type GenreDeletedEvent {
  deletedGenre: GenreEventPayload!
  event: EventType!
  timestamp: Float!
}

input GenreDisconnectInput {
  product: [GenreProductDisconnectFieldInput!]
}

type GenreEdge {
  cursor: String!
  node: Genre!
}

type GenreEventPayload {
  name: String!
}

type GenreIProductProductAggregationSelection {
  count: Int!
  node: GenreIProductProductNodeAggregateSelection
}

type GenreIProductProductNodeAggregateSelection {
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input GenreOnCreateInput {
  name: String!
}

input GenreOptions {
  limit: Int
  offset: Int
  """
  Specify one or more GenreSort objects to sort Genres by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [GenreSort!]
}

input GenreProductAggregateInput {
  AND: [GenreProductAggregateInput!]
  NOT: GenreProductAggregateInput
  OR: [GenreProductAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: GenreProductNodeAggregationWhereInput
}

input GenreProductConnectFieldInput {
  connect: IProductConnectInput
  where: IProductConnectWhere
}

type GenreProductConnectedRelationship {
  node: IProductEventPayload!
}

type GenreProductConnection {
  edges: [GenreProductRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input GenreProductConnectionSort {
  node: IProductSort
}

input GenreProductConnectionWhere {
  AND: [GenreProductConnectionWhere!]
  NOT: GenreProductConnectionWhere
  OR: [GenreProductConnectionWhere!]
  node: IProductWhere
}

input GenreProductCreateFieldInput {
  node: IProductCreateInput!
}

input GenreProductDeleteFieldInput {
  delete: IProductDeleteInput
  where: GenreProductConnectionWhere
}

input GenreProductDisconnectFieldInput {
  disconnect: IProductDisconnectInput
  where: GenreProductConnectionWhere
}

input GenreProductFieldInput {
  connect: [GenreProductConnectFieldInput!]
  create: [GenreProductCreateFieldInput!]
}

input GenreProductNodeAggregationWhereInput {
  AND: [GenreProductNodeAggregationWhereInput!]
  NOT: GenreProductNodeAggregationWhereInput
  OR: [GenreProductNodeAggregationWhereInput!]
  id_AVERAGE_LENGTH_EQUAL: Float
  id_AVERAGE_LENGTH_GT: Float
  id_AVERAGE_LENGTH_GTE: Float
  id_AVERAGE_LENGTH_LT: Float
  id_AVERAGE_LENGTH_LTE: Float
  id_LONGEST_LENGTH_EQUAL: Int
  id_LONGEST_LENGTH_GT: Int
  id_LONGEST_LENGTH_GTE: Int
  id_LONGEST_LENGTH_LT: Int
  id_LONGEST_LENGTH_LTE: Int
  id_SHORTEST_LENGTH_EQUAL: Int
  id_SHORTEST_LENGTH_GT: Int
  id_SHORTEST_LENGTH_GTE: Int
  id_SHORTEST_LENGTH_LT: Int
  id_SHORTEST_LENGTH_LTE: Int
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

type GenreProductRelationship {
  cursor: String!
  node: IProduct!
}

input GenreProductRelationshipSubscriptionWhere {
  node: IProductSubscriptionWhere
}

input GenreProductUpdateConnectionInput {
  node: IProductUpdateInput
}

input GenreProductUpdateFieldInput {
  connect: [GenreProductConnectFieldInput!]
  create: [GenreProductCreateFieldInput!]
  delete: [GenreProductDeleteFieldInput!]
  disconnect: [GenreProductDisconnectFieldInput!]
  update: GenreProductUpdateConnectionInput
  where: GenreProductConnectionWhere
}

input GenreRelationInput {
  product: [GenreProductCreateFieldInput!]
}

type GenreRelationshipCreatedEvent {
  createdRelationship: GenreConnectedRelationships!
  event: EventType!
  genre: GenreEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input GenreRelationshipCreatedSubscriptionWhere {
  AND: [GenreRelationshipCreatedSubscriptionWhere!]
  NOT: GenreRelationshipCreatedSubscriptionWhere
  OR: [GenreRelationshipCreatedSubscriptionWhere!]
  createdRelationship: GenreRelationshipsSubscriptionWhere
  genre: GenreSubscriptionWhere
}

type GenreRelationshipDeletedEvent {
  deletedRelationship: GenreConnectedRelationships!
  event: EventType!
  genre: GenreEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input GenreRelationshipDeletedSubscriptionWhere {
  AND: [GenreRelationshipDeletedSubscriptionWhere!]
  NOT: GenreRelationshipDeletedSubscriptionWhere
  OR: [GenreRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: GenreRelationshipsSubscriptionWhere
  genre: GenreSubscriptionWhere
}

input GenreRelationshipsSubscriptionWhere {
  product: GenreProductRelationshipSubscriptionWhere
}

"""
Fields to sort Genres by. The order in which sorts are applied is not guaranteed when specifying many fields in one GenreSort object.
"""
input GenreSort {
  name: SortDirection
}

input GenreSubscriptionWhere {
  AND: [GenreSubscriptionWhere!]
  NOT: GenreSubscriptionWhere
  OR: [GenreSubscriptionWhere!]
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

input GenreUniqueWhere {
  name: String
}

input GenreUpdateInput {
  name: String
  product: [GenreProductUpdateFieldInput!]
}

type GenreUpdatedEvent {
  event: EventType!
  previousState: GenreEventPayload!
  timestamp: Float!
  updatedGenre: GenreEventPayload!
}

input GenreWhere {
  AND: [GenreWhere!]
  NOT: GenreWhere
  OR: [GenreWhere!]
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
  productAggregate: GenreProductAggregateInput
  """
  Return Genres where all of the related GenreProductConnections match this filter
  """
  productConnection_ALL: GenreProductConnectionWhere
  """
  Return Genres where none of the related GenreProductConnections match this filter
  """
  productConnection_NONE: GenreProductConnectionWhere
  """
  Return Genres where one of the related GenreProductConnections match this filter
  """
  productConnection_SINGLE: GenreProductConnectionWhere
  """
  Return Genres where some of the related GenreProductConnections match this filter
  """
  productConnection_SOME: GenreProductConnectionWhere
  """Return Genres where all of the related IProducts match this filter"""
  product_ALL: IProductWhere
  """Return Genres where none of the related IProducts match this filter"""
  product_NONE: IProductWhere
  """Return Genres where one of the related IProducts match this filter"""
  product_SINGLE: IProductWhere
  """Return Genres where some of the related IProducts match this filter"""
  product_SOME: IProductWhere
}

type GenresConnection {
  edges: [GenreEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

interface IProduct {
  genre(options: QueryOptions, where: UGenreWhere): UGenre!
  genreConnection(after: String, first: Int, sort: [IProductGenreConnectionSort!], where: IProductGenreConnectionWhere): IProductGenreConnection!
  id: String!
  name: String!
}

type IProductAggregateSelection {
  count: Int!
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input IProductConnectInput {
  genre: IProductGenreConnectInput
}

input IProductConnectWhere {
  node: IProductWhere!
}

input IProductCreateInput {
  Movie: MovieCreateInput
  Series: SeriesCreateInput
}

input IProductDeleteInput {
  genre: IProductGenreDeleteInput
}

input IProductDisconnectInput {
  genre: IProductGenreDisconnectInput
}

type IProductEdge {
  cursor: String!
  node: IProduct!
}

interface IProductEventPayload {
  id: String!
  name: String!
}

input IProductGenreConnectInput {
  Genre: IProductGenreGenreConnectFieldInput
  Rating: IProductGenreRatingConnectFieldInput
}

type IProductGenreConnection {
  edges: [IProductGenreRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input IProductGenreConnectionSort {
  edge: IProductGenreEdgeSort
}

input IProductGenreConnectionWhere {
  Genre: IProductGenreGenreConnectionWhere
  Rating: IProductGenreRatingConnectionWhere
}

input IProductGenreDeleteInput {
  Genre: IProductGenreGenreDeleteFieldInput
  Rating: IProductGenreRatingDeleteFieldInput
}

input IProductGenreDisconnectInput {
  Genre: IProductGenreGenreDisconnectFieldInput
  Rating: IProductGenreRatingDisconnectFieldInput
}

input IProductGenreEdgeCreateInput {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsCreateInput!
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsCreateInput
}

input IProductGenreEdgeSort {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsSort
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsSort
}

input IProductGenreEdgeUpdateInput {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsUpdateInput
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsUpdateInput
}

input IProductGenreEdgeWhere {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsWhere
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsWhere
}

input IProductGenreGenreConnectFieldInput {
  connect: GenreConnectInput
  edge: IProductGenreEdgeCreateInput!
  where: GenreConnectWhere
}

input IProductGenreGenreConnectOrCreateFieldInput {
  onCreate: IProductGenreGenreConnectOrCreateFieldInputOnCreate!
  where: GenreConnectOrCreateWhere!
}

input IProductGenreGenreConnectOrCreateFieldInputOnCreate {
  edge: IProductGenreEdgeCreateInput!
  node: GenreOnCreateInput!
}

input IProductGenreGenreConnectionWhere {
  AND: [IProductGenreGenreConnectionWhere!]
  NOT: IProductGenreGenreConnectionWhere
  OR: [IProductGenreGenreConnectionWhere!]
  edge: IProductGenreEdgeWhere
  node: GenreWhere
}

input IProductGenreGenreCreateFieldInput {
  edge: IProductGenreEdgeCreateInput!
  node: GenreCreateInput!
}

input IProductGenreGenreDeleteFieldInput {
  delete: GenreDeleteInput
  where: IProductGenreGenreConnectionWhere
}

input IProductGenreGenreDisconnectFieldInput {
  disconnect: GenreDisconnectInput
  where: IProductGenreGenreConnectionWhere
}

input IProductGenreGenreUpdateConnectionInput {
  edge: IProductGenreEdgeUpdateInput
  node: GenreUpdateInput
}

input IProductGenreGenreUpdateFieldInput {
  connect: IProductGenreGenreConnectFieldInput
  connectOrCreate: IProductGenreGenreConnectOrCreateFieldInput
  create: IProductGenreGenreCreateFieldInput
  delete: IProductGenreGenreDeleteFieldInput
  disconnect: IProductGenreGenreDisconnectFieldInput
  update: IProductGenreGenreUpdateConnectionInput
  where: IProductGenreGenreConnectionWhere
}

input IProductGenreRatingConnectFieldInput {
  connect: RatingConnectInput
  edge: IProductGenreEdgeCreateInput!
  where: RatingConnectWhere
}

input IProductGenreRatingConnectOrCreateFieldInput {
  onCreate: IProductGenreRatingConnectOrCreateFieldInputOnCreate!
  where: RatingConnectOrCreateWhere!
}

input IProductGenreRatingConnectOrCreateFieldInputOnCreate {
  edge: IProductGenreEdgeCreateInput!
  node: RatingOnCreateInput!
}

input IProductGenreRatingConnectionWhere {
  AND: [IProductGenreRatingConnectionWhere!]
  NOT: IProductGenreRatingConnectionWhere
  OR: [IProductGenreRatingConnectionWhere!]
  edge: IProductGenreEdgeWhere
  node: RatingWhere
}

input IProductGenreRatingCreateFieldInput {
  edge: IProductGenreEdgeCreateInput!
  node: RatingCreateInput!
}

input IProductGenreRatingDeleteFieldInput {
  delete: RatingDeleteInput
  where: IProductGenreRatingConnectionWhere
}

input IProductGenreRatingDisconnectFieldInput {
  disconnect: RatingDisconnectInput
  where: IProductGenreRatingConnectionWhere
}

input IProductGenreRatingUpdateConnectionInput {
  edge: IProductGenreEdgeUpdateInput
  node: RatingUpdateInput
}

input IProductGenreRatingUpdateFieldInput {
  connect: IProductGenreRatingConnectFieldInput
  connectOrCreate: IProductGenreRatingConnectOrCreateFieldInput
  create: IProductGenreRatingCreateFieldInput
  delete: IProductGenreRatingDeleteFieldInput
  disconnect: IProductGenreRatingDisconnectFieldInput
  update: IProductGenreRatingUpdateConnectionInput
  where: IProductGenreRatingConnectionWhere
}

type IProductGenreRelationship {
  cursor: String!
  node: UGenre!
  properties: IProductGenreRelationshipProperties!
}

union IProductGenreRelationshipProperties = MovieProps | SeriesProps

input IProductGenreUpdateInput {
  Genre: IProductGenreGenreUpdateFieldInput
  Rating: IProductGenreRatingUpdateFieldInput
}

enum IProductImplementation {
  Movie
  Series
}

input IProductOptions {
  limit: Int
  offset: Int
  """
  Specify one or more IProductSort objects to sort IProducts by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [IProductSort]
}

"""
Fields to sort IProducts by. The order in which sorts are applied is not guaranteed when specifying many fields in one IProductSort object.
"""
input IProductSort {
  id: SortDirection
  name: SortDirection
}

input IProductSubscriptionWhere {
  AND: [IProductSubscriptionWhere!]
  NOT: IProductSubscriptionWhere
  OR: [IProductSubscriptionWhere!]
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
  typename_IN: [IProductImplementation!]
}

input IProductUpdateInput {
  genre: IProductGenreUpdateInput
  id: String
  name: String
}

input IProductWhere {
  AND: [IProductWhere!]
  NOT: IProductWhere
  OR: [IProductWhere!]
  genre: UGenreWhere
  genreConnection: IProductGenreConnectionWhere
  genreConnection_NOT: IProductGenreConnectionWhere
  genre_NOT: UGenreWhere
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
  typename_IN: [IProductImplementation!]
}

type IProductsConnection {
  edges: [IProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IntAggregateSelection {
  average: Float
  max: Int
  min: Int
  sum: Int
}

type Movie implements IProduct {
  genre(directed: Boolean = true, options: QueryOptions, where: UGenreWhere): UGenre!
  genreConnection(after: String, directed: Boolean = true, first: Int, sort: [IProductGenreConnectionSort!], where: IProductGenreConnectionWhere): IProductGenreConnection!
  id: String!
  name: String!
}

type MovieAggregateSelection {
  count: Int!
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input MovieConnectInput {
  genre: MovieGenreConnectInput
}

input MovieConnectOrCreateInput {
  genre: MovieGenreConnectOrCreateInput
}

type MovieConnectedRelationships {
  genre: MovieGenreConnectedRelationship
}

input MovieCreateInput {
  genre: MovieGenreCreateInput
  id: String!
  name: String!
}

type MovieCreatedEvent {
  createdMovie: MovieEventPayload!
  event: EventType!
  timestamp: Float!
}

input MovieDeleteInput {
  genre: MovieGenreDeleteInput
}

type MovieDeletedEvent {
  deletedMovie: MovieEventPayload!
  event: EventType!
  timestamp: Float!
}

input MovieDisconnectInput {
  genre: MovieGenreDisconnectInput
}

type MovieEdge {
  cursor: String!
  node: Movie!
}

type MovieEventPayload implements IProductEventPayload {
  id: String!
  name: String!
}

input MovieGenreConnectInput {
  Genre: MovieGenreGenreConnectFieldInput
  Rating: MovieGenreRatingConnectFieldInput
}

input MovieGenreConnectOrCreateInput {
  Genre: MovieGenreGenreConnectOrCreateFieldInput
  Rating: MovieGenreRatingConnectOrCreateFieldInput
}

type MovieGenreConnectedRelationship {
  node: UGenreEventPayload!
  year: Int!
}

input MovieGenreCreateFieldInput {
  Genre: MovieGenreGenreCreateFieldInput
  Rating: MovieGenreRatingCreateFieldInput
}

input MovieGenreCreateInput {
  Genre: MovieGenreGenreFieldInput
  Rating: MovieGenreRatingFieldInput
}

input MovieGenreDeleteInput {
  Genre: IProductGenreGenreDeleteFieldInput
  Rating: IProductGenreRatingDeleteFieldInput
}

input MovieGenreDisconnectInput {
  Genre: IProductGenreGenreDisconnectFieldInput
  Rating: IProductGenreRatingDisconnectFieldInput
}

input MovieGenreGenreConnectFieldInput {
  connect: GenreConnectInput
  edge: MoviePropsCreateInput!
  where: GenreConnectWhere
}

input MovieGenreGenreConnectOrCreateFieldInput {
  onCreate: MovieGenreGenreConnectOrCreateFieldInputOnCreate!
  where: GenreConnectOrCreateWhere!
}

input MovieGenreGenreConnectOrCreateFieldInputOnCreate {
  edge: MoviePropsCreateInput!
  node: GenreOnCreateInput!
}

input MovieGenreGenreCreateFieldInput {
  edge: MoviePropsCreateInput!
  node: GenreCreateInput!
}

input MovieGenreGenreFieldInput {
  connect: MovieGenreGenreConnectFieldInput
  connectOrCreate: MovieGenreGenreConnectOrCreateFieldInput
  create: MovieGenreGenreCreateFieldInput
}

input MovieGenreGenreSubscriptionWhere {
  edge: MoviePropsSubscriptionWhere
  node: GenreSubscriptionWhere
}

input MovieGenreGenreUpdateConnectionInput {
  edge: MoviePropsUpdateInput
  node: GenreUpdateInput
}

input MovieGenreGenreUpdateFieldInput {
  connect: MovieGenreGenreConnectFieldInput
  connectOrCreate: MovieGenreGenreConnectOrCreateFieldInput
  create: MovieGenreGenreCreateFieldInput
  delete: IProductGenreGenreDeleteFieldInput
  disconnect: IProductGenreGenreDisconnectFieldInput
  update: MovieGenreGenreUpdateConnectionInput
  where: IProductGenreGenreConnectionWhere
}

input MovieGenreRatingConnectFieldInput {
  connect: RatingConnectInput
  edge: MoviePropsCreateInput!
  where: RatingConnectWhere
}

input MovieGenreRatingConnectOrCreateFieldInput {
  onCreate: MovieGenreRatingConnectOrCreateFieldInputOnCreate!
  where: RatingConnectOrCreateWhere!
}

input MovieGenreRatingConnectOrCreateFieldInputOnCreate {
  edge: MoviePropsCreateInput!
  node: RatingOnCreateInput!
}

input MovieGenreRatingCreateFieldInput {
  edge: MoviePropsCreateInput!
  node: RatingCreateInput!
}

input MovieGenreRatingFieldInput {
  connect: MovieGenreRatingConnectFieldInput
  connectOrCreate: MovieGenreRatingConnectOrCreateFieldInput
  create: MovieGenreRatingCreateFieldInput
}

input MovieGenreRatingSubscriptionWhere {
  edge: MoviePropsSubscriptionWhere
  node: RatingSubscriptionWhere
}

input MovieGenreRatingUpdateConnectionInput {
  edge: MoviePropsUpdateInput
  node: RatingUpdateInput
}

input MovieGenreRatingUpdateFieldInput {
  connect: MovieGenreRatingConnectFieldInput
  connectOrCreate: MovieGenreRatingConnectOrCreateFieldInput
  create: MovieGenreRatingCreateFieldInput
  delete: IProductGenreRatingDeleteFieldInput
  disconnect: IProductGenreRatingDisconnectFieldInput
  update: MovieGenreRatingUpdateConnectionInput
  where: IProductGenreRatingConnectionWhere
}

input MovieGenreRelationshipSubscriptionWhere {
  Genre: MovieGenreGenreSubscriptionWhere
  Rating: MovieGenreRatingSubscriptionWhere
}

input MovieGenreUpdateInput {
  Genre: MovieGenreGenreUpdateFieldInput
  Rating: MovieGenreRatingUpdateFieldInput
}

input MovieOptions {
  limit: Int
  offset: Int
  """
  Specify one or more MovieSort objects to sort Movies by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [MovieSort!]
}

"""
The edge properties for the following fields:
* Movie.genre
"""
type MovieProps {
  year: Int!
}

input MoviePropsCreateInput {
  year: Int!
}

input MoviePropsSort {
  year: SortDirection
}

input MoviePropsSubscriptionWhere {
  AND: [MoviePropsSubscriptionWhere!]
  NOT: MoviePropsSubscriptionWhere
  OR: [MoviePropsSubscriptionWhere!]
  year: Int
  year_GT: Int
  year_GTE: Int
  year_IN: [Int!]
  year_LT: Int
  year_LTE: Int
}

input MoviePropsUpdateInput {
  year: Int
  year_DECREMENT: Int
  year_INCREMENT: Int
}

input MoviePropsWhere {
  AND: [MoviePropsWhere!]
  NOT: MoviePropsWhere
  OR: [MoviePropsWhere!]
  year: Int
  year_GT: Int
  year_GTE: Int
  year_IN: [Int!]
  year_LT: Int
  year_LTE: Int
}

input MovieRelationInput {
  genre: MovieGenreCreateFieldInput
}

type MovieRelationshipCreatedEvent {
  createdRelationship: MovieConnectedRelationships!
  event: EventType!
  movie: MovieEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input MovieRelationshipCreatedSubscriptionWhere {
  AND: [MovieRelationshipCreatedSubscriptionWhere!]
  NOT: MovieRelationshipCreatedSubscriptionWhere
  OR: [MovieRelationshipCreatedSubscriptionWhere!]
  createdRelationship: MovieRelationshipsSubscriptionWhere
  movie: MovieSubscriptionWhere
}

type MovieRelationshipDeletedEvent {
  deletedRelationship: MovieConnectedRelationships!
  event: EventType!
  movie: MovieEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input MovieRelationshipDeletedSubscriptionWhere {
  AND: [MovieRelationshipDeletedSubscriptionWhere!]
  NOT: MovieRelationshipDeletedSubscriptionWhere
  OR: [MovieRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: MovieRelationshipsSubscriptionWhere
  movie: MovieSubscriptionWhere
}

input MovieRelationshipsSubscriptionWhere {
  genre: MovieGenreRelationshipSubscriptionWhere
}

"""
Fields to sort Movies by. The order in which sorts are applied is not guaranteed when specifying many fields in one MovieSort object.
"""
input MovieSort {
  id: SortDirection
  name: SortDirection
}

input MovieSubscriptionWhere {
  AND: [MovieSubscriptionWhere!]
  NOT: MovieSubscriptionWhere
  OR: [MovieSubscriptionWhere!]
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

input MovieUpdateInput {
  genre: MovieGenreUpdateInput
  id: String
  name: String
}

type MovieUpdatedEvent {
  event: EventType!
  previousState: MovieEventPayload!
  timestamp: Float!
  updatedMovie: MovieEventPayload!
}

input MovieWhere {
  AND: [MovieWhere!]
  NOT: MovieWhere
  OR: [MovieWhere!]
  genre: UGenreWhere
  genreConnection: IProductGenreConnectionWhere
  genreConnection_NOT: IProductGenreConnectionWhere
  genre_NOT: UGenreWhere
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

type MoviesConnection {
  edges: [MovieEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Mutation {
  createGenres(input: [GenreCreateInput!]!): CreateGenresMutationResponse!
  createMovies(input: [MovieCreateInput!]!): CreateMoviesMutationResponse!
  createRatings(input: [RatingCreateInput!]!): CreateRatingsMutationResponse!
  createSeries(input: [SeriesCreateInput!]!): CreateSeriesMutationResponse!
  deleteGenres(delete: GenreDeleteInput, where: GenreWhere): DeleteInfo!
  deleteMovies(delete: MovieDeleteInput, where: MovieWhere): DeleteInfo!
  deleteRatings(delete: RatingDeleteInput, where: RatingWhere): DeleteInfo!
  deleteSeries(delete: SeriesDeleteInput, where: SeriesWhere): DeleteInfo!
  updateGenres(connect: GenreConnectInput, create: GenreRelationInput, delete: GenreDeleteInput, disconnect: GenreDisconnectInput, update: GenreUpdateInput, where: GenreWhere): UpdateGenresMutationResponse!
  updateMovies(connect: MovieConnectInput, connectOrCreate: MovieConnectOrCreateInput, create: MovieRelationInput, delete: MovieDeleteInput, disconnect: MovieDisconnectInput, update: MovieUpdateInput, where: MovieWhere): UpdateMoviesMutationResponse!
  updateRatings(connect: RatingConnectInput, create: RatingRelationInput, delete: RatingDeleteInput, disconnect: RatingDisconnectInput, update: RatingUpdateInput, where: RatingWhere): UpdateRatingsMutationResponse!
  updateSeries(connect: SeriesConnectInput, connectOrCreate: SeriesConnectOrCreateInput, create: SeriesRelationInput, delete: SeriesDeleteInput, disconnect: SeriesDisconnectInput, update: SeriesUpdateInput, where: SeriesWhere): UpdateSeriesMutationResponse!
}

"""Pagination information (Relay)"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  genres(options: GenreOptions, where: GenreWhere): [Genre!]!
  genresAggregate(where: GenreWhere): GenreAggregateSelection!
  genresConnection(after: String, first: Int, sort: [GenreSort], where: GenreWhere): GenresConnection!
  iProducts(options: IProductOptions, where: IProductWhere): [IProduct!]!
  iProductsAggregate(where: IProductWhere): IProductAggregateSelection!
  iProductsConnection(after: String, first: Int, sort: [IProductSort], where: IProductWhere): IProductsConnection!
  movies(options: MovieOptions, where: MovieWhere): [Movie!]!
  moviesAggregate(where: MovieWhere): MovieAggregateSelection!
  moviesConnection(after: String, first: Int, sort: [MovieSort], where: MovieWhere): MoviesConnection!
  ratings(options: RatingOptions, where: RatingWhere): [Rating!]!
  ratingsAggregate(where: RatingWhere): RatingAggregateSelection!
  ratingsConnection(after: String, first: Int, sort: [RatingSort], where: RatingWhere): RatingsConnection!
  series(options: SeriesOptions, where: SeriesWhere): [Series!]!
  seriesAggregate(where: SeriesWhere): SeriesAggregateSelection!
  seriesConnection(after: String, first: Int, sort: [SeriesSort], where: SeriesWhere): SeriesConnection!
  uGenres(options: QueryOptions, where: UGenreWhere): [UGenre!]!
}

"""Input type for options that can be specified on a query operation."""
input QueryOptions {
  limit: Int
  offset: Int
}

type Rating {
  number: Int!
  product(directed: Boolean = true, options: IProductOptions, where: IProductWhere): [IProduct!]!
  productAggregate(directed: Boolean = true, where: IProductWhere): RatingIProductProductAggregationSelection
  productConnection(after: String, directed: Boolean = true, first: Int, sort: [RatingProductConnectionSort!], where: RatingProductConnectionWhere): RatingProductConnection!
}

type RatingAggregateSelection {
  count: Int!
  number: IntAggregateSelection!
}

input RatingConnectInput {
  product: [RatingProductConnectFieldInput!]
}

input RatingConnectOrCreateWhere {
  node: RatingUniqueWhere!
}

input RatingConnectWhere {
  node: RatingWhere!
}

type RatingConnectedRelationships {
  product: RatingProductConnectedRelationship
}

input RatingCreateInput {
  number: Int!
  product: RatingProductFieldInput
}

type RatingCreatedEvent {
  createdRating: RatingEventPayload!
  event: EventType!
  timestamp: Float!
}

input RatingDeleteInput {
  product: [RatingProductDeleteFieldInput!]
}

type RatingDeletedEvent {
  deletedRating: RatingEventPayload!
  event: EventType!
  timestamp: Float!
}

input RatingDisconnectInput {
  product: [RatingProductDisconnectFieldInput!]
}

type RatingEdge {
  cursor: String!
  node: Rating!
}

type RatingEventPayload {
  number: Int!
}

type RatingIProductProductAggregationSelection {
  count: Int!
  node: RatingIProductProductNodeAggregateSelection
}

type RatingIProductProductNodeAggregateSelection {
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input RatingOnCreateInput {
  number: Int!
}

input RatingOptions {
  limit: Int
  offset: Int
  """
  Specify one or more RatingSort objects to sort Ratings by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [RatingSort!]
}

input RatingProductAggregateInput {
  AND: [RatingProductAggregateInput!]
  NOT: RatingProductAggregateInput
  OR: [RatingProductAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: RatingProductNodeAggregationWhereInput
}

input RatingProductConnectFieldInput {
  connect: IProductConnectInput
  where: IProductConnectWhere
}

type RatingProductConnectedRelationship {
  node: IProductEventPayload!
}

type RatingProductConnection {
  edges: [RatingProductRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input RatingProductConnectionSort {
  node: IProductSort
}

input RatingProductConnectionWhere {
  AND: [RatingProductConnectionWhere!]
  NOT: RatingProductConnectionWhere
  OR: [RatingProductConnectionWhere!]
  node: IProductWhere
}

input RatingProductCreateFieldInput {
  node: IProductCreateInput!
}

input RatingProductDeleteFieldInput {
  delete: IProductDeleteInput
  where: RatingProductConnectionWhere
}

input RatingProductDisconnectFieldInput {
  disconnect: IProductDisconnectInput
  where: RatingProductConnectionWhere
}

input RatingProductFieldInput {
  connect: [RatingProductConnectFieldInput!]
  create: [RatingProductCreateFieldInput!]
}

input RatingProductNodeAggregationWhereInput {
  AND: [RatingProductNodeAggregationWhereInput!]
  NOT: RatingProductNodeAggregationWhereInput
  OR: [RatingProductNodeAggregationWhereInput!]
  id_AVERAGE_LENGTH_EQUAL: Float
  id_AVERAGE_LENGTH_GT: Float
  id_AVERAGE_LENGTH_GTE: Float
  id_AVERAGE_LENGTH_LT: Float
  id_AVERAGE_LENGTH_LTE: Float
  id_LONGEST_LENGTH_EQUAL: Int
  id_LONGEST_LENGTH_GT: Int
  id_LONGEST_LENGTH_GTE: Int
  id_LONGEST_LENGTH_LT: Int
  id_LONGEST_LENGTH_LTE: Int
  id_SHORTEST_LENGTH_EQUAL: Int
  id_SHORTEST_LENGTH_GT: Int
  id_SHORTEST_LENGTH_GTE: Int
  id_SHORTEST_LENGTH_LT: Int
  id_SHORTEST_LENGTH_LTE: Int
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

type RatingProductRelationship {
  cursor: String!
  node: IProduct!
}

input RatingProductRelationshipSubscriptionWhere {
  node: IProductSubscriptionWhere
}

input RatingProductUpdateConnectionInput {
  node: IProductUpdateInput
}

input RatingProductUpdateFieldInput {
  connect: [RatingProductConnectFieldInput!]
  create: [RatingProductCreateFieldInput!]
  delete: [RatingProductDeleteFieldInput!]
  disconnect: [RatingProductDisconnectFieldInput!]
  update: RatingProductUpdateConnectionInput
  where: RatingProductConnectionWhere
}

input RatingRelationInput {
  product: [RatingProductCreateFieldInput!]
}

type RatingRelationshipCreatedEvent {
  createdRelationship: RatingConnectedRelationships!
  event: EventType!
  rating: RatingEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input RatingRelationshipCreatedSubscriptionWhere {
  AND: [RatingRelationshipCreatedSubscriptionWhere!]
  NOT: RatingRelationshipCreatedSubscriptionWhere
  OR: [RatingRelationshipCreatedSubscriptionWhere!]
  createdRelationship: RatingRelationshipsSubscriptionWhere
  rating: RatingSubscriptionWhere
}

type RatingRelationshipDeletedEvent {
  deletedRelationship: RatingConnectedRelationships!
  event: EventType!
  rating: RatingEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input RatingRelationshipDeletedSubscriptionWhere {
  AND: [RatingRelationshipDeletedSubscriptionWhere!]
  NOT: RatingRelationshipDeletedSubscriptionWhere
  OR: [RatingRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: RatingRelationshipsSubscriptionWhere
  rating: RatingSubscriptionWhere
}

input RatingRelationshipsSubscriptionWhere {
  product: RatingProductRelationshipSubscriptionWhere
}

"""
Fields to sort Ratings by. The order in which sorts are applied is not guaranteed when specifying many fields in one RatingSort object.
"""
input RatingSort {
  number: SortDirection
}

input RatingSubscriptionWhere {
  AND: [RatingSubscriptionWhere!]
  NOT: RatingSubscriptionWhere
  OR: [RatingSubscriptionWhere!]
  number: Int
  number_GT: Int
  number_GTE: Int
  number_IN: [Int!]
  number_LT: Int
  number_LTE: Int
}

input RatingUniqueWhere {
  number: Int
}

input RatingUpdateInput {
  number: Int
  number_DECREMENT: Int
  number_INCREMENT: Int
  product: [RatingProductUpdateFieldInput!]
}

type RatingUpdatedEvent {
  event: EventType!
  previousState: RatingEventPayload!
  timestamp: Float!
  updatedRating: RatingEventPayload!
}

input RatingWhere {
  AND: [RatingWhere!]
  NOT: RatingWhere
  OR: [RatingWhere!]
  number: Int
  number_GT: Int
  number_GTE: Int
  number_IN: [Int!]
  number_LT: Int
  number_LTE: Int
  productAggregate: RatingProductAggregateInput
  """
  Return Ratings where all of the related RatingProductConnections match this filter
  """
  productConnection_ALL: RatingProductConnectionWhere
  """
  Return Ratings where none of the related RatingProductConnections match this filter
  """
  productConnection_NONE: RatingProductConnectionWhere
  """
  Return Ratings where one of the related RatingProductConnections match this filter
  """
  productConnection_SINGLE: RatingProductConnectionWhere
  """
  Return Ratings where some of the related RatingProductConnections match this filter
  """
  productConnection_SOME: RatingProductConnectionWhere
  """Return Ratings where all of the related IProducts match this filter"""
  product_ALL: IProductWhere
  """Return Ratings where none of the related IProducts match this filter"""
  product_NONE: IProductWhere
  """Return Ratings where one of the related IProducts match this filter"""
  product_SINGLE: IProductWhere
  """Return Ratings where some of the related IProducts match this filter"""
  product_SOME: IProductWhere
}

type RatingsConnection {
  edges: [RatingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Series implements IProduct {
  genre(directed: Boolean = true, options: QueryOptions, where: UGenreWhere): UGenre!
  genreConnection(after: String, directed: Boolean = true, first: Int, sort: [IProductGenreConnectionSort!], where: IProductGenreConnectionWhere): IProductGenreConnection!
  id: String!
  name: String!
}

type SeriesAggregateSelection {
  count: Int!
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input SeriesConnectInput {
  genre: SeriesGenreConnectInput
}

input SeriesConnectOrCreateInput {
  genre: SeriesGenreConnectOrCreateInput
}

type SeriesConnectedRelationships {
  genre: SeriesGenreConnectedRelationship
}

type SeriesConnection {
  edges: [SeriesEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input SeriesCreateInput {
  genre: SeriesGenreCreateInput
  id: String!
  name: String!
}

type SeriesCreatedEvent {
  createdSeries: SeriesEventPayload!
  event: EventType!
  timestamp: Float!
}

input SeriesDeleteInput {
  genre: SeriesGenreDeleteInput
}

type SeriesDeletedEvent {
  deletedSeries: SeriesEventPayload!
  event: EventType!
  timestamp: Float!
}

input SeriesDisconnectInput {
  genre: SeriesGenreDisconnectInput
}

type SeriesEdge {
  cursor: String!
  node: Series!
}

type SeriesEventPayload implements IProductEventPayload {
  id: String!
  name: String!
}

input SeriesGenreConnectInput {
  Genre: SeriesGenreGenreConnectFieldInput
  Rating: SeriesGenreRatingConnectFieldInput
}

input SeriesGenreConnectOrCreateInput {
  Genre: SeriesGenreGenreConnectOrCreateFieldInput
  Rating: SeriesGenreRatingConnectOrCreateFieldInput
}

type SeriesGenreConnectedRelationship {
  episodes: Int
  node: UGenreEventPayload!
}

input SeriesGenreCreateFieldInput {
  Genre: SeriesGenreGenreCreateFieldInput
  Rating: SeriesGenreRatingCreateFieldInput
}

input SeriesGenreCreateInput {
  Genre: SeriesGenreGenreFieldInput
  Rating: SeriesGenreRatingFieldInput
}

input SeriesGenreDeleteInput {
  Genre: IProductGenreGenreDeleteFieldInput
  Rating: IProductGenreRatingDeleteFieldInput
}

input SeriesGenreDisconnectInput {
  Genre: IProductGenreGenreDisconnectFieldInput
  Rating: IProductGenreRatingDisconnectFieldInput
}

input SeriesGenreGenreConnectFieldInput {
  connect: GenreConnectInput
  edge: SeriesPropsCreateInput
  where: GenreConnectWhere
}

input SeriesGenreGenreConnectOrCreateFieldInput {
  onCreate: SeriesGenreGenreConnectOrCreateFieldInputOnCreate!
  where: GenreConnectOrCreateWhere!
}

input SeriesGenreGenreConnectOrCreateFieldInputOnCreate {
  edge: SeriesPropsCreateInput
  node: GenreOnCreateInput!
}

input SeriesGenreGenreCreateFieldInput {
  edge: SeriesPropsCreateInput
  node: GenreCreateInput!
}

input SeriesGenreGenreFieldInput {
  connect: SeriesGenreGenreConnectFieldInput
  connectOrCreate: SeriesGenreGenreConnectOrCreateFieldInput
  create: SeriesGenreGenreCreateFieldInput
}

input SeriesGenreGenreSubscriptionWhere {
  edge: SeriesPropsSubscriptionWhere
  node: GenreSubscriptionWhere
}

input SeriesGenreGenreUpdateConnectionInput {
  edge: SeriesPropsUpdateInput
  node: GenreUpdateInput
}

input SeriesGenreGenreUpdateFieldInput {
  connect: SeriesGenreGenreConnectFieldInput
  connectOrCreate: SeriesGenreGenreConnectOrCreateFieldInput
  create: SeriesGenreGenreCreateFieldInput
  delete: IProductGenreGenreDeleteFieldInput
  disconnect: IProductGenreGenreDisconnectFieldInput
  update: SeriesGenreGenreUpdateConnectionInput
  where: IProductGenreGenreConnectionWhere
}

input SeriesGenreRatingConnectFieldInput {
  connect: RatingConnectInput
  edge: SeriesPropsCreateInput
  where: RatingConnectWhere
}

input SeriesGenreRatingConnectOrCreateFieldInput {
  onCreate: SeriesGenreRatingConnectOrCreateFieldInputOnCreate!
  where: RatingConnectOrCreateWhere!
}

input SeriesGenreRatingConnectOrCreateFieldInputOnCreate {
  edge: SeriesPropsCreateInput
  node: RatingOnCreateInput!
}

input SeriesGenreRatingCreateFieldInput {
  edge: SeriesPropsCreateInput
  node: RatingCreateInput!
}

input SeriesGenreRatingFieldInput {
  connect: SeriesGenreRatingConnectFieldInput
  connectOrCreate: SeriesGenreRatingConnectOrCreateFieldInput
  create: SeriesGenreRatingCreateFieldInput
}

input SeriesGenreRatingSubscriptionWhere {
  edge: SeriesPropsSubscriptionWhere
  node: RatingSubscriptionWhere
}

input SeriesGenreRatingUpdateConnectionInput {
  edge: SeriesPropsUpdateInput
  node: RatingUpdateInput
}

input SeriesGenreRatingUpdateFieldInput {
  connect: SeriesGenreRatingConnectFieldInput
  connectOrCreate: SeriesGenreRatingConnectOrCreateFieldInput
  create: SeriesGenreRatingCreateFieldInput
  delete: IProductGenreRatingDeleteFieldInput
  disconnect: IProductGenreRatingDisconnectFieldInput
  update: SeriesGenreRatingUpdateConnectionInput
  where: IProductGenreRatingConnectionWhere
}

input SeriesGenreRelationshipSubscriptionWhere {
  Genre: SeriesGenreGenreSubscriptionWhere
  Rating: SeriesGenreRatingSubscriptionWhere
}

input SeriesGenreUpdateInput {
  Genre: SeriesGenreGenreUpdateFieldInput
  Rating: SeriesGenreRatingUpdateFieldInput
}

input SeriesOptions {
  limit: Int
  offset: Int
  """
  Specify one or more SeriesSort objects to sort Series by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [SeriesSort!]
}

"""
The edge properties for the following fields:
* Series.genre
"""
type SeriesProps {
  episodes: Int
}

input SeriesPropsCreateInput {
  episodes: Int
}

input SeriesPropsSort {
  episodes: SortDirection
}

input SeriesPropsSubscriptionWhere {
  AND: [SeriesPropsSubscriptionWhere!]
  NOT: SeriesPropsSubscriptionWhere
  OR: [SeriesPropsSubscriptionWhere!]
  episodes: Int
  episodes_GT: Int
  episodes_GTE: Int
  episodes_IN: [Int]
  episodes_LT: Int
  episodes_LTE: Int
}

input SeriesPropsUpdateInput {
  episodes: Int
  episodes_DECREMENT: Int
  episodes_INCREMENT: Int
}

input SeriesPropsWhere {
  AND: [SeriesPropsWhere!]
  NOT: SeriesPropsWhere
  OR: [SeriesPropsWhere!]
  episodes: Int
  episodes_GT: Int
  episodes_GTE: Int
  episodes_IN: [Int]
  episodes_LT: Int
  episodes_LTE: Int
}

input SeriesRelationInput {
  genre: SeriesGenreCreateFieldInput
}

type SeriesRelationshipCreatedEvent {
  createdRelationship: SeriesConnectedRelationships!
  event: EventType!
  relationshipFieldName: String!
  series: SeriesEventPayload!
  timestamp: Float!
}

input SeriesRelationshipCreatedSubscriptionWhere {
  AND: [SeriesRelationshipCreatedSubscriptionWhere!]
  NOT: SeriesRelationshipCreatedSubscriptionWhere
  OR: [SeriesRelationshipCreatedSubscriptionWhere!]
  createdRelationship: SeriesRelationshipsSubscriptionWhere
  series: SeriesSubscriptionWhere
}

type SeriesRelationshipDeletedEvent {
  deletedRelationship: SeriesConnectedRelationships!
  event: EventType!
  relationshipFieldName: String!
  series: SeriesEventPayload!
  timestamp: Float!
}

input SeriesRelationshipDeletedSubscriptionWhere {
  AND: [SeriesRelationshipDeletedSubscriptionWhere!]
  NOT: SeriesRelationshipDeletedSubscriptionWhere
  OR: [SeriesRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: SeriesRelationshipsSubscriptionWhere
  series: SeriesSubscriptionWhere
}

input SeriesRelationshipsSubscriptionWhere {
  genre: SeriesGenreRelationshipSubscriptionWhere
}

"""
Fields to sort Series by. The order in which sorts are applied is not guaranteed when specifying many fields in one SeriesSort object.
"""
input SeriesSort {
  id: SortDirection
  name: SortDirection
}

input SeriesSubscriptionWhere {
  AND: [SeriesSubscriptionWhere!]
  NOT: SeriesSubscriptionWhere
  OR: [SeriesSubscriptionWhere!]
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

input SeriesUpdateInput {
  genre: SeriesGenreUpdateInput
  id: String
  name: String
}

type SeriesUpdatedEvent {
  event: EventType!
  previousState: SeriesEventPayload!
  timestamp: Float!
  updatedSeries: SeriesEventPayload!
}

input SeriesWhere {
  AND: [SeriesWhere!]
  NOT: SeriesWhere
  OR: [SeriesWhere!]
  genre: UGenreWhere
  genreConnection: IProductGenreConnectionWhere
  genreConnection_NOT: IProductGenreConnectionWhere
  genre_NOT: UGenreWhere
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

"""An enum for sorting in either ascending or descending order."""
enum SortDirection {
  """Sort by field values in ascending order."""
  ASC
  """Sort by field values in descending order."""
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type Subscription {
  genreCreated(where: GenreSubscriptionWhere): GenreCreatedEvent!
  genreDeleted(where: GenreSubscriptionWhere): GenreDeletedEvent!
  genreRelationshipCreated(where: GenreRelationshipCreatedSubscriptionWhere): GenreRelationshipCreatedEvent!
  genreRelationshipDeleted(where: GenreRelationshipDeletedSubscriptionWhere): GenreRelationshipDeletedEvent!
  genreUpdated(where: GenreSubscriptionWhere): GenreUpdatedEvent!
  movieCreated(where: MovieSubscriptionWhere): MovieCreatedEvent!
  movieDeleted(where: MovieSubscriptionWhere): MovieDeletedEvent!
  movieRelationshipCreated(where: MovieRelationshipCreatedSubscriptionWhere): MovieRelationshipCreatedEvent!
  movieRelationshipDeleted(where: MovieRelationshipDeletedSubscriptionWhere): MovieRelationshipDeletedEvent!
  movieUpdated(where: MovieSubscriptionWhere): MovieUpdatedEvent!
  ratingCreated(where: RatingSubscriptionWhere): RatingCreatedEvent!
  ratingDeleted(where: RatingSubscriptionWhere): RatingDeletedEvent!
  ratingRelationshipCreated(where: RatingRelationshipCreatedSubscriptionWhere): RatingRelationshipCreatedEvent!
  ratingRelationshipDeleted(where: RatingRelationshipDeletedSubscriptionWhere): RatingRelationshipDeletedEvent!
  ratingUpdated(where: RatingSubscriptionWhere): RatingUpdatedEvent!
  seriesCreated(where: SeriesSubscriptionWhere): SeriesCreatedEvent!
  seriesDeleted(where: SeriesSubscriptionWhere): SeriesDeletedEvent!
  seriesRelationshipCreated(where: SeriesRelationshipCreatedSubscriptionWhere): SeriesRelationshipCreatedEvent!
  seriesRelationshipDeleted(where: SeriesRelationshipDeletedSubscriptionWhere): SeriesRelationshipDeletedEvent!
  seriesUpdated(where: SeriesSubscriptionWhere): SeriesUpdatedEvent!
}

union UGenre = Genre | Rating

union UGenreEventPayload = GenreEventPayload | RatingEventPayload

input UGenreWhere {
  Genre: GenreWhere
  Rating: RatingWhere
}

type UpdateGenresMutationResponse {
  genres: [Genre!]!
  info: UpdateInfo!
}

"""
Information about the number of nodes and relationships created and deleted during an update mutation
"""
type UpdateInfo {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateMoviesMutationResponse {
  info: UpdateInfo!
  movies: [Movie!]!
}

type UpdateRatingsMutationResponse {
  info: UpdateInfo!
  ratings: [Rating!]!
}

type UpdateSeriesMutationResponse {
  info: UpdateInfo!
  series: [Series!]!
}
----

'''
