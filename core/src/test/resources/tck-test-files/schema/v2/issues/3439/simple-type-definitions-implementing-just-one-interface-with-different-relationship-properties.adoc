:toc:

= https://github.com/neo4j/graphql/issues/3439 -> Simple type definitions implementing just one interface with different relationship properties

== Source schema

[source,graphql,schema=true]
----
interface IProduct {
  id: String!
  name: String!
  genre: Genre! @declareRelationship
}

type Movie implements IProduct {
  id: String!
  name: String!
  genre: Genre! @relationship(type: "HAS_GENRE", direction: OUT, properties: "MovieProps")
}

type Series implements IProduct {
  id: String!
  name: String!
  genre: Genre! @relationship(type: "HAS_GENRE", direction: OUT, properties: "SeriesProps")
}

type MovieProps @relationshipProperties {
  year: Int!
}

type SeriesProps @relationshipProperties {
  episodes: Int
}

type Genre {
  name: String! @unique
  product: [IProduct!]! @relationship(type: "HAS_GENRE", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "features": {
    "subscriptions": true
  }
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type CreateGenresMutationResponse {
  genres: [Genre!]!
  info: CreateInfo!
}

"""
Information about the number of nodes and relationships created during a create mutation
"""
type CreateInfo {
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateMoviesMutationResponse {
  info: CreateInfo!
  movies: [Movie!]!
}

type CreateSeriesMutationResponse {
  info: CreateInfo!
  series: [Series!]!
}

"""
Information about the number of nodes and relationships deleted during a delete mutation
"""
type DeleteInfo {
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

enum EventType {
  CREATE
  CREATE_RELATIONSHIP
  DELETE
  DELETE_RELATIONSHIP
  UPDATE
}

type Genre {
  name: String!
  product(directed: Boolean = true, options: IProductOptions, where: IProductWhere): [IProduct!]!
  productAggregate(directed: Boolean = true, where: IProductWhere): GenreIProductProductAggregationSelection
  productConnection(after: String, directed: Boolean = true, first: Int, sort: [GenreProductConnectionSort!], where: GenreProductConnectionWhere): GenreProductConnection!
}

type GenreAggregateSelection {
  count: Int!
  name: StringAggregateSelection!
}

input GenreConnectInput {
  product: [GenreProductConnectFieldInput!]
}

input GenreConnectOrCreateWhere {
  node: GenreUniqueWhere!
}

input GenreConnectWhere {
  node: GenreWhere!
}

type GenreConnectedRelationships {
  product: GenreProductConnectedRelationship
}

input GenreCreateInput {
  name: String!
  product: GenreProductFieldInput
}

type GenreCreatedEvent {
  createdGenre: GenreEventPayload!
  event: EventType!
  timestamp: Float!
}

input GenreDeleteInput {
  product: [GenreProductDeleteFieldInput!]
}

type GenreDeletedEvent {
  deletedGenre: GenreEventPayload!
  event: EventType!
  timestamp: Float!
}

input GenreDisconnectInput {
  product: [GenreProductDisconnectFieldInput!]
}

type GenreEdge {
  cursor: String!
  node: Genre!
}

type GenreEventPayload {
  name: String!
}

type GenreIProductProductAggregationSelection {
  count: Int!
  node: GenreIProductProductNodeAggregateSelection
}

type GenreIProductProductNodeAggregateSelection {
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input GenreOnCreateInput {
  name: String!
}

input GenreOptions {
  limit: Int
  offset: Int
  """
  Specify one or more GenreSort objects to sort Genres by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [GenreSort!]
}

input GenreProductAggregateInput {
  AND: [GenreProductAggregateInput!]
  NOT: GenreProductAggregateInput
  OR: [GenreProductAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: GenreProductNodeAggregationWhereInput
}

input GenreProductConnectFieldInput {
  connect: IProductConnectInput
  where: IProductConnectWhere
}

type GenreProductConnectedRelationship {
  node: IProductEventPayload!
}

type GenreProductConnection {
  edges: [GenreProductRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input GenreProductConnectionSort {
  node: IProductSort
}

input GenreProductConnectionWhere {
  AND: [GenreProductConnectionWhere!]
  NOT: GenreProductConnectionWhere
  OR: [GenreProductConnectionWhere!]
  node: IProductWhere
}

input GenreProductCreateFieldInput {
  node: IProductCreateInput!
}

input GenreProductDeleteFieldInput {
  delete: IProductDeleteInput
  where: GenreProductConnectionWhere
}

input GenreProductDisconnectFieldInput {
  disconnect: IProductDisconnectInput
  where: GenreProductConnectionWhere
}

input GenreProductFieldInput {
  connect: [GenreProductConnectFieldInput!]
  create: [GenreProductCreateFieldInput!]
}

input GenreProductNodeAggregationWhereInput {
  AND: [GenreProductNodeAggregationWhereInput!]
  NOT: GenreProductNodeAggregationWhereInput
  OR: [GenreProductNodeAggregationWhereInput!]
  id_AVERAGE_LENGTH_EQUAL: Float
  id_AVERAGE_LENGTH_GT: Float
  id_AVERAGE_LENGTH_GTE: Float
  id_AVERAGE_LENGTH_LT: Float
  id_AVERAGE_LENGTH_LTE: Float
  id_LONGEST_LENGTH_EQUAL: Int
  id_LONGEST_LENGTH_GT: Int
  id_LONGEST_LENGTH_GTE: Int
  id_LONGEST_LENGTH_LT: Int
  id_LONGEST_LENGTH_LTE: Int
  id_SHORTEST_LENGTH_EQUAL: Int
  id_SHORTEST_LENGTH_GT: Int
  id_SHORTEST_LENGTH_GTE: Int
  id_SHORTEST_LENGTH_LT: Int
  id_SHORTEST_LENGTH_LTE: Int
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

type GenreProductRelationship {
  cursor: String!
  node: IProduct!
}

input GenreProductRelationshipSubscriptionWhere {
  node: IProductSubscriptionWhere
}

input GenreProductUpdateConnectionInput {
  node: IProductUpdateInput
}

input GenreProductUpdateFieldInput {
  connect: [GenreProductConnectFieldInput!]
  create: [GenreProductCreateFieldInput!]
  delete: [GenreProductDeleteFieldInput!]
  disconnect: [GenreProductDisconnectFieldInput!]
  update: GenreProductUpdateConnectionInput
  where: GenreProductConnectionWhere
}

input GenreRelationInput {
  product: [GenreProductCreateFieldInput!]
}

type GenreRelationshipCreatedEvent {
  createdRelationship: GenreConnectedRelationships!
  event: EventType!
  genre: GenreEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input GenreRelationshipCreatedSubscriptionWhere {
  AND: [GenreRelationshipCreatedSubscriptionWhere!]
  NOT: GenreRelationshipCreatedSubscriptionWhere
  OR: [GenreRelationshipCreatedSubscriptionWhere!]
  createdRelationship: GenreRelationshipsSubscriptionWhere
  genre: GenreSubscriptionWhere
}

type GenreRelationshipDeletedEvent {
  deletedRelationship: GenreConnectedRelationships!
  event: EventType!
  genre: GenreEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input GenreRelationshipDeletedSubscriptionWhere {
  AND: [GenreRelationshipDeletedSubscriptionWhere!]
  NOT: GenreRelationshipDeletedSubscriptionWhere
  OR: [GenreRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: GenreRelationshipsSubscriptionWhere
  genre: GenreSubscriptionWhere
}

input GenreRelationshipsSubscriptionWhere {
  product: GenreProductRelationshipSubscriptionWhere
}

"""
Fields to sort Genres by. The order in which sorts are applied is not guaranteed when specifying many fields in one GenreSort object.
"""
input GenreSort {
  name: SortDirection
}

input GenreSubscriptionWhere {
  AND: [GenreSubscriptionWhere!]
  NOT: GenreSubscriptionWhere
  OR: [GenreSubscriptionWhere!]
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

input GenreUniqueWhere {
  name: String
}

input GenreUpdateInput {
  name: String
  product: [GenreProductUpdateFieldInput!]
}

type GenreUpdatedEvent {
  event: EventType!
  previousState: GenreEventPayload!
  timestamp: Float!
  updatedGenre: GenreEventPayload!
}

input GenreWhere {
  AND: [GenreWhere!]
  NOT: GenreWhere
  OR: [GenreWhere!]
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
  productAggregate: GenreProductAggregateInput
  """
  Return Genres where all of the related GenreProductConnections match this filter
  """
  productConnection_ALL: GenreProductConnectionWhere
  """
  Return Genres where none of the related GenreProductConnections match this filter
  """
  productConnection_NONE: GenreProductConnectionWhere
  """
  Return Genres where one of the related GenreProductConnections match this filter
  """
  productConnection_SINGLE: GenreProductConnectionWhere
  """
  Return Genres where some of the related GenreProductConnections match this filter
  """
  productConnection_SOME: GenreProductConnectionWhere
  """Return Genres where all of the related IProducts match this filter"""
  product_ALL: IProductWhere
  """Return Genres where none of the related IProducts match this filter"""
  product_NONE: IProductWhere
  """Return Genres where one of the related IProducts match this filter"""
  product_SINGLE: IProductWhere
  """Return Genres where some of the related IProducts match this filter"""
  product_SOME: IProductWhere
}

type GenresConnection {
  edges: [GenreEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

interface IProduct {
  genre(options: GenreOptions, where: GenreWhere): Genre!
  genreConnection(after: String, first: Int, sort: [IProductGenreConnectionSort!], where: IProductGenreConnectionWhere): IProductGenreConnection!
  id: String!
  name: String!
}

type IProductAggregateSelection {
  count: Int!
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input IProductConnectInput {
  genre: IProductGenreConnectFieldInput
}

input IProductConnectWhere {
  node: IProductWhere!
}

input IProductCreateInput {
  Movie: MovieCreateInput
  Series: SeriesCreateInput
}

input IProductDeleteInput {
  genre: IProductGenreDeleteFieldInput
}

input IProductDisconnectInput {
  genre: IProductGenreDisconnectFieldInput
}

type IProductEdge {
  cursor: String!
  node: IProduct!
}

interface IProductEventPayload {
  id: String!
  name: String!
}

input IProductGenreAggregateInput {
  AND: [IProductGenreAggregateInput!]
  NOT: IProductGenreAggregateInput
  OR: [IProductGenreAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: IProductGenreEdgeAggregationWhereInput
  node: IProductGenreNodeAggregationWhereInput
}

input IProductGenreConnectFieldInput {
  connect: GenreConnectInput
  edge: IProductGenreEdgeCreateInput!
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: GenreConnectWhere
}

input IProductGenreConnectOrCreateFieldInput {
  onCreate: IProductGenreConnectOrCreateFieldInputOnCreate!
  where: GenreConnectOrCreateWhere!
}

input IProductGenreConnectOrCreateFieldInputOnCreate {
  edge: IProductGenreEdgeCreateInput!
  node: GenreOnCreateInput!
}

type IProductGenreConnection {
  edges: [IProductGenreRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input IProductGenreConnectionSort {
  edge: IProductGenreEdgeSort
  node: GenreSort
}

input IProductGenreConnectionWhere {
  AND: [IProductGenreConnectionWhere!]
  NOT: IProductGenreConnectionWhere
  OR: [IProductGenreConnectionWhere!]
  edge: IProductGenreEdgeWhere
  node: GenreWhere
}

input IProductGenreCreateFieldInput {
  edge: IProductGenreEdgeCreateInput!
  node: GenreCreateInput!
}

input IProductGenreDeleteFieldInput {
  delete: GenreDeleteInput
  where: IProductGenreConnectionWhere
}

input IProductGenreDisconnectFieldInput {
  disconnect: GenreDisconnectInput
  where: IProductGenreConnectionWhere
}

input IProductGenreEdgeAggregationWhereInput {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsAggregationWhereInput
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsAggregationWhereInput
}

input IProductGenreEdgeCreateInput {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsCreateInput!
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsCreateInput
}

input IProductGenreEdgeSort {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsSort
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsSort
}

input IProductGenreEdgeUpdateInput {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsUpdateInput
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsUpdateInput
}

input IProductGenreEdgeWhere {
  """
  Relationship properties when source node is of type:
  * Movie
  """
  MovieProps: MoviePropsWhere
  """
  Relationship properties when source node is of type:
  * Series
  """
  SeriesProps: SeriesPropsWhere
}

input IProductGenreNodeAggregationWhereInput {
  AND: [IProductGenreNodeAggregationWhereInput!]
  NOT: IProductGenreNodeAggregationWhereInput
  OR: [IProductGenreNodeAggregationWhereInput!]
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

type IProductGenreRelationship {
  cursor: String!
  node: Genre!
  properties: IProductGenreRelationshipProperties!
}

union IProductGenreRelationshipProperties = MovieProps | SeriesProps

input IProductGenreUpdateConnectionInput {
  edge: IProductGenreEdgeUpdateInput
  node: GenreUpdateInput
}

input IProductGenreUpdateFieldInput {
  connect: IProductGenreConnectFieldInput
  connectOrCreate: IProductGenreConnectOrCreateFieldInput
  create: IProductGenreCreateFieldInput
  delete: IProductGenreDeleteFieldInput
  disconnect: IProductGenreDisconnectFieldInput
  update: IProductGenreUpdateConnectionInput
  where: IProductGenreConnectionWhere
}

enum IProductImplementation {
  Movie
  Series
}

input IProductOptions {
  limit: Int
  offset: Int
  """
  Specify one or more IProductSort objects to sort IProducts by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [IProductSort]
}

"""
Fields to sort IProducts by. The order in which sorts are applied is not guaranteed when specifying many fields in one IProductSort object.
"""
input IProductSort {
  id: SortDirection
  name: SortDirection
}

input IProductSubscriptionWhere {
  AND: [IProductSubscriptionWhere!]
  NOT: IProductSubscriptionWhere
  OR: [IProductSubscriptionWhere!]
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
  typename_IN: [IProductImplementation!]
}

input IProductUpdateInput {
  genre: IProductGenreUpdateFieldInput
  id: String
  name: String
}

input IProductWhere {
  AND: [IProductWhere!]
  NOT: IProductWhere
  OR: [IProductWhere!]
  genre: GenreWhere
  genreAggregate: IProductGenreAggregateInput
  genreConnection: IProductGenreConnectionWhere
  genreConnection_NOT: IProductGenreConnectionWhere
  genre_NOT: GenreWhere
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
  typename_IN: [IProductImplementation!]
}

type IProductsConnection {
  edges: [IProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IntAggregateSelection {
  average: Float
  max: Int
  min: Int
  sum: Int
}

type Movie implements IProduct {
  genre(directed: Boolean = true, options: GenreOptions, where: GenreWhere): Genre!
  genreAggregate(directed: Boolean = true, where: GenreWhere): MovieGenreGenreAggregationSelection
  genreConnection(after: String, directed: Boolean = true, first: Int, sort: [IProductGenreConnectionSort!], where: IProductGenreConnectionWhere): IProductGenreConnection!
  id: String!
  name: String!
}

type MovieAggregateSelection {
  count: Int!
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input MovieConnectInput {
  genre: MovieGenreConnectFieldInput
}

input MovieConnectOrCreateInput {
  genre: MovieGenreConnectOrCreateFieldInput
}

type MovieConnectedRelationships {
  genre: MovieGenreConnectedRelationship
}

input MovieCreateInput {
  genre: MovieGenreFieldInput
  id: String!
  name: String!
}

type MovieCreatedEvent {
  createdMovie: MovieEventPayload!
  event: EventType!
  timestamp: Float!
}

input MovieDeleteInput {
  genre: IProductGenreDeleteFieldInput
}

type MovieDeletedEvent {
  deletedMovie: MovieEventPayload!
  event: EventType!
  timestamp: Float!
}

input MovieDisconnectInput {
  genre: IProductGenreDisconnectFieldInput
}

type MovieEdge {
  cursor: String!
  node: Movie!
}

type MovieEventPayload implements IProductEventPayload {
  id: String!
  name: String!
}

input MovieGenreAggregateInput {
  AND: [MovieGenreAggregateInput!]
  NOT: MovieGenreAggregateInput
  OR: [MovieGenreAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: MoviePropsAggregationWhereInput
  node: MovieGenreNodeAggregationWhereInput
}

input MovieGenreConnectFieldInput {
  connect: GenreConnectInput
  edge: MoviePropsCreateInput!
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: GenreConnectWhere
}

input MovieGenreConnectOrCreateFieldInput {
  onCreate: MovieGenreConnectOrCreateFieldInputOnCreate!
  where: GenreConnectOrCreateWhere!
}

input MovieGenreConnectOrCreateFieldInputOnCreate {
  edge: MoviePropsCreateInput!
  node: GenreOnCreateInput!
}

type MovieGenreConnectedRelationship {
  node: GenreEventPayload!
  year: Int!
}

input MovieGenreCreateFieldInput {
  edge: MoviePropsCreateInput!
  node: GenreCreateInput!
}

input MovieGenreFieldInput {
  connect: MovieGenreConnectFieldInput
  connectOrCreate: MovieGenreConnectOrCreateFieldInput
  create: MovieGenreCreateFieldInput
}

type MovieGenreGenreAggregationSelection {
  count: Int!
  edge: MovieGenreGenreEdgeAggregateSelection
  node: MovieGenreGenreNodeAggregateSelection
}

type MovieGenreGenreEdgeAggregateSelection {
  year: IntAggregateSelection!
}

type MovieGenreGenreNodeAggregateSelection {
  name: StringAggregateSelection!
}

input MovieGenreNodeAggregationWhereInput {
  AND: [MovieGenreNodeAggregationWhereInput!]
  NOT: MovieGenreNodeAggregationWhereInput
  OR: [MovieGenreNodeAggregationWhereInput!]
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

input MovieGenreRelationshipSubscriptionWhere {
  edge: MoviePropsSubscriptionWhere
  node: GenreSubscriptionWhere
}

input MovieGenreUpdateConnectionInput {
  edge: MoviePropsUpdateInput
  node: GenreUpdateInput
}

input MovieGenreUpdateFieldInput {
  connect: MovieGenreConnectFieldInput
  connectOrCreate: MovieGenreConnectOrCreateFieldInput
  create: MovieGenreCreateFieldInput
  delete: IProductGenreDeleteFieldInput
  disconnect: IProductGenreDisconnectFieldInput
  update: MovieGenreUpdateConnectionInput
  where: IProductGenreConnectionWhere
}

input MovieOptions {
  limit: Int
  offset: Int
  """
  Specify one or more MovieSort objects to sort Movies by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [MovieSort!]
}

"""
The edge properties for the following fields:
* Movie.genre
"""
type MovieProps {
  year: Int!
}

input MoviePropsAggregationWhereInput {
  AND: [MoviePropsAggregationWhereInput!]
  NOT: MoviePropsAggregationWhereInput
  OR: [MoviePropsAggregationWhereInput!]
  year_AVERAGE_EQUAL: Float
  year_AVERAGE_GT: Float
  year_AVERAGE_GTE: Float
  year_AVERAGE_LT: Float
  year_AVERAGE_LTE: Float
  year_MAX_EQUAL: Int
  year_MAX_GT: Int
  year_MAX_GTE: Int
  year_MAX_LT: Int
  year_MAX_LTE: Int
  year_MIN_EQUAL: Int
  year_MIN_GT: Int
  year_MIN_GTE: Int
  year_MIN_LT: Int
  year_MIN_LTE: Int
  year_SUM_EQUAL: Int
  year_SUM_GT: Int
  year_SUM_GTE: Int
  year_SUM_LT: Int
  year_SUM_LTE: Int
}

input MoviePropsCreateInput {
  year: Int!
}

input MoviePropsSort {
  year: SortDirection
}

input MoviePropsSubscriptionWhere {
  AND: [MoviePropsSubscriptionWhere!]
  NOT: MoviePropsSubscriptionWhere
  OR: [MoviePropsSubscriptionWhere!]
  year: Int
  year_GT: Int
  year_GTE: Int
  year_IN: [Int!]
  year_LT: Int
  year_LTE: Int
}

input MoviePropsUpdateInput {
  year: Int
  year_DECREMENT: Int
  year_INCREMENT: Int
}

input MoviePropsWhere {
  AND: [MoviePropsWhere!]
  NOT: MoviePropsWhere
  OR: [MoviePropsWhere!]
  year: Int
  year_GT: Int
  year_GTE: Int
  year_IN: [Int!]
  year_LT: Int
  year_LTE: Int
}

input MovieRelationInput {
  genre: MovieGenreCreateFieldInput
}

type MovieRelationshipCreatedEvent {
  createdRelationship: MovieConnectedRelationships!
  event: EventType!
  movie: MovieEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input MovieRelationshipCreatedSubscriptionWhere {
  AND: [MovieRelationshipCreatedSubscriptionWhere!]
  NOT: MovieRelationshipCreatedSubscriptionWhere
  OR: [MovieRelationshipCreatedSubscriptionWhere!]
  createdRelationship: MovieRelationshipsSubscriptionWhere
  movie: MovieSubscriptionWhere
}

type MovieRelationshipDeletedEvent {
  deletedRelationship: MovieConnectedRelationships!
  event: EventType!
  movie: MovieEventPayload!
  relationshipFieldName: String!
  timestamp: Float!
}

input MovieRelationshipDeletedSubscriptionWhere {
  AND: [MovieRelationshipDeletedSubscriptionWhere!]
  NOT: MovieRelationshipDeletedSubscriptionWhere
  OR: [MovieRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: MovieRelationshipsSubscriptionWhere
  movie: MovieSubscriptionWhere
}

input MovieRelationshipsSubscriptionWhere {
  genre: MovieGenreRelationshipSubscriptionWhere
}

"""
Fields to sort Movies by. The order in which sorts are applied is not guaranteed when specifying many fields in one MovieSort object.
"""
input MovieSort {
  id: SortDirection
  name: SortDirection
}

input MovieSubscriptionWhere {
  AND: [MovieSubscriptionWhere!]
  NOT: MovieSubscriptionWhere
  OR: [MovieSubscriptionWhere!]
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

input MovieUpdateInput {
  genre: MovieGenreUpdateFieldInput
  id: String
  name: String
}

type MovieUpdatedEvent {
  event: EventType!
  previousState: MovieEventPayload!
  timestamp: Float!
  updatedMovie: MovieEventPayload!
}

input MovieWhere {
  AND: [MovieWhere!]
  NOT: MovieWhere
  OR: [MovieWhere!]
  genre: GenreWhere
  genreAggregate: MovieGenreAggregateInput
  genreConnection: IProductGenreConnectionWhere
  genreConnection_NOT: IProductGenreConnectionWhere
  genre_NOT: GenreWhere
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

type MoviesConnection {
  edges: [MovieEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Mutation {
  createGenres(input: [GenreCreateInput!]!): CreateGenresMutationResponse!
  createMovies(input: [MovieCreateInput!]!): CreateMoviesMutationResponse!
  createSeries(input: [SeriesCreateInput!]!): CreateSeriesMutationResponse!
  deleteGenres(delete: GenreDeleteInput, where: GenreWhere): DeleteInfo!
  deleteMovies(delete: MovieDeleteInput, where: MovieWhere): DeleteInfo!
  deleteSeries(delete: SeriesDeleteInput, where: SeriesWhere): DeleteInfo!
  updateGenres(connect: GenreConnectInput, create: GenreRelationInput, delete: GenreDeleteInput, disconnect: GenreDisconnectInput, update: GenreUpdateInput, where: GenreWhere): UpdateGenresMutationResponse!
  updateMovies(connect: MovieConnectInput, connectOrCreate: MovieConnectOrCreateInput, create: MovieRelationInput, delete: MovieDeleteInput, disconnect: MovieDisconnectInput, update: MovieUpdateInput, where: MovieWhere): UpdateMoviesMutationResponse!
  updateSeries(connect: SeriesConnectInput, connectOrCreate: SeriesConnectOrCreateInput, create: SeriesRelationInput, delete: SeriesDeleteInput, disconnect: SeriesDisconnectInput, update: SeriesUpdateInput, where: SeriesWhere): UpdateSeriesMutationResponse!
}

"""Pagination information (Relay)"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  genres(options: GenreOptions, where: GenreWhere): [Genre!]!
  genresAggregate(where: GenreWhere): GenreAggregateSelection!
  genresConnection(after: String, first: Int, sort: [GenreSort], where: GenreWhere): GenresConnection!
  iProducts(options: IProductOptions, where: IProductWhere): [IProduct!]!
  iProductsAggregate(where: IProductWhere): IProductAggregateSelection!
  iProductsConnection(after: String, first: Int, sort: [IProductSort], where: IProductWhere): IProductsConnection!
  movies(options: MovieOptions, where: MovieWhere): [Movie!]!
  moviesAggregate(where: MovieWhere): MovieAggregateSelection!
  moviesConnection(after: String, first: Int, sort: [MovieSort], where: MovieWhere): MoviesConnection!
  series(options: SeriesOptions, where: SeriesWhere): [Series!]!
  seriesAggregate(where: SeriesWhere): SeriesAggregateSelection!
  seriesConnection(after: String, first: Int, sort: [SeriesSort], where: SeriesWhere): SeriesConnection!
}

type Series implements IProduct {
  genre(directed: Boolean = true, options: GenreOptions, where: GenreWhere): Genre!
  genreAggregate(directed: Boolean = true, where: GenreWhere): SeriesGenreGenreAggregationSelection
  genreConnection(after: String, directed: Boolean = true, first: Int, sort: [IProductGenreConnectionSort!], where: IProductGenreConnectionWhere): IProductGenreConnection!
  id: String!
  name: String!
}

type SeriesAggregateSelection {
  count: Int!
  id: StringAggregateSelection!
  name: StringAggregateSelection!
}

input SeriesConnectInput {
  genre: SeriesGenreConnectFieldInput
}

input SeriesConnectOrCreateInput {
  genre: SeriesGenreConnectOrCreateFieldInput
}

type SeriesConnectedRelationships {
  genre: SeriesGenreConnectedRelationship
}

type SeriesConnection {
  edges: [SeriesEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input SeriesCreateInput {
  genre: SeriesGenreFieldInput
  id: String!
  name: String!
}

type SeriesCreatedEvent {
  createdSeries: SeriesEventPayload!
  event: EventType!
  timestamp: Float!
}

input SeriesDeleteInput {
  genre: IProductGenreDeleteFieldInput
}

type SeriesDeletedEvent {
  deletedSeries: SeriesEventPayload!
  event: EventType!
  timestamp: Float!
}

input SeriesDisconnectInput {
  genre: IProductGenreDisconnectFieldInput
}

type SeriesEdge {
  cursor: String!
  node: Series!
}

type SeriesEventPayload implements IProductEventPayload {
  id: String!
  name: String!
}

input SeriesGenreAggregateInput {
  AND: [SeriesGenreAggregateInput!]
  NOT: SeriesGenreAggregateInput
  OR: [SeriesGenreAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: SeriesPropsAggregationWhereInput
  node: SeriesGenreNodeAggregationWhereInput
}

input SeriesGenreConnectFieldInput {
  connect: GenreConnectInput
  edge: SeriesPropsCreateInput
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: GenreConnectWhere
}

input SeriesGenreConnectOrCreateFieldInput {
  onCreate: SeriesGenreConnectOrCreateFieldInputOnCreate!
  where: GenreConnectOrCreateWhere!
}

input SeriesGenreConnectOrCreateFieldInputOnCreate {
  edge: SeriesPropsCreateInput
  node: GenreOnCreateInput!
}

type SeriesGenreConnectedRelationship {
  episodes: Int
  node: GenreEventPayload!
}

input SeriesGenreCreateFieldInput {
  edge: SeriesPropsCreateInput
  node: GenreCreateInput!
}

input SeriesGenreFieldInput {
  connect: SeriesGenreConnectFieldInput
  connectOrCreate: SeriesGenreConnectOrCreateFieldInput
  create: SeriesGenreCreateFieldInput
}

type SeriesGenreGenreAggregationSelection {
  count: Int!
  edge: SeriesGenreGenreEdgeAggregateSelection
  node: SeriesGenreGenreNodeAggregateSelection
}

type SeriesGenreGenreEdgeAggregateSelection {
  episodes: IntAggregateSelection!
}

type SeriesGenreGenreNodeAggregateSelection {
  name: StringAggregateSelection!
}

input SeriesGenreNodeAggregationWhereInput {
  AND: [SeriesGenreNodeAggregationWhereInput!]
  NOT: SeriesGenreNodeAggregationWhereInput
  OR: [SeriesGenreNodeAggregationWhereInput!]
  name_AVERAGE_LENGTH_EQUAL: Float
  name_AVERAGE_LENGTH_GT: Float
  name_AVERAGE_LENGTH_GTE: Float
  name_AVERAGE_LENGTH_LT: Float
  name_AVERAGE_LENGTH_LTE: Float
  name_LONGEST_LENGTH_EQUAL: Int
  name_LONGEST_LENGTH_GT: Int
  name_LONGEST_LENGTH_GTE: Int
  name_LONGEST_LENGTH_LT: Int
  name_LONGEST_LENGTH_LTE: Int
  name_SHORTEST_LENGTH_EQUAL: Int
  name_SHORTEST_LENGTH_GT: Int
  name_SHORTEST_LENGTH_GTE: Int
  name_SHORTEST_LENGTH_LT: Int
  name_SHORTEST_LENGTH_LTE: Int
}

input SeriesGenreRelationshipSubscriptionWhere {
  edge: SeriesPropsSubscriptionWhere
  node: GenreSubscriptionWhere
}

input SeriesGenreUpdateConnectionInput {
  edge: SeriesPropsUpdateInput
  node: GenreUpdateInput
}

input SeriesGenreUpdateFieldInput {
  connect: SeriesGenreConnectFieldInput
  connectOrCreate: SeriesGenreConnectOrCreateFieldInput
  create: SeriesGenreCreateFieldInput
  delete: IProductGenreDeleteFieldInput
  disconnect: IProductGenreDisconnectFieldInput
  update: SeriesGenreUpdateConnectionInput
  where: IProductGenreConnectionWhere
}

input SeriesOptions {
  limit: Int
  offset: Int
  """
  Specify one or more SeriesSort objects to sort Series by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [SeriesSort!]
}

"""
The edge properties for the following fields:
* Series.genre
"""
type SeriesProps {
  episodes: Int
}

input SeriesPropsAggregationWhereInput {
  AND: [SeriesPropsAggregationWhereInput!]
  NOT: SeriesPropsAggregationWhereInput
  OR: [SeriesPropsAggregationWhereInput!]
  episodes_AVERAGE_EQUAL: Float
  episodes_AVERAGE_GT: Float
  episodes_AVERAGE_GTE: Float
  episodes_AVERAGE_LT: Float
  episodes_AVERAGE_LTE: Float
  episodes_MAX_EQUAL: Int
  episodes_MAX_GT: Int
  episodes_MAX_GTE: Int
  episodes_MAX_LT: Int
  episodes_MAX_LTE: Int
  episodes_MIN_EQUAL: Int
  episodes_MIN_GT: Int
  episodes_MIN_GTE: Int
  episodes_MIN_LT: Int
  episodes_MIN_LTE: Int
  episodes_SUM_EQUAL: Int
  episodes_SUM_GT: Int
  episodes_SUM_GTE: Int
  episodes_SUM_LT: Int
  episodes_SUM_LTE: Int
}

input SeriesPropsCreateInput {
  episodes: Int
}

input SeriesPropsSort {
  episodes: SortDirection
}

input SeriesPropsSubscriptionWhere {
  AND: [SeriesPropsSubscriptionWhere!]
  NOT: SeriesPropsSubscriptionWhere
  OR: [SeriesPropsSubscriptionWhere!]
  episodes: Int
  episodes_GT: Int
  episodes_GTE: Int
  episodes_IN: [Int]
  episodes_LT: Int
  episodes_LTE: Int
}

input SeriesPropsUpdateInput {
  episodes: Int
  episodes_DECREMENT: Int
  episodes_INCREMENT: Int
}

input SeriesPropsWhere {
  AND: [SeriesPropsWhere!]
  NOT: SeriesPropsWhere
  OR: [SeriesPropsWhere!]
  episodes: Int
  episodes_GT: Int
  episodes_GTE: Int
  episodes_IN: [Int]
  episodes_LT: Int
  episodes_LTE: Int
}

input SeriesRelationInput {
  genre: SeriesGenreCreateFieldInput
}

type SeriesRelationshipCreatedEvent {
  createdRelationship: SeriesConnectedRelationships!
  event: EventType!
  relationshipFieldName: String!
  series: SeriesEventPayload!
  timestamp: Float!
}

input SeriesRelationshipCreatedSubscriptionWhere {
  AND: [SeriesRelationshipCreatedSubscriptionWhere!]
  NOT: SeriesRelationshipCreatedSubscriptionWhere
  OR: [SeriesRelationshipCreatedSubscriptionWhere!]
  createdRelationship: SeriesRelationshipsSubscriptionWhere
  series: SeriesSubscriptionWhere
}

type SeriesRelationshipDeletedEvent {
  deletedRelationship: SeriesConnectedRelationships!
  event: EventType!
  relationshipFieldName: String!
  series: SeriesEventPayload!
  timestamp: Float!
}

input SeriesRelationshipDeletedSubscriptionWhere {
  AND: [SeriesRelationshipDeletedSubscriptionWhere!]
  NOT: SeriesRelationshipDeletedSubscriptionWhere
  OR: [SeriesRelationshipDeletedSubscriptionWhere!]
  deletedRelationship: SeriesRelationshipsSubscriptionWhere
  series: SeriesSubscriptionWhere
}

input SeriesRelationshipsSubscriptionWhere {
  genre: SeriesGenreRelationshipSubscriptionWhere
}

"""
Fields to sort Series by. The order in which sorts are applied is not guaranteed when specifying many fields in one SeriesSort object.
"""
input SeriesSort {
  id: SortDirection
  name: SortDirection
}

input SeriesSubscriptionWhere {
  AND: [SeriesSubscriptionWhere!]
  NOT: SeriesSubscriptionWhere
  OR: [SeriesSubscriptionWhere!]
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

input SeriesUpdateInput {
  genre: SeriesGenreUpdateFieldInput
  id: String
  name: String
}

type SeriesUpdatedEvent {
  event: EventType!
  previousState: SeriesEventPayload!
  timestamp: Float!
  updatedSeries: SeriesEventPayload!
}

input SeriesWhere {
  AND: [SeriesWhere!]
  NOT: SeriesWhere
  OR: [SeriesWhere!]
  genre: GenreWhere
  genreAggregate: SeriesGenreAggregateInput
  genreConnection: IProductGenreConnectionWhere
  genreConnection_NOT: IProductGenreConnectionWhere
  genre_NOT: GenreWhere
  id: String
  id_CONTAINS: String
  id_ENDS_WITH: String
  id_IN: [String!]
  id_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String!]
  name_STARTS_WITH: String
}

"""An enum for sorting in either ascending or descending order."""
enum SortDirection {
  """Sort by field values in ascending order."""
  ASC
  """Sort by field values in descending order."""
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type Subscription {
  genreCreated(where: GenreSubscriptionWhere): GenreCreatedEvent!
  genreDeleted(where: GenreSubscriptionWhere): GenreDeletedEvent!
  genreRelationshipCreated(where: GenreRelationshipCreatedSubscriptionWhere): GenreRelationshipCreatedEvent!
  genreRelationshipDeleted(where: GenreRelationshipDeletedSubscriptionWhere): GenreRelationshipDeletedEvent!
  genreUpdated(where: GenreSubscriptionWhere): GenreUpdatedEvent!
  movieCreated(where: MovieSubscriptionWhere): MovieCreatedEvent!
  movieDeleted(where: MovieSubscriptionWhere): MovieDeletedEvent!
  movieRelationshipCreated(where: MovieRelationshipCreatedSubscriptionWhere): MovieRelationshipCreatedEvent!
  movieRelationshipDeleted(where: MovieRelationshipDeletedSubscriptionWhere): MovieRelationshipDeletedEvent!
  movieUpdated(where: MovieSubscriptionWhere): MovieUpdatedEvent!
  seriesCreated(where: SeriesSubscriptionWhere): SeriesCreatedEvent!
  seriesDeleted(where: SeriesSubscriptionWhere): SeriesDeletedEvent!
  seriesRelationshipCreated(where: SeriesRelationshipCreatedSubscriptionWhere): SeriesRelationshipCreatedEvent!
  seriesRelationshipDeleted(where: SeriesRelationshipDeletedSubscriptionWhere): SeriesRelationshipDeletedEvent!
  seriesUpdated(where: SeriesSubscriptionWhere): SeriesUpdatedEvent!
}

type UpdateGenresMutationResponse {
  genres: [Genre!]!
  info: UpdateInfo!
}

"""
Information about the number of nodes and relationships created and deleted during an update mutation
"""
type UpdateInfo {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateMoviesMutationResponse {
  info: UpdateInfo!
  movies: [Movie!]!
}

type UpdateSeriesMutationResponse {
  info: UpdateInfo!
  series: [Series!]!
}
----

'''
