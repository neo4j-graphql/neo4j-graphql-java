:toc:

= https://github.com/neo4j/graphql/issues/556 -> should compile type defs with no errors

== Source schema

[source,graphql,schema=true]
----
type Journalist {
  articles: [Article!]! @relationship(type: "HAS_ARTICLE", direction: OUT, properties: "HasArticle")
}

type HasArticle @relationshipProperties {
  createdAt: DateTime! @timestamp
}

type Article {
  id: ID! @id @unique
  blocks: [Block!]! @relationship(type: "HAS_BLOCK", direction: OUT, properties: "HasBlock")
  images: [Image!]! @relationship(type: "HAS_IMAGE", direction: OUT)
}

type HasBlock @relationshipProperties {
  order: Int!
}

interface Block {
  id: ID
}

type TextBlock implements Block {
  id: ID @id @unique
  text: String
}

type DividerBlock implements Block {
  id: ID @id @unique
}

type ImageBlock implements Block {
  id: ID @id @unique
  images: [Image!]! @relationship(type: "HAS_IMAGE", direction: OUT)
}

interface Image {
  featuredIn: [Article!]
}

type PDFImage implements Image {
  featuredIn: [Article!]! @relationship(type: "HAS_IMAGE", direction: IN)
  url: String!
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

type Article {
  blocks(directed: Boolean = true, options: BlockOptions, where: BlockWhere): [Block!]!
  blocksAggregate(directed: Boolean = true, where: BlockWhere): ArticleBlockBlocksAggregationSelection
  blocksConnection(after: String, directed: Boolean = true, first: Int, sort: [ArticleBlocksConnectionSort!], where: ArticleBlocksConnectionWhere): ArticleBlocksConnection!
  id: ID!
  images(directed: Boolean = true, options: ImageOptions, where: ImageWhere): [Image!]!
  imagesAggregate(directed: Boolean = true, where: ImageWhere): ArticleImageImagesAggregationSelection
  imagesConnection(after: String, directed: Boolean = true, first: Int, where: ArticleImagesConnectionWhere): ArticleImagesConnection!
}

type ArticleAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

type ArticleBlockBlocksAggregationSelection {
  count: Int!
  edge: ArticleBlockBlocksEdgeAggregateSelection
  node: ArticleBlockBlocksNodeAggregateSelection
}

type ArticleBlockBlocksEdgeAggregateSelection {
  order: IntAggregateSelection!
}

type ArticleBlockBlocksNodeAggregateSelection {
  id: IDAggregateSelection!
}

input ArticleBlocksAggregateInput {
  AND: [ArticleBlocksAggregateInput!]
  NOT: ArticleBlocksAggregateInput
  OR: [ArticleBlocksAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: HasBlockAggregationWhereInput
}

input ArticleBlocksConnectFieldInput {
  edge: HasBlockCreateInput!
  where: BlockConnectWhere
}

type ArticleBlocksConnection {
  edges: [ArticleBlocksRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ArticleBlocksConnectionSort {
  edge: HasBlockSort
  node: BlockSort
}

input ArticleBlocksConnectionWhere {
  AND: [ArticleBlocksConnectionWhere!]
  NOT: ArticleBlocksConnectionWhere
  OR: [ArticleBlocksConnectionWhere!]
  edge: HasBlockWhere
  node: BlockWhere
}

input ArticleBlocksCreateFieldInput {
  edge: HasBlockCreateInput!
  node: BlockCreateInput!
}

input ArticleBlocksDeleteFieldInput {
  where: ArticleBlocksConnectionWhere
}

input ArticleBlocksDisconnectFieldInput {
  where: ArticleBlocksConnectionWhere
}

input ArticleBlocksFieldInput {
  connect: [ArticleBlocksConnectFieldInput!]
  create: [ArticleBlocksCreateFieldInput!]
}

type ArticleBlocksRelationship {
  cursor: String!
  node: Block!
  properties: HasBlock!
}

input ArticleBlocksUpdateConnectionInput {
  edge: HasBlockUpdateInput
  node: BlockUpdateInput
}

input ArticleBlocksUpdateFieldInput {
  connect: [ArticleBlocksConnectFieldInput!]
  create: [ArticleBlocksCreateFieldInput!]
  delete: [ArticleBlocksDeleteFieldInput!]
  disconnect: [ArticleBlocksDisconnectFieldInput!]
  update: ArticleBlocksUpdateConnectionInput
  where: ArticleBlocksConnectionWhere
}

input ArticleConnectInput {
  blocks: [ArticleBlocksConnectFieldInput!]
  images: [ArticleImagesConnectFieldInput!]
}

input ArticleConnectOrCreateWhere {
  node: ArticleUniqueWhere!
}

input ArticleConnectWhere {
  node: ArticleWhere!
}

input ArticleCreateInput {
  blocks: ArticleBlocksFieldInput
  images: ArticleImagesFieldInput
}

input ArticleDeleteInput {
  blocks: [ArticleBlocksDeleteFieldInput!]
  images: [ArticleImagesDeleteFieldInput!]
}

input ArticleDisconnectInput {
  blocks: [ArticleBlocksDisconnectFieldInput!]
  images: [ArticleImagesDisconnectFieldInput!]
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

type ArticleImageImagesAggregationSelection {
  count: Int!
}

input ArticleImagesAggregateInput {
  AND: [ArticleImagesAggregateInput!]
  NOT: ArticleImagesAggregateInput
  OR: [ArticleImagesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
}

input ArticleImagesConnectFieldInput {
  where: ImageConnectWhere
}

type ArticleImagesConnection {
  edges: [ArticleImagesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ArticleImagesConnectionWhere {
  AND: [ArticleImagesConnectionWhere!]
  NOT: ArticleImagesConnectionWhere
  OR: [ArticleImagesConnectionWhere!]
  node: ImageWhere
}

input ArticleImagesCreateFieldInput {
  node: ImageCreateInput!
}

input ArticleImagesDeleteFieldInput {
  where: ArticleImagesConnectionWhere
}

input ArticleImagesDisconnectFieldInput {
  where: ArticleImagesConnectionWhere
}

input ArticleImagesFieldInput {
  connect: [ArticleImagesConnectFieldInput!]
  create: [ArticleImagesCreateFieldInput!]
}

type ArticleImagesRelationship {
  cursor: String!
  node: Image!
}

input ArticleImagesUpdateConnectionInput {
  node: ImageUpdateInput
}

input ArticleImagesUpdateFieldInput {
  connect: [ArticleImagesConnectFieldInput!]
  create: [ArticleImagesCreateFieldInput!]
  delete: [ArticleImagesDeleteFieldInput!]
  disconnect: [ArticleImagesDisconnectFieldInput!]
  update: ArticleImagesUpdateConnectionInput
  where: ArticleImagesConnectionWhere
}

input ArticleOnCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ArticleOptions {
  limit: Int
  offset: Int
  """
  Specify one or more ArticleSort objects to sort Articles by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ArticleSort!]
}

input ArticleRelationInput {
  blocks: [ArticleBlocksCreateFieldInput!]
  images: [ArticleImagesCreateFieldInput!]
}

"""
Fields to sort Articles by. The order in which sorts are applied is not guaranteed when specifying many fields in one ArticleSort object.
"""
input ArticleSort {
  id: SortDirection
}

input ArticleUniqueWhere {
  id: ID
}

input ArticleUpdateInput {
  blocks: [ArticleBlocksUpdateFieldInput!]
  images: [ArticleImagesUpdateFieldInput!]
}

input ArticleWhere {
  AND: [ArticleWhere!]
  NOT: ArticleWhere
  OR: [ArticleWhere!]
  blocksAggregate: ArticleBlocksAggregateInput
  """
  Return Articles where all of the related ArticleBlocksConnections match this filter
  """
  blocksConnection_ALL: ArticleBlocksConnectionWhere
  """
  Return Articles where none of the related ArticleBlocksConnections match this filter
  """
  blocksConnection_NONE: ArticleBlocksConnectionWhere
  """
  Return Articles where one of the related ArticleBlocksConnections match this filter
  """
  blocksConnection_SINGLE: ArticleBlocksConnectionWhere
  """
  Return Articles where some of the related ArticleBlocksConnections match this filter
  """
  blocksConnection_SOME: ArticleBlocksConnectionWhere
  """Return Articles where all of the related Blocks match this filter"""
  blocks_ALL: BlockWhere
  """Return Articles where none of the related Blocks match this filter"""
  blocks_NONE: BlockWhere
  """Return Articles where one of the related Blocks match this filter"""
  blocks_SINGLE: BlockWhere
  """Return Articles where some of the related Blocks match this filter"""
  blocks_SOME: BlockWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID!]
  id_STARTS_WITH: ID
  imagesAggregate: ArticleImagesAggregateInput
  """
  Return Articles where all of the related ArticleImagesConnections match this filter
  """
  imagesConnection_ALL: ArticleImagesConnectionWhere
  """
  Return Articles where none of the related ArticleImagesConnections match this filter
  """
  imagesConnection_NONE: ArticleImagesConnectionWhere
  """
  Return Articles where one of the related ArticleImagesConnections match this filter
  """
  imagesConnection_SINGLE: ArticleImagesConnectionWhere
  """
  Return Articles where some of the related ArticleImagesConnections match this filter
  """
  imagesConnection_SOME: ArticleImagesConnectionWhere
  """Return Articles where all of the related Images match this filter"""
  images_ALL: ImageWhere
  """Return Articles where none of the related Images match this filter"""
  images_NONE: ImageWhere
  """Return Articles where one of the related Images match this filter"""
  images_SINGLE: ImageWhere
  """Return Articles where some of the related Images match this filter"""
  images_SOME: ImageWhere
}

type ArticlesConnection {
  edges: [ArticleEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

interface Block {
  id: ID
}

type BlockAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input BlockConnectWhere {
  node: BlockWhere!
}

input BlockCreateInput {
  DividerBlock: DividerBlockCreateInput
  ImageBlock: ImageBlockCreateInput
  TextBlock: TextBlockCreateInput
}

type BlockEdge {
  cursor: String!
  node: Block!
}

enum BlockImplementation {
  DividerBlock
  ImageBlock
  TextBlock
}

input BlockOptions {
  limit: Int
  offset: Int
  """
  Specify one or more BlockSort objects to sort Blocks by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [BlockSort]
}

"""
Fields to sort Blocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one BlockSort object.
"""
input BlockSort {
  id: SortDirection
}

input BlockUpdateInput {
  id: ID
}

input BlockWhere {
  AND: [BlockWhere!]
  NOT: BlockWhere
  OR: [BlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  typename_IN: [BlockImplementation!]
}

type BlocksConnection {
  edges: [BlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreateArticlesMutationResponse {
  articles: [Article!]!
  info: CreateInfo!
}

type CreateDividerBlocksMutationResponse {
  dividerBlocks: [DividerBlock!]!
  info: CreateInfo!
}

type CreateImageBlocksMutationResponse {
  imageBlocks: [ImageBlock!]!
  info: CreateInfo!
}

"""
Information about the number of nodes and relationships created during a create mutation
"""
type CreateInfo {
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateJournalistsMutationResponse {
  info: CreateInfo!
  journalists: [Journalist!]!
}

type CreatePdfImagesMutationResponse {
  info: CreateInfo!
  pdfImages: [PDFImage!]!
}

type CreateTextBlocksMutationResponse {
  info: CreateInfo!
  textBlocks: [TextBlock!]!
}

"""A date and time, represented as an ISO-8601 string"""
scalar DateTime

type DateTimeAggregateSelection {
  max: DateTime
  min: DateTime
}

"""
Information about the number of nodes and relationships deleted during a delete mutation
"""
type DeleteInfo {
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type DividerBlock implements Block {
  id: ID
}

type DividerBlockAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input DividerBlockCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

type DividerBlockEdge {
  cursor: String!
  node: DividerBlock!
}

input DividerBlockOptions {
  limit: Int
  offset: Int
  """
  Specify one or more DividerBlockSort objects to sort DividerBlocks by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [DividerBlockSort!]
}

"""
Fields to sort DividerBlocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one DividerBlockSort object.
"""
input DividerBlockSort {
  id: SortDirection
}

input DividerBlockUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input DividerBlockWhere {
  AND: [DividerBlockWhere!]
  NOT: DividerBlockWhere
  OR: [DividerBlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
}

type DividerBlocksConnection {
  edges: [DividerBlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
The edge properties for the following fields:
* Journalist.articles
"""
type HasArticle {
  createdAt: DateTime!
}

input HasArticleAggregationWhereInput {
  AND: [HasArticleAggregationWhereInput!]
  NOT: HasArticleAggregationWhereInput
  OR: [HasArticleAggregationWhereInput!]
  createdAt_MAX_EQUAL: DateTime
  createdAt_MAX_GT: DateTime
  createdAt_MAX_GTE: DateTime
  createdAt_MAX_LT: DateTime
  createdAt_MAX_LTE: DateTime
  createdAt_MIN_EQUAL: DateTime
  createdAt_MIN_GT: DateTime
  createdAt_MIN_GTE: DateTime
  createdAt_MIN_LT: DateTime
  createdAt_MIN_LTE: DateTime
}

input HasArticleSort {
  createdAt: SortDirection
}

input HasArticleWhere {
  AND: [HasArticleWhere!]
  NOT: HasArticleWhere
  OR: [HasArticleWhere!]
  createdAt: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_IN: [DateTime!]
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
}

"""
The edge properties for the following fields:
* Article.blocks
"""
type HasBlock {
  order: Int!
}

input HasBlockAggregationWhereInput {
  AND: [HasBlockAggregationWhereInput!]
  NOT: HasBlockAggregationWhereInput
  OR: [HasBlockAggregationWhereInput!]
  order_AVERAGE_EQUAL: Float
  order_AVERAGE_GT: Float
  order_AVERAGE_GTE: Float
  order_AVERAGE_LT: Float
  order_AVERAGE_LTE: Float
  order_MAX_EQUAL: Int
  order_MAX_GT: Int
  order_MAX_GTE: Int
  order_MAX_LT: Int
  order_MAX_LTE: Int
  order_MIN_EQUAL: Int
  order_MIN_GT: Int
  order_MIN_GTE: Int
  order_MIN_LT: Int
  order_MIN_LTE: Int
  order_SUM_EQUAL: Int
  order_SUM_GT: Int
  order_SUM_GTE: Int
  order_SUM_LT: Int
  order_SUM_LTE: Int
}

input HasBlockCreateInput {
  order: Int!
}

input HasBlockSort {
  order: SortDirection
}

input HasBlockUpdateInput {
  order: Int
  order_DECREMENT: Int
  order_INCREMENT: Int
}

input HasBlockWhere {
  AND: [HasBlockWhere!]
  NOT: HasBlockWhere
  OR: [HasBlockWhere!]
  order: Int
  order_GT: Int
  order_GTE: Int
  order_IN: [Int!]
  order_LT: Int
  order_LTE: Int
}

type IDAggregateSelection {
  longest: ID
  shortest: ID
}

interface Image {
  featuredIn: [Article!]
}

type ImageAggregateSelection {
  count: Int!
}

type ImageBlock implements Block {
  id: ID
  images(directed: Boolean = true, options: ImageOptions, where: ImageWhere): [Image!]!
  imagesAggregate(directed: Boolean = true, where: ImageWhere): ImageBlockImageImagesAggregationSelection
  imagesConnection(after: String, directed: Boolean = true, first: Int, where: ImageBlockImagesConnectionWhere): ImageBlockImagesConnection!
}

type ImageBlockAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input ImageBlockConnectInput {
  images: [ImageBlockImagesConnectFieldInput!]
}

input ImageBlockCreateInput {
  images: ImageBlockImagesFieldInput
}

input ImageBlockDeleteInput {
  images: [ImageBlockImagesDeleteFieldInput!]
}

input ImageBlockDisconnectInput {
  images: [ImageBlockImagesDisconnectFieldInput!]
}

type ImageBlockEdge {
  cursor: String!
  node: ImageBlock!
}

type ImageBlockImageImagesAggregationSelection {
  count: Int!
}

input ImageBlockImagesAggregateInput {
  AND: [ImageBlockImagesAggregateInput!]
  NOT: ImageBlockImagesAggregateInput
  OR: [ImageBlockImagesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
}

input ImageBlockImagesConnectFieldInput {
  where: ImageConnectWhere
}

type ImageBlockImagesConnection {
  edges: [ImageBlockImagesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ImageBlockImagesConnectionWhere {
  AND: [ImageBlockImagesConnectionWhere!]
  NOT: ImageBlockImagesConnectionWhere
  OR: [ImageBlockImagesConnectionWhere!]
  node: ImageWhere
}

input ImageBlockImagesCreateFieldInput {
  node: ImageCreateInput!
}

input ImageBlockImagesDeleteFieldInput {
  where: ImageBlockImagesConnectionWhere
}

input ImageBlockImagesDisconnectFieldInput {
  where: ImageBlockImagesConnectionWhere
}

input ImageBlockImagesFieldInput {
  connect: [ImageBlockImagesConnectFieldInput!]
  create: [ImageBlockImagesCreateFieldInput!]
}

type ImageBlockImagesRelationship {
  cursor: String!
  node: Image!
}

input ImageBlockImagesUpdateConnectionInput {
  node: ImageUpdateInput
}

input ImageBlockImagesUpdateFieldInput {
  connect: [ImageBlockImagesConnectFieldInput!]
  create: [ImageBlockImagesCreateFieldInput!]
  delete: [ImageBlockImagesDeleteFieldInput!]
  disconnect: [ImageBlockImagesDisconnectFieldInput!]
  update: ImageBlockImagesUpdateConnectionInput
  where: ImageBlockImagesConnectionWhere
}

input ImageBlockOptions {
  limit: Int
  offset: Int
  """
  Specify one or more ImageBlockSort objects to sort ImageBlocks by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ImageBlockSort!]
}

input ImageBlockRelationInput {
  images: [ImageBlockImagesCreateFieldInput!]
}

"""
Fields to sort ImageBlocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one ImageBlockSort object.
"""
input ImageBlockSort {
  id: SortDirection
}

input ImageBlockUpdateInput {
  images: [ImageBlockImagesUpdateFieldInput!]
}

input ImageBlockWhere {
  AND: [ImageBlockWhere!]
  NOT: ImageBlockWhere
  OR: [ImageBlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  imagesAggregate: ImageBlockImagesAggregateInput
  """
  Return ImageBlocks where all of the related ImageBlockImagesConnections match this filter
  """
  imagesConnection_ALL: ImageBlockImagesConnectionWhere
  """
  Return ImageBlocks where none of the related ImageBlockImagesConnections match this filter
  """
  imagesConnection_NONE: ImageBlockImagesConnectionWhere
  """
  Return ImageBlocks where one of the related ImageBlockImagesConnections match this filter
  """
  imagesConnection_SINGLE: ImageBlockImagesConnectionWhere
  """
  Return ImageBlocks where some of the related ImageBlockImagesConnections match this filter
  """
  imagesConnection_SOME: ImageBlockImagesConnectionWhere
  """Return ImageBlocks where all of the related Images match this filter"""
  images_ALL: ImageWhere
  """Return ImageBlocks where none of the related Images match this filter"""
  images_NONE: ImageWhere
  """Return ImageBlocks where one of the related Images match this filter"""
  images_SINGLE: ImageWhere
  """Return ImageBlocks where some of the related Images match this filter"""
  images_SOME: ImageWhere
}

type ImageBlocksConnection {
  edges: [ImageBlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ImageConnectWhere {
  node: ImageWhere!
}

input ImageCreateInput {
  PDFImage: PDFImageCreateInput
}

type ImageEdge {
  cursor: String!
  node: Image!
}

enum ImageImplementation {
  PDFImage
}

input ImageOptions {
  limit: Int
  offset: Int
}

input ImageUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ImageWhere {
  AND: [ImageWhere!]
  NOT: ImageWhere
  OR: [ImageWhere!]
  typename_IN: [ImageImplementation!]
}

type ImagesConnection {
  edges: [ImageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IntAggregateSelection {
  average: Float
  max: Int
  min: Int
  sum: Int
}

type Journalist {
  articles(directed: Boolean = true, options: ArticleOptions, where: ArticleWhere): [Article!]!
  articlesAggregate(directed: Boolean = true, where: ArticleWhere): JournalistArticleArticlesAggregationSelection
  articlesConnection(after: String, directed: Boolean = true, first: Int, sort: [JournalistArticlesConnectionSort!], where: JournalistArticlesConnectionWhere): JournalistArticlesConnection!
}

type JournalistAggregateSelection {
  count: Int!
}

type JournalistArticleArticlesAggregationSelection {
  count: Int!
  edge: JournalistArticleArticlesEdgeAggregateSelection
  node: JournalistArticleArticlesNodeAggregateSelection
}

type JournalistArticleArticlesEdgeAggregateSelection {
  createdAt: DateTimeAggregateSelection!
}

type JournalistArticleArticlesNodeAggregateSelection {
  id: IDAggregateSelection!
}

input JournalistArticlesAggregateInput {
  AND: [JournalistArticlesAggregateInput!]
  NOT: JournalistArticlesAggregateInput
  OR: [JournalistArticlesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: HasArticleAggregationWhereInput
}

input JournalistArticlesConnectFieldInput {
  connect: [ArticleConnectInput!]
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: ArticleConnectWhere
}

input JournalistArticlesConnectOrCreateFieldInput {
  onCreate: JournalistArticlesConnectOrCreateFieldInputOnCreate!
  where: ArticleConnectOrCreateWhere!
}

input JournalistArticlesConnectOrCreateFieldInputOnCreate {
  node: ArticleOnCreateInput!
}

type JournalistArticlesConnection {
  edges: [JournalistArticlesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input JournalistArticlesConnectionSort {
  edge: HasArticleSort
  node: ArticleSort
}

input JournalistArticlesConnectionWhere {
  AND: [JournalistArticlesConnectionWhere!]
  NOT: JournalistArticlesConnectionWhere
  OR: [JournalistArticlesConnectionWhere!]
  edge: HasArticleWhere
  node: ArticleWhere
}

input JournalistArticlesCreateFieldInput {
  node: ArticleCreateInput!
}

input JournalistArticlesDeleteFieldInput {
  delete: ArticleDeleteInput
  where: JournalistArticlesConnectionWhere
}

input JournalistArticlesDisconnectFieldInput {
  disconnect: ArticleDisconnectInput
  where: JournalistArticlesConnectionWhere
}

input JournalistArticlesFieldInput {
  connect: [JournalistArticlesConnectFieldInput!]
  connectOrCreate: [JournalistArticlesConnectOrCreateFieldInput!]
  create: [JournalistArticlesCreateFieldInput!]
}

type JournalistArticlesRelationship {
  cursor: String!
  node: Article!
  properties: HasArticle!
}

input JournalistArticlesUpdateConnectionInput {
  node: ArticleUpdateInput
}

input JournalistArticlesUpdateFieldInput {
  connect: [JournalistArticlesConnectFieldInput!]
  connectOrCreate: [JournalistArticlesConnectOrCreateFieldInput!]
  create: [JournalistArticlesCreateFieldInput!]
  delete: [JournalistArticlesDeleteFieldInput!]
  disconnect: [JournalistArticlesDisconnectFieldInput!]
  update: JournalistArticlesUpdateConnectionInput
  where: JournalistArticlesConnectionWhere
}

input JournalistConnectInput {
  articles: [JournalistArticlesConnectFieldInput!]
}

input JournalistConnectOrCreateInput {
  articles: [JournalistArticlesConnectOrCreateFieldInput!]
}

input JournalistCreateInput {
  articles: JournalistArticlesFieldInput
}

input JournalistDeleteInput {
  articles: [JournalistArticlesDeleteFieldInput!]
}

input JournalistDisconnectInput {
  articles: [JournalistArticlesDisconnectFieldInput!]
}

type JournalistEdge {
  cursor: String!
  node: Journalist!
}

input JournalistOptions {
  limit: Int
  offset: Int
}

input JournalistRelationInput {
  articles: [JournalistArticlesCreateFieldInput!]
}

input JournalistUpdateInput {
  articles: [JournalistArticlesUpdateFieldInput!]
}

input JournalistWhere {
  AND: [JournalistWhere!]
  NOT: JournalistWhere
  OR: [JournalistWhere!]
  articlesAggregate: JournalistArticlesAggregateInput
  """
  Return Journalists where all of the related JournalistArticlesConnections match this filter
  """
  articlesConnection_ALL: JournalistArticlesConnectionWhere
  """
  Return Journalists where none of the related JournalistArticlesConnections match this filter
  """
  articlesConnection_NONE: JournalistArticlesConnectionWhere
  """
  Return Journalists where one of the related JournalistArticlesConnections match this filter
  """
  articlesConnection_SINGLE: JournalistArticlesConnectionWhere
  """
  Return Journalists where some of the related JournalistArticlesConnections match this filter
  """
  articlesConnection_SOME: JournalistArticlesConnectionWhere
  """Return Journalists where all of the related Articles match this filter"""
  articles_ALL: ArticleWhere
  """
  Return Journalists where none of the related Articles match this filter
  """
  articles_NONE: ArticleWhere
  """Return Journalists where one of the related Articles match this filter"""
  articles_SINGLE: ArticleWhere
  """
  Return Journalists where some of the related Articles match this filter
  """
  articles_SOME: ArticleWhere
}

type JournalistsConnection {
  edges: [JournalistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Mutation {
  createArticles(input: [ArticleCreateInput!]!): CreateArticlesMutationResponse!
  createDividerBlocks(input: [DividerBlockCreateInput!]!): CreateDividerBlocksMutationResponse!
  createImageBlocks(input: [ImageBlockCreateInput!]!): CreateImageBlocksMutationResponse!
  createJournalists(input: [JournalistCreateInput!]!): CreateJournalistsMutationResponse!
  createPdfImages(input: [PDFImageCreateInput!]!): CreatePdfImagesMutationResponse!
  createTextBlocks(input: [TextBlockCreateInput!]!): CreateTextBlocksMutationResponse!
  deleteArticles(delete: ArticleDeleteInput, where: ArticleWhere): DeleteInfo!
  deleteDividerBlocks(where: DividerBlockWhere): DeleteInfo!
  deleteImageBlocks(delete: ImageBlockDeleteInput, where: ImageBlockWhere): DeleteInfo!
  deleteJournalists(delete: JournalistDeleteInput, where: JournalistWhere): DeleteInfo!
  deletePdfImages(delete: PDFImageDeleteInput, where: PDFImageWhere): DeleteInfo!
  deleteTextBlocks(where: TextBlockWhere): DeleteInfo!
  updateArticles(connect: ArticleConnectInput, create: ArticleRelationInput, delete: ArticleDeleteInput, disconnect: ArticleDisconnectInput, update: ArticleUpdateInput, where: ArticleWhere): UpdateArticlesMutationResponse!
  updateDividerBlocks(update: DividerBlockUpdateInput, where: DividerBlockWhere): UpdateDividerBlocksMutationResponse!
  updateImageBlocks(connect: ImageBlockConnectInput, create: ImageBlockRelationInput, delete: ImageBlockDeleteInput, disconnect: ImageBlockDisconnectInput, update: ImageBlockUpdateInput, where: ImageBlockWhere): UpdateImageBlocksMutationResponse!
  updateJournalists(connect: JournalistConnectInput, connectOrCreate: JournalistConnectOrCreateInput, create: JournalistRelationInput, delete: JournalistDeleteInput, disconnect: JournalistDisconnectInput, update: JournalistUpdateInput, where: JournalistWhere): UpdateJournalistsMutationResponse!
  updatePdfImages(connect: PDFImageConnectInput, connectOrCreate: PDFImageConnectOrCreateInput, create: PDFImageRelationInput, delete: PDFImageDeleteInput, disconnect: PDFImageDisconnectInput, update: PDFImageUpdateInput, where: PDFImageWhere): UpdatePdfImagesMutationResponse!
  updateTextBlocks(update: TextBlockUpdateInput, where: TextBlockWhere): UpdateTextBlocksMutationResponse!
}

type PDFImage implements Image {
  featuredIn(directed: Boolean = true, options: ArticleOptions, where: ArticleWhere): [Article!]!
  featuredInAggregate(directed: Boolean = true, where: ArticleWhere): PDFImageArticleFeaturedInAggregationSelection
  featuredInConnection(after: String, directed: Boolean = true, first: Int, sort: [PDFImageFeaturedInConnectionSort!], where: PDFImageFeaturedInConnectionWhere): PDFImageFeaturedInConnection!
  url: String!
}

type PDFImageAggregateSelection {
  count: Int!
  url: StringAggregateSelection!
}

type PDFImageArticleFeaturedInAggregationSelection {
  count: Int!
  node: PDFImageArticleFeaturedInNodeAggregateSelection
}

type PDFImageArticleFeaturedInNodeAggregateSelection {
  id: IDAggregateSelection!
}

input PDFImageConnectInput {
  featuredIn: [PDFImageFeaturedInConnectFieldInput!]
}

input PDFImageConnectOrCreateInput {
  featuredIn: [PDFImageFeaturedInConnectOrCreateFieldInput!]
}

input PDFImageCreateInput {
  featuredIn: PDFImageFeaturedInFieldInput
  url: String!
}

input PDFImageDeleteInput {
  featuredIn: [PDFImageFeaturedInDeleteFieldInput!]
}

input PDFImageDisconnectInput {
  featuredIn: [PDFImageFeaturedInDisconnectFieldInput!]
}

type PDFImageEdge {
  cursor: String!
  node: PDFImage!
}

input PDFImageFeaturedInAggregateInput {
  AND: [PDFImageFeaturedInAggregateInput!]
  NOT: PDFImageFeaturedInAggregateInput
  OR: [PDFImageFeaturedInAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
}

input PDFImageFeaturedInConnectFieldInput {
  connect: [ArticleConnectInput!]
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: ArticleConnectWhere
}

input PDFImageFeaturedInConnectOrCreateFieldInput {
  onCreate: PDFImageFeaturedInConnectOrCreateFieldInputOnCreate!
  where: ArticleConnectOrCreateWhere!
}

input PDFImageFeaturedInConnectOrCreateFieldInputOnCreate {
  node: ArticleOnCreateInput!
}

type PDFImageFeaturedInConnection {
  edges: [PDFImageFeaturedInRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PDFImageFeaturedInConnectionSort {
  node: ArticleSort
}

input PDFImageFeaturedInConnectionWhere {
  AND: [PDFImageFeaturedInConnectionWhere!]
  NOT: PDFImageFeaturedInConnectionWhere
  OR: [PDFImageFeaturedInConnectionWhere!]
  node: ArticleWhere
}

input PDFImageFeaturedInCreateFieldInput {
  node: ArticleCreateInput!
}

input PDFImageFeaturedInDeleteFieldInput {
  delete: ArticleDeleteInput
  where: PDFImageFeaturedInConnectionWhere
}

input PDFImageFeaturedInDisconnectFieldInput {
  disconnect: ArticleDisconnectInput
  where: PDFImageFeaturedInConnectionWhere
}

input PDFImageFeaturedInFieldInput {
  connect: [PDFImageFeaturedInConnectFieldInput!]
  connectOrCreate: [PDFImageFeaturedInConnectOrCreateFieldInput!]
  create: [PDFImageFeaturedInCreateFieldInput!]
}

type PDFImageFeaturedInRelationship {
  cursor: String!
  node: Article!
}

input PDFImageFeaturedInUpdateConnectionInput {
  node: ArticleUpdateInput
}

input PDFImageFeaturedInUpdateFieldInput {
  connect: [PDFImageFeaturedInConnectFieldInput!]
  connectOrCreate: [PDFImageFeaturedInConnectOrCreateFieldInput!]
  create: [PDFImageFeaturedInCreateFieldInput!]
  delete: [PDFImageFeaturedInDeleteFieldInput!]
  disconnect: [PDFImageFeaturedInDisconnectFieldInput!]
  update: PDFImageFeaturedInUpdateConnectionInput
  where: PDFImageFeaturedInConnectionWhere
}

input PDFImageOptions {
  limit: Int
  offset: Int
  """
  Specify one or more PDFImageSort objects to sort PdfImages by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PDFImageSort!]
}

input PDFImageRelationInput {
  featuredIn: [PDFImageFeaturedInCreateFieldInput!]
}

"""
Fields to sort PdfImages by. The order in which sorts are applied is not guaranteed when specifying many fields in one PDFImageSort object.
"""
input PDFImageSort {
  url: SortDirection
}

input PDFImageUpdateInput {
  featuredIn: [PDFImageFeaturedInUpdateFieldInput!]
  url: String
}

input PDFImageWhere {
  AND: [PDFImageWhere!]
  NOT: PDFImageWhere
  OR: [PDFImageWhere!]
  featuredInAggregate: PDFImageFeaturedInAggregateInput
  """
  Return PDFImages where all of the related PDFImageFeaturedInConnections match this filter
  """
  featuredInConnection_ALL: PDFImageFeaturedInConnectionWhere
  """
  Return PDFImages where none of the related PDFImageFeaturedInConnections match this filter
  """
  featuredInConnection_NONE: PDFImageFeaturedInConnectionWhere
  """
  Return PDFImages where one of the related PDFImageFeaturedInConnections match this filter
  """
  featuredInConnection_SINGLE: PDFImageFeaturedInConnectionWhere
  """
  Return PDFImages where some of the related PDFImageFeaturedInConnections match this filter
  """
  featuredInConnection_SOME: PDFImageFeaturedInConnectionWhere
  """Return PDFImages where all of the related Articles match this filter"""
  featuredIn_ALL: ArticleWhere
  """Return PDFImages where none of the related Articles match this filter"""
  featuredIn_NONE: ArticleWhere
  """Return PDFImages where one of the related Articles match this filter"""
  featuredIn_SINGLE: ArticleWhere
  """Return PDFImages where some of the related Articles match this filter"""
  featuredIn_SOME: ArticleWhere
  url: String
  url_CONTAINS: String
  url_ENDS_WITH: String
  url_IN: [String!]
  url_STARTS_WITH: String
}

"""Pagination information (Relay)"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PdfImagesConnection {
  edges: [PDFImageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Query {
  articles(options: ArticleOptions, where: ArticleWhere): [Article!]!
  articlesAggregate(where: ArticleWhere): ArticleAggregateSelection!
  articlesConnection(after: String, first: Int, sort: [ArticleSort], where: ArticleWhere): ArticlesConnection!
  blocks(options: BlockOptions, where: BlockWhere): [Block!]!
  blocksAggregate(where: BlockWhere): BlockAggregateSelection!
  blocksConnection(after: String, first: Int, sort: [BlockSort], where: BlockWhere): BlocksConnection!
  dividerBlocks(options: DividerBlockOptions, where: DividerBlockWhere): [DividerBlock!]!
  dividerBlocksAggregate(where: DividerBlockWhere): DividerBlockAggregateSelection!
  dividerBlocksConnection(after: String, first: Int, sort: [DividerBlockSort], where: DividerBlockWhere): DividerBlocksConnection!
  imageBlocks(options: ImageBlockOptions, where: ImageBlockWhere): [ImageBlock!]!
  imageBlocksAggregate(where: ImageBlockWhere): ImageBlockAggregateSelection!
  imageBlocksConnection(after: String, first: Int, sort: [ImageBlockSort], where: ImageBlockWhere): ImageBlocksConnection!
  images(options: ImageOptions, where: ImageWhere): [Image!]!
  imagesAggregate(where: ImageWhere): ImageAggregateSelection!
  imagesConnection(after: String, first: Int, where: ImageWhere): ImagesConnection!
  journalists(options: JournalistOptions, where: JournalistWhere): [Journalist!]!
  journalistsAggregate(where: JournalistWhere): JournalistAggregateSelection!
  journalistsConnection(after: String, first: Int, where: JournalistWhere): JournalistsConnection!
  pdfImages(options: PDFImageOptions, where: PDFImageWhere): [PDFImage!]!
  pdfImagesAggregate(where: PDFImageWhere): PDFImageAggregateSelection!
  pdfImagesConnection(after: String, first: Int, sort: [PDFImageSort], where: PDFImageWhere): PdfImagesConnection!
  textBlocks(options: TextBlockOptions, where: TextBlockWhere): [TextBlock!]!
  textBlocksAggregate(where: TextBlockWhere): TextBlockAggregateSelection!
  textBlocksConnection(after: String, first: Int, sort: [TextBlockSort], where: TextBlockWhere): TextBlocksConnection!
}

"""An enum for sorting in either ascending or descending order."""
enum SortDirection {
  """Sort by field values in ascending order."""
  ASC
  """Sort by field values in descending order."""
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type TextBlock implements Block {
  id: ID
  text: String
}

type TextBlockAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  text: StringAggregateSelection!
}

input TextBlockCreateInput {
  text: String
}

type TextBlockEdge {
  cursor: String!
  node: TextBlock!
}

input TextBlockOptions {
  limit: Int
  offset: Int
  """
  Specify one or more TextBlockSort objects to sort TextBlocks by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TextBlockSort!]
}

"""
Fields to sort TextBlocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one TextBlockSort object.
"""
input TextBlockSort {
  id: SortDirection
  text: SortDirection
}

input TextBlockUpdateInput {
  text: String
}

input TextBlockWhere {
  AND: [TextBlockWhere!]
  NOT: TextBlockWhere
  OR: [TextBlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
  text: String
  text_CONTAINS: String
  text_ENDS_WITH: String
  text_IN: [String]
  text_STARTS_WITH: String
}

type TextBlocksConnection {
  edges: [TextBlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UpdateArticlesMutationResponse {
  articles: [Article!]!
  info: UpdateInfo!
}

type UpdateDividerBlocksMutationResponse {
  dividerBlocks: [DividerBlock!]!
  info: UpdateInfo!
}

type UpdateImageBlocksMutationResponse {
  imageBlocks: [ImageBlock!]!
  info: UpdateInfo!
}

"""
Information about the number of nodes and relationships created and deleted during an update mutation
"""
type UpdateInfo {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateJournalistsMutationResponse {
  info: UpdateInfo!
  journalists: [Journalist!]!
}

type UpdatePdfImagesMutationResponse {
  info: UpdateInfo!
  pdfImages: [PDFImage!]!
}

type UpdateTextBlocksMutationResponse {
  info: UpdateInfo!
  textBlocks: [TextBlock!]!
}
----

'''
