:toc:

= https://github.com/neo4j/graphql/issues/556 -> should compile type defs with no errors

== Source schema

[source,graphql,schema=true]
----
type Journalist {
  articles: [Article!]! @relationship(type: "HAS_ARTICLE", direction: OUT, properties: "HasArticle")
}

interface HasArticle @relationshipProperties {
  createdAt: DateTime! @timestamp
}

type Article {
  id: ID! @id @unique
  blocks: [Block!]! @relationship(type: "HAS_BLOCK", direction: OUT, properties: "HasBlock")
  images: [Image!]! @relationship(type: "HAS_IMAGE", direction: OUT)
}

interface HasBlock @relationshipProperties {
  order: Int!
}

interface Block {
  id: ID @id
}

type TextBlock implements Block {
  id: ID @id @unique
  text: String
}

type DividerBlock implements Block {
  id: ID @id @unique
}

type ImageBlock implements Block {
  id: ID @id @unique
  images: [Image!]! @relationship(type: "HAS_IMAGE", direction: OUT)
}

interface Image {
  featuredIn: [Article!]
}

type PDFImage implements Image {
  featuredIn: [Article!]! @relationship(type: "HAS_IMAGE", direction: IN)
  url: String!
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

interface Block {
  id: ID
}

interface HasArticle {
  createdAt: DateTime!
}

interface HasBlock {
  order: Int!
}

interface Image {
  featuredIn: [Article!]
}

type Article {
  blocks(directed: Boolean = true, options: BlockOptions, where: BlockWhere): [Block!]!
  blocksConnection(after: String, directed: Boolean = true, first: Int, sort: [ArticleBlocksConnectionSort!], where: ArticleBlocksConnectionWhere): ArticleBlocksConnection!
  id: ID!
  images(directed: Boolean = true, options: ImageOptions, where: ImageWhere): [Image!]!
  imagesConnection(after: String, directed: Boolean = true, first: Int, where: ArticleImagesConnectionWhere): ArticleImagesConnection!
}

type ArticleAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNonNullable!
}

type ArticleBlocksConnection {
  edges: [ArticleBlocksRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ArticleBlocksRelationship implements HasBlock {
  cursor: String!
  node: Block!
  order: Int!
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

type ArticleImagesConnection {
  edges: [ArticleImagesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ArticleImagesRelationship {
  cursor: String!
  node: Image!
}

type ArticlesConnection {
  edges: [ArticleEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreateArticlesMutationResponse {
  articles: [Article!]!
  info: CreateInfo!
}

type CreateDividerBlocksMutationResponse {
  dividerBlocks: [DividerBlock!]!
  info: CreateInfo!
}

type CreateImageBlocksMutationResponse {
  imageBlocks: [ImageBlock!]!
  info: CreateInfo!
}

"Information about the number of nodes and relationships created during a create mutation"
type CreateInfo {
  bookmark: String @deprecated(reason : "This field has been deprecated because bookmarks are now handled by the driver.")
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateJournalistsMutationResponse {
  info: CreateInfo!
  journalists: [Journalist!]!
}

type CreatePdfImagesMutationResponse {
  info: CreateInfo!
  pdfImages: [PDFImage!]!
}

type CreateTextBlocksMutationResponse {
  info: CreateInfo!
  textBlocks: [TextBlock!]!
}

type DateTimeAggregateSelectionNonNullable {
  max: DateTime!
  min: DateTime!
}

"Information about the number of nodes and relationships deleted during a delete mutation"
type DeleteInfo {
  bookmark: String @deprecated(reason : "This field has been deprecated because bookmarks are now handled by the driver.")
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type DividerBlock implements Block {
  id: ID
}

type DividerBlockAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNullable!
}

type DividerBlockEdge {
  cursor: String!
  node: DividerBlock!
}

type DividerBlocksConnection {
  edges: [DividerBlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IDAggregateSelectionNonNullable {
  longest: ID!
  shortest: ID!
}

type IDAggregateSelectionNullable {
  longest: ID
  shortest: ID
}

type ImageBlock implements Block {
  id: ID
  images(directed: Boolean = true, options: ImageOptions, where: ImageWhere): [Image!]!
  imagesConnection(after: String, directed: Boolean = true, first: Int, where: ImageBlockImagesConnectionWhere): ImageBlockImagesConnection!
}

type ImageBlockAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNullable!
}

type ImageBlockEdge {
  cursor: String!
  node: ImageBlock!
}

type ImageBlockImagesConnection {
  edges: [ImageBlockImagesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ImageBlockImagesRelationship {
  cursor: String!
  node: Image!
}

type ImageBlocksConnection {
  edges: [ImageBlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ImageFeaturedInConnection {
  edges: [ImageFeaturedInRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ImageFeaturedInRelationship {
  cursor: String!
  node: Article!
}

type Journalist {
  articles(directed: Boolean = true, options: ArticleOptions, where: ArticleWhere): [Article!]!
  articlesAggregate(directed: Boolean = true, where: ArticleWhere): JournalistArticleArticlesAggregationSelection
  articlesConnection(after: String, directed: Boolean = true, first: Int, sort: [JournalistArticlesConnectionSort!], where: JournalistArticlesConnectionWhere): JournalistArticlesConnection!
}

type JournalistAggregateSelection {
  count: Int!
}

type JournalistArticleArticlesAggregationSelection {
  count: Int!
  edge: JournalistArticleArticlesEdgeAggregateSelection
  node: JournalistArticleArticlesNodeAggregateSelection
}

type JournalistArticleArticlesEdgeAggregateSelection {
  createdAt: DateTimeAggregateSelectionNonNullable!
}

type JournalistArticleArticlesNodeAggregateSelection {
  id: IDAggregateSelectionNonNullable!
}

type JournalistArticlesConnection {
  edges: [JournalistArticlesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type JournalistArticlesRelationship implements HasArticle {
  createdAt: DateTime!
  cursor: String!
  node: Article!
}

type JournalistEdge {
  cursor: String!
  node: Journalist!
}

type JournalistsConnection {
  edges: [JournalistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Mutation {
  createArticles(input: [ArticleCreateInput!]!): CreateArticlesMutationResponse!
  createDividerBlocks(input: [DividerBlockCreateInput!]!): CreateDividerBlocksMutationResponse!
  createImageBlocks(input: [ImageBlockCreateInput!]!): CreateImageBlocksMutationResponse!
  createJournalists(input: [JournalistCreateInput!]!): CreateJournalistsMutationResponse!
  createPdfImages(input: [PDFImageCreateInput!]!): CreatePdfImagesMutationResponse!
  createTextBlocks(input: [TextBlockCreateInput!]!): CreateTextBlocksMutationResponse!
  deleteArticles(delete: ArticleDeleteInput, where: ArticleWhere): DeleteInfo!
  deleteDividerBlocks(where: DividerBlockWhere): DeleteInfo!
  deleteImageBlocks(delete: ImageBlockDeleteInput, where: ImageBlockWhere): DeleteInfo!
  deleteJournalists(delete: JournalistDeleteInput, where: JournalistWhere): DeleteInfo!
  deletePdfImages(delete: PDFImageDeleteInput, where: PDFImageWhere): DeleteInfo!
  deleteTextBlocks(where: TextBlockWhere): DeleteInfo!
  updateArticles(connect: ArticleConnectInput, create: ArticleRelationInput, delete: ArticleDeleteInput, disconnect: ArticleDisconnectInput, update: ArticleUpdateInput, where: ArticleWhere): UpdateArticlesMutationResponse!
  updateDividerBlocks(update: DividerBlockUpdateInput, where: DividerBlockWhere): UpdateDividerBlocksMutationResponse!
  updateImageBlocks(connect: ImageBlockConnectInput, create: ImageBlockRelationInput, delete: ImageBlockDeleteInput, disconnect: ImageBlockDisconnectInput, update: ImageBlockUpdateInput, where: ImageBlockWhere): UpdateImageBlocksMutationResponse!
  updateJournalists(connect: JournalistConnectInput, connectOrCreate: JournalistConnectOrCreateInput, create: JournalistRelationInput, delete: JournalistDeleteInput, disconnect: JournalistDisconnectInput, update: JournalistUpdateInput, where: JournalistWhere): UpdateJournalistsMutationResponse!
  updatePdfImages(connect: PDFImageConnectInput, connectOrCreate: PDFImageConnectOrCreateInput, create: PDFImageRelationInput, delete: PDFImageDeleteInput, disconnect: PDFImageDisconnectInput, update: PDFImageUpdateInput, where: PDFImageWhere): UpdatePdfImagesMutationResponse!
  updateTextBlocks(update: TextBlockUpdateInput, where: TextBlockWhere): UpdateTextBlocksMutationResponse!
}

type PDFImage implements Image {
  featuredIn(directed: Boolean = true, options: ArticleOptions, where: ArticleWhere): [Article!]!
  featuredInAggregate(directed: Boolean = true, where: ArticleWhere): PDFImageArticleFeaturedInAggregationSelection
  featuredInConnection(after: String, directed: Boolean = true, first: Int, sort: [ImageFeaturedInConnectionSort!], where: ImageFeaturedInConnectionWhere): ImageFeaturedInConnection!
  url: String!
}

type PDFImageAggregateSelection {
  count: Int!
  url: StringAggregateSelectionNonNullable!
}

type PDFImageArticleFeaturedInAggregationSelection {
  count: Int!
  node: PDFImageArticleFeaturedInNodeAggregateSelection
}

type PDFImageArticleFeaturedInNodeAggregateSelection {
  id: IDAggregateSelectionNonNullable!
}

type PDFImageEdge {
  cursor: String!
  node: PDFImage!
}

"Pagination information (Relay)"
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PdfImagesConnection {
  edges: [PDFImageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Query {
  articles(options: ArticleOptions, where: ArticleWhere): [Article!]!
  articlesAggregate(where: ArticleWhere): ArticleAggregateSelection!
  articlesConnection(after: String, first: Int, sort: [ArticleSort], where: ArticleWhere): ArticlesConnection!
  dividerBlocks(options: DividerBlockOptions, where: DividerBlockWhere): [DividerBlock!]!
  dividerBlocksAggregate(where: DividerBlockWhere): DividerBlockAggregateSelection!
  dividerBlocksConnection(after: String, first: Int, sort: [DividerBlockSort], where: DividerBlockWhere): DividerBlocksConnection!
  imageBlocks(options: ImageBlockOptions, where: ImageBlockWhere): [ImageBlock!]!
  imageBlocksAggregate(where: ImageBlockWhere): ImageBlockAggregateSelection!
  imageBlocksConnection(after: String, first: Int, sort: [ImageBlockSort], where: ImageBlockWhere): ImageBlocksConnection!
  journalists(options: JournalistOptions, where: JournalistWhere): [Journalist!]!
  journalistsAggregate(where: JournalistWhere): JournalistAggregateSelection!
  journalistsConnection(after: String, first: Int, where: JournalistWhere): JournalistsConnection!
  pdfImages(options: PDFImageOptions, where: PDFImageWhere): [PDFImage!]!
  pdfImagesAggregate(where: PDFImageWhere): PDFImageAggregateSelection!
  pdfImagesConnection(after: String, first: Int, sort: [PDFImageSort], where: PDFImageWhere): PdfImagesConnection!
  textBlocks(options: TextBlockOptions, where: TextBlockWhere): [TextBlock!]!
  textBlocksAggregate(where: TextBlockWhere): TextBlockAggregateSelection!
  textBlocksConnection(after: String, first: Int, sort: [TextBlockSort], where: TextBlockWhere): TextBlocksConnection!
}

type StringAggregateSelectionNonNullable {
  longest: String!
  shortest: String!
}

type StringAggregateSelectionNullable {
  longest: String
  shortest: String
}

type TextBlock implements Block {
  id: ID
  text: String
}

type TextBlockAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNullable!
  text: StringAggregateSelectionNullable!
}

type TextBlockEdge {
  cursor: String!
  node: TextBlock!
}

type TextBlocksConnection {
  edges: [TextBlockEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UpdateArticlesMutationResponse {
  articles: [Article!]!
  info: UpdateInfo!
}

type UpdateDividerBlocksMutationResponse {
  dividerBlocks: [DividerBlock!]!
  info: UpdateInfo!
}

type UpdateImageBlocksMutationResponse {
  imageBlocks: [ImageBlock!]!
  info: UpdateInfo!
}

"Information about the number of nodes and relationships created and deleted during an update mutation"
type UpdateInfo {
  bookmark: String @deprecated(reason : "This field has been deprecated because bookmarks are now handled by the driver.")
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateJournalistsMutationResponse {
  info: UpdateInfo!
  journalists: [Journalist!]!
}

type UpdatePdfImagesMutationResponse {
  info: UpdateInfo!
  pdfImages: [PDFImage!]!
}

type UpdateTextBlocksMutationResponse {
  info: UpdateInfo!
  textBlocks: [TextBlock!]!
}

"An enum for sorting in either ascending or descending order."
enum SortDirection {
  "Sort by field values in ascending order."
  ASC
  "Sort by field values in descending order."
  DESC
}

"A date and time, represented as an ISO-8601 string"
scalar DateTime

input ArticleBlocksConnectFieldInput {
  connect: BlockConnectInput
  edge: HasBlockCreateInput!
  where: BlockConnectWhere
}

input ArticleBlocksConnectionSort {
  edge: HasBlockSort
  node: BlockSort
}

input ArticleBlocksConnectionWhere {
  AND: [ArticleBlocksConnectionWhere!]
  NOT: ArticleBlocksConnectionWhere
  OR: [ArticleBlocksConnectionWhere!]
  edge: HasBlockWhere
  edge_NOT: HasBlockWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  node: BlockWhere
  node_NOT: BlockWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input ArticleBlocksCreateFieldInput {
  edge: HasBlockCreateInput!
  node: BlockCreateInput!
}

input ArticleBlocksDeleteFieldInput {
  delete: BlockDeleteInput
  where: ArticleBlocksConnectionWhere
}

input ArticleBlocksDisconnectFieldInput {
  disconnect: BlockDisconnectInput
  where: ArticleBlocksConnectionWhere
}

input ArticleBlocksFieldInput {
  connect: [ArticleBlocksConnectFieldInput!]
  create: [ArticleBlocksCreateFieldInput!]
}

input ArticleBlocksUpdateConnectionInput {
  edge: HasBlockUpdateInput
  node: BlockUpdateInput
}

input ArticleBlocksUpdateFieldInput {
  connect: [ArticleBlocksConnectFieldInput!]
  create: [ArticleBlocksCreateFieldInput!]
  delete: [ArticleBlocksDeleteFieldInput!]
  disconnect: [ArticleBlocksDisconnectFieldInput!]
  update: ArticleBlocksUpdateConnectionInput
  where: ArticleBlocksConnectionWhere
}

input ArticleConnectInput {
  blocks: [ArticleBlocksConnectFieldInput!]
  images: [ArticleImagesConnectFieldInput!]
}

input ArticleConnectOrCreateWhere {
  node: ArticleUniqueWhere!
}

input ArticleConnectWhere {
  node: ArticleWhere!
}

input ArticleCreateInput {
  blocks: ArticleBlocksFieldInput
  images: ArticleImagesFieldInput
}

input ArticleDeleteInput {
  blocks: [ArticleBlocksDeleteFieldInput!]
  images: [ArticleImagesDeleteFieldInput!]
}

input ArticleDisconnectInput {
  blocks: [ArticleBlocksDisconnectFieldInput!]
  images: [ArticleImagesDisconnectFieldInput!]
}

input ArticleImagesConnectFieldInput {
  connect: ImageConnectInput
  where: ImageConnectWhere
}

input ArticleImagesConnectionWhere {
  AND: [ArticleImagesConnectionWhere!]
  NOT: ArticleImagesConnectionWhere
  OR: [ArticleImagesConnectionWhere!]
  node: ImageWhere
  node_NOT: ImageWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input ArticleImagesCreateFieldInput {
  node: ImageCreateInput!
}

input ArticleImagesDeleteFieldInput {
  delete: ImageDeleteInput
  where: ArticleImagesConnectionWhere
}

input ArticleImagesDisconnectFieldInput {
  disconnect: ImageDisconnectInput
  where: ArticleImagesConnectionWhere
}

input ArticleImagesFieldInput {
  connect: [ArticleImagesConnectFieldInput!]
  create: [ArticleImagesCreateFieldInput!]
}

input ArticleImagesUpdateConnectionInput {
  node: ImageUpdateInput
}

input ArticleImagesUpdateFieldInput {
  connect: [ArticleImagesConnectFieldInput!]
  create: [ArticleImagesCreateFieldInput!]
  delete: [ArticleImagesDeleteFieldInput!]
  disconnect: [ArticleImagesDisconnectFieldInput!]
  update: ArticleImagesUpdateConnectionInput
  where: ArticleImagesConnectionWhere
}

input ArticleOnCreateInput {
  "Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/"
  _emptyInput: Boolean
}

input ArticleOptions {
  limit: Int
  offset: Int
  "Specify one or more ArticleSort objects to sort Articles by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [ArticleSort!]
}

input ArticleRelationInput {
  blocks: [ArticleBlocksCreateFieldInput!]
  images: [ArticleImagesCreateFieldInput!]
}

"Fields to sort Articles by. The order in which sorts are applied is not guaranteed when specifying many fields in one ArticleSort object."
input ArticleSort {
  id: SortDirection
}

input ArticleUniqueWhere {
  id: ID
}

input ArticleUpdateInput {
  blocks: [ArticleBlocksUpdateFieldInput!]
  images: [ArticleImagesUpdateFieldInput!]
}

input ArticleWhere {
  AND: [ArticleWhere!]
  NOT: ArticleWhere
  OR: [ArticleWhere!]
  blocksConnection: ArticleBlocksConnectionWhere @deprecated(reason : "Use `blocksConnection_SOME` instead.")
  "Return Articles where all of the related ArticleBlocksConnections match this filter"
  blocksConnection_ALL: ArticleBlocksConnectionWhere
  "Return Articles where none of the related ArticleBlocksConnections match this filter"
  blocksConnection_NONE: ArticleBlocksConnectionWhere
  blocksConnection_NOT: ArticleBlocksConnectionWhere @deprecated(reason : "Use `blocksConnection_NONE` instead.")
  "Return Articles where one of the related ArticleBlocksConnections match this filter"
  blocksConnection_SINGLE: ArticleBlocksConnectionWhere
  "Return Articles where some of the related ArticleBlocksConnections match this filter"
  blocksConnection_SOME: ArticleBlocksConnectionWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID!]
  id_NOT: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_CONTAINS: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_ENDS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_IN: [ID!] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_STARTS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_STARTS_WITH: ID
  imagesConnection: ArticleImagesConnectionWhere @deprecated(reason : "Use `imagesConnection_SOME` instead.")
  "Return Articles where all of the related ArticleImagesConnections match this filter"
  imagesConnection_ALL: ArticleImagesConnectionWhere
  "Return Articles where none of the related ArticleImagesConnections match this filter"
  imagesConnection_NONE: ArticleImagesConnectionWhere
  imagesConnection_NOT: ArticleImagesConnectionWhere @deprecated(reason : "Use `imagesConnection_NONE` instead.")
  "Return Articles where one of the related ArticleImagesConnections match this filter"
  imagesConnection_SINGLE: ArticleImagesConnectionWhere
  "Return Articles where some of the related ArticleImagesConnections match this filter"
  imagesConnection_SOME: ArticleImagesConnectionWhere
}

input BlockConnectInput {
  _on: BlockImplementationsConnectInput
}

input BlockConnectWhere {
  node: BlockWhere!
}

input BlockCreateInput {
  DividerBlock: DividerBlockCreateInput
  ImageBlock: ImageBlockCreateInput
  TextBlock: TextBlockCreateInput
}

input BlockDeleteInput {
  _on: BlockImplementationsDeleteInput
}

input BlockDisconnectInput {
  _on: BlockImplementationsDisconnectInput
}

input BlockImplementationsConnectInput {
  ImageBlock: [ImageBlockConnectInput!]
}

input BlockImplementationsDeleteInput {
  ImageBlock: [ImageBlockDeleteInput!]
}

input BlockImplementationsDisconnectInput {
  ImageBlock: [ImageBlockDisconnectInput!]
}

input BlockImplementationsUpdateInput {
  DividerBlock: DividerBlockUpdateInput
  ImageBlock: ImageBlockUpdateInput
  TextBlock: TextBlockUpdateInput
}

input BlockImplementationsWhere {
  DividerBlock: DividerBlockWhere
  ImageBlock: ImageBlockWhere
  TextBlock: TextBlockWhere
}

input BlockOptions {
  limit: Int
  offset: Int
  "Specify one or more BlockSort objects to sort Blocks by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [BlockSort]
}

"Fields to sort Blocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one BlockSort object."
input BlockSort {
  id: SortDirection
}

input BlockUpdateInput {
  _on: BlockImplementationsUpdateInput
}

input BlockWhere {
  _on: BlockImplementationsWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_CONTAINS: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_ENDS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_IN: [ID] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_STARTS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_STARTS_WITH: ID
}

input DividerBlockCreateInput {
  "Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/"
  _emptyInput: Boolean
}

input DividerBlockOptions {
  limit: Int
  offset: Int
  "Specify one or more DividerBlockSort objects to sort DividerBlocks by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [DividerBlockSort!]
}

"Fields to sort DividerBlocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one DividerBlockSort object."
input DividerBlockSort {
  id: SortDirection
}

input DividerBlockUpdateInput {
  "Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/"
  _emptyInput: Boolean
}

input DividerBlockWhere {
  AND: [DividerBlockWhere!]
  NOT: DividerBlockWhere
  OR: [DividerBlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_CONTAINS: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_ENDS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_IN: [ID] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_STARTS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_STARTS_WITH: ID
}

input HasArticleSort {
  createdAt: SortDirection
}

input HasArticleWhere {
  AND: [HasArticleWhere!]
  NOT: HasArticleWhere
  OR: [HasArticleWhere!]
  createdAt: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_IN: [DateTime!]
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  createdAt_NOT: DateTime @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  createdAt_NOT_IN: [DateTime!] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input HasBlockCreateInput {
  order: Int!
}

input HasBlockSort {
  order: SortDirection
}

input HasBlockUpdateInput {
  order: Int
  order_DECREMENT: Int
  order_INCREMENT: Int
}

input HasBlockWhere {
  AND: [HasBlockWhere!]
  NOT: HasBlockWhere
  OR: [HasBlockWhere!]
  order: Int
  order_GT: Int
  order_GTE: Int
  order_IN: [Int!]
  order_LT: Int
  order_LTE: Int
  order_NOT: Int @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  order_NOT_IN: [Int!] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input ImageBlockConnectInput {
  images: [ImageBlockImagesConnectFieldInput!]
}

input ImageBlockCreateInput {
  images: ImageBlockImagesFieldInput
}

input ImageBlockDeleteInput {
  images: [ImageBlockImagesDeleteFieldInput!]
}

input ImageBlockDisconnectInput {
  images: [ImageBlockImagesDisconnectFieldInput!]
}

input ImageBlockImagesConnectFieldInput {
  connect: ImageConnectInput
  where: ImageConnectWhere
}

input ImageBlockImagesConnectionWhere {
  AND: [ImageBlockImagesConnectionWhere!]
  NOT: ImageBlockImagesConnectionWhere
  OR: [ImageBlockImagesConnectionWhere!]
  node: ImageWhere
  node_NOT: ImageWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input ImageBlockImagesCreateFieldInput {
  node: ImageCreateInput!
}

input ImageBlockImagesDeleteFieldInput {
  delete: ImageDeleteInput
  where: ImageBlockImagesConnectionWhere
}

input ImageBlockImagesDisconnectFieldInput {
  disconnect: ImageDisconnectInput
  where: ImageBlockImagesConnectionWhere
}

input ImageBlockImagesFieldInput {
  connect: [ImageBlockImagesConnectFieldInput!]
  create: [ImageBlockImagesCreateFieldInput!]
}

input ImageBlockImagesUpdateConnectionInput {
  node: ImageUpdateInput
}

input ImageBlockImagesUpdateFieldInput {
  connect: [ImageBlockImagesConnectFieldInput!]
  create: [ImageBlockImagesCreateFieldInput!]
  delete: [ImageBlockImagesDeleteFieldInput!]
  disconnect: [ImageBlockImagesDisconnectFieldInput!]
  update: ImageBlockImagesUpdateConnectionInput
  where: ImageBlockImagesConnectionWhere
}

input ImageBlockOptions {
  limit: Int
  offset: Int
  "Specify one or more ImageBlockSort objects to sort ImageBlocks by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [ImageBlockSort!]
}

input ImageBlockRelationInput {
  images: [ImageBlockImagesCreateFieldInput!]
}

"Fields to sort ImageBlocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one ImageBlockSort object."
input ImageBlockSort {
  id: SortDirection
}

input ImageBlockUpdateInput {
  images: [ImageBlockImagesUpdateFieldInput!]
}

input ImageBlockWhere {
  AND: [ImageBlockWhere!]
  NOT: ImageBlockWhere
  OR: [ImageBlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_CONTAINS: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_ENDS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_IN: [ID] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_STARTS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_STARTS_WITH: ID
  imagesConnection: ImageBlockImagesConnectionWhere @deprecated(reason : "Use `imagesConnection_SOME` instead.")
  "Return ImageBlocks where all of the related ImageBlockImagesConnections match this filter"
  imagesConnection_ALL: ImageBlockImagesConnectionWhere
  "Return ImageBlocks where none of the related ImageBlockImagesConnections match this filter"
  imagesConnection_NONE: ImageBlockImagesConnectionWhere
  imagesConnection_NOT: ImageBlockImagesConnectionWhere @deprecated(reason : "Use `imagesConnection_NONE` instead.")
  "Return ImageBlocks where one of the related ImageBlockImagesConnections match this filter"
  imagesConnection_SINGLE: ImageBlockImagesConnectionWhere
  "Return ImageBlocks where some of the related ImageBlockImagesConnections match this filter"
  imagesConnection_SOME: ImageBlockImagesConnectionWhere
}

input ImageConnectInput {
  _on: ImageImplementationsConnectInput
}

input ImageConnectWhere {
  node: ImageWhere!
}

input ImageCreateInput {
  PDFImage: PDFImageCreateInput
}

input ImageDeleteInput {
  _on: ImageImplementationsDeleteInput
}

input ImageDisconnectInput {
  _on: ImageImplementationsDisconnectInput
}

input ImageFeaturedInConnectFieldInput {
  connect: [ArticleConnectInput!]
  "Whether or not to overwrite any matching relationship with the new properties."
  overwrite: Boolean! = true
  where: ArticleConnectWhere
}

input ImageFeaturedInConnectOrCreateFieldInput {
  onCreate: ImageFeaturedInConnectOrCreateFieldInputOnCreate!
  where: ArticleConnectOrCreateWhere!
}

input ImageFeaturedInConnectOrCreateFieldInputOnCreate {
  node: ArticleOnCreateInput!
}

input ImageFeaturedInConnectionSort {
  node: ArticleSort
}

input ImageFeaturedInConnectionWhere {
  AND: [ImageFeaturedInConnectionWhere!]
  NOT: ImageFeaturedInConnectionWhere
  OR: [ImageFeaturedInConnectionWhere!]
  node: ArticleWhere
  node_NOT: ArticleWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input ImageFeaturedInCreateFieldInput {
  node: ArticleCreateInput!
}

input ImageFeaturedInDeleteFieldInput {
  delete: ArticleDeleteInput
  where: ImageFeaturedInConnectionWhere
}

input ImageFeaturedInDisconnectFieldInput {
  disconnect: ArticleDisconnectInput
  where: ImageFeaturedInConnectionWhere
}

input ImageFeaturedInFieldInput {
  connect: [ImageFeaturedInConnectFieldInput!]
  connectOrCreate: [ImageFeaturedInConnectOrCreateFieldInput!]
  create: [ImageFeaturedInCreateFieldInput!]
}

input ImageFeaturedInUpdateConnectionInput {
  node: ArticleUpdateInput
}

input ImageFeaturedInUpdateFieldInput {
  connect: [ImageFeaturedInConnectFieldInput!]
  connectOrCreate: [ImageFeaturedInConnectOrCreateFieldInput!]
  create: [ImageFeaturedInCreateFieldInput!]
  delete: [ImageFeaturedInDeleteFieldInput!]
  disconnect: [ImageFeaturedInDisconnectFieldInput!]
  update: ImageFeaturedInUpdateConnectionInput
  where: ImageFeaturedInConnectionWhere
}

input ImageImplementationsConnectInput {
  PDFImage: [PDFImageConnectInput!]
}

input ImageImplementationsDeleteInput {
  PDFImage: [PDFImageDeleteInput!]
}

input ImageImplementationsDisconnectInput {
  PDFImage: [PDFImageDisconnectInput!]
}

input ImageImplementationsUpdateInput {
  PDFImage: PDFImageUpdateInput
}

input ImageImplementationsWhere {
  PDFImage: PDFImageWhere
}

input ImageOptions {
  limit: Int
  offset: Int
}

input ImageUpdateInput {
  _on: ImageImplementationsUpdateInput
}

input ImageWhere {
  _on: ImageImplementationsWhere
}

input JournalistArticlesAggregateInput {
  AND: [JournalistArticlesAggregateInput!]
  NOT: JournalistArticlesAggregateInput
  OR: [JournalistArticlesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: JournalistArticlesEdgeAggregationWhereInput
  node: JournalistArticlesNodeAggregationWhereInput
}

input JournalistArticlesConnectFieldInput {
  connect: [ArticleConnectInput!]
  "Whether or not to overwrite any matching relationship with the new properties."
  overwrite: Boolean! = true
  where: ArticleConnectWhere
}

input JournalistArticlesConnectOrCreateFieldInput {
  onCreate: JournalistArticlesConnectOrCreateFieldInputOnCreate!
  where: ArticleConnectOrCreateWhere!
}

input JournalistArticlesConnectOrCreateFieldInputOnCreate {
  node: ArticleOnCreateInput!
}

input JournalistArticlesConnectionSort {
  edge: HasArticleSort
  node: ArticleSort
}

input JournalistArticlesConnectionWhere {
  AND: [JournalistArticlesConnectionWhere!]
  NOT: JournalistArticlesConnectionWhere
  OR: [JournalistArticlesConnectionWhere!]
  edge: HasArticleWhere
  edge_NOT: HasArticleWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  node: ArticleWhere
  node_NOT: ArticleWhere @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
}

input JournalistArticlesCreateFieldInput {
  node: ArticleCreateInput!
}

input JournalistArticlesDeleteFieldInput {
  delete: ArticleDeleteInput
  where: JournalistArticlesConnectionWhere
}

input JournalistArticlesDisconnectFieldInput {
  disconnect: ArticleDisconnectInput
  where: JournalistArticlesConnectionWhere
}

input JournalistArticlesEdgeAggregationWhereInput {
  AND: [JournalistArticlesEdgeAggregationWhereInput!]
  NOT: JournalistArticlesEdgeAggregationWhereInput
  OR: [JournalistArticlesEdgeAggregationWhereInput!]
  createdAt_EQUAL: DateTime @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
  createdAt_GT: DateTime @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
  createdAt_GTE: DateTime @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
  createdAt_LT: DateTime @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
  createdAt_LTE: DateTime @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
  createdAt_MAX_EQUAL: DateTime
  createdAt_MAX_GT: DateTime
  createdAt_MAX_GTE: DateTime
  createdAt_MAX_LT: DateTime
  createdAt_MAX_LTE: DateTime
  createdAt_MIN_EQUAL: DateTime
  createdAt_MIN_GT: DateTime
  createdAt_MIN_GTE: DateTime
  createdAt_MIN_LT: DateTime
  createdAt_MIN_LTE: DateTime
}

input JournalistArticlesFieldInput {
  connect: [JournalistArticlesConnectFieldInput!]
  connectOrCreate: [JournalistArticlesConnectOrCreateFieldInput!]
  create: [JournalistArticlesCreateFieldInput!]
}

input JournalistArticlesNodeAggregationWhereInput {
  AND: [JournalistArticlesNodeAggregationWhereInput!]
  NOT: JournalistArticlesNodeAggregationWhereInput
  OR: [JournalistArticlesNodeAggregationWhereInput!]
  id_EQUAL: ID @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
}

input JournalistArticlesUpdateConnectionInput {
  node: ArticleUpdateInput
}

input JournalistArticlesUpdateFieldInput {
  connect: [JournalistArticlesConnectFieldInput!]
  connectOrCreate: [JournalistArticlesConnectOrCreateFieldInput!]
  create: [JournalistArticlesCreateFieldInput!]
  delete: [JournalistArticlesDeleteFieldInput!]
  disconnect: [JournalistArticlesDisconnectFieldInput!]
  update: JournalistArticlesUpdateConnectionInput
  where: JournalistArticlesConnectionWhere
}

input JournalistConnectInput {
  articles: [JournalistArticlesConnectFieldInput!]
}

input JournalistConnectOrCreateInput {
  articles: [JournalistArticlesConnectOrCreateFieldInput!]
}

input JournalistCreateInput {
  articles: JournalistArticlesFieldInput
}

input JournalistDeleteInput {
  articles: [JournalistArticlesDeleteFieldInput!]
}

input JournalistDisconnectInput {
  articles: [JournalistArticlesDisconnectFieldInput!]
}

input JournalistOptions {
  limit: Int
  offset: Int
}

input JournalistRelationInput {
  articles: [JournalistArticlesCreateFieldInput!]
}

input JournalistUpdateInput {
  articles: [JournalistArticlesUpdateFieldInput!]
}

input JournalistWhere {
  AND: [JournalistWhere!]
  NOT: JournalistWhere
  OR: [JournalistWhere!]
  articles: ArticleWhere @deprecated(reason : "Use `articles_SOME` instead.")
  articlesAggregate: JournalistArticlesAggregateInput
  articlesConnection: JournalistArticlesConnectionWhere @deprecated(reason : "Use `articlesConnection_SOME` instead.")
  "Return Journalists where all of the related JournalistArticlesConnections match this filter"
  articlesConnection_ALL: JournalistArticlesConnectionWhere
  "Return Journalists where none of the related JournalistArticlesConnections match this filter"
  articlesConnection_NONE: JournalistArticlesConnectionWhere
  articlesConnection_NOT: JournalistArticlesConnectionWhere @deprecated(reason : "Use `articlesConnection_NONE` instead.")
  "Return Journalists where one of the related JournalistArticlesConnections match this filter"
  articlesConnection_SINGLE: JournalistArticlesConnectionWhere
  "Return Journalists where some of the related JournalistArticlesConnections match this filter"
  articlesConnection_SOME: JournalistArticlesConnectionWhere
  "Return Journalists where all of the related Articles match this filter"
  articles_ALL: ArticleWhere
  "Return Journalists where none of the related Articles match this filter"
  articles_NONE: ArticleWhere
  articles_NOT: ArticleWhere @deprecated(reason : "Use `articles_NONE` instead.")
  "Return Journalists where one of the related Articles match this filter"
  articles_SINGLE: ArticleWhere
  "Return Journalists where some of the related Articles match this filter"
  articles_SOME: ArticleWhere
}

input PDFImageConnectInput {
  featuredIn: [ImageFeaturedInConnectFieldInput!]
}

input PDFImageConnectOrCreateInput {
  featuredIn: [ImageFeaturedInConnectOrCreateFieldInput!]
}

input PDFImageCreateInput {
  featuredIn: ImageFeaturedInFieldInput
  url: String!
}

input PDFImageDeleteInput {
  featuredIn: [ImageFeaturedInDeleteFieldInput!]
}

input PDFImageDisconnectInput {
  featuredIn: [ImageFeaturedInDisconnectFieldInput!]
}

input PDFImageFeaturedInAggregateInput {
  AND: [PDFImageFeaturedInAggregateInput!]
  NOT: PDFImageFeaturedInAggregateInput
  OR: [PDFImageFeaturedInAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PDFImageFeaturedInNodeAggregationWhereInput
}

input PDFImageFeaturedInNodeAggregationWhereInput {
  AND: [PDFImageFeaturedInNodeAggregationWhereInput!]
  NOT: PDFImageFeaturedInNodeAggregationWhereInput
  OR: [PDFImageFeaturedInNodeAggregationWhereInput!]
  id_EQUAL: ID @deprecated(reason : "Aggregation filters that are not relying on an aggregating function will be deprecated.")
}

input PDFImageOptions {
  limit: Int
  offset: Int
  "Specify one or more PDFImageSort objects to sort PdfImages by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [PDFImageSort!]
}

input PDFImageRelationInput {
  featuredIn: [ImageFeaturedInCreateFieldInput!]
}

"Fields to sort PdfImages by. The order in which sorts are applied is not guaranteed when specifying many fields in one PDFImageSort object."
input PDFImageSort {
  url: SortDirection
}

input PDFImageUpdateInput {
  featuredIn: [ImageFeaturedInUpdateFieldInput!]
  url: String
}

input PDFImageWhere {
  AND: [PDFImageWhere!]
  NOT: PDFImageWhere
  OR: [PDFImageWhere!]
  featuredIn: ArticleWhere @deprecated(reason : "Use `featuredIn_SOME` instead.")
  featuredInAggregate: PDFImageFeaturedInAggregateInput
  featuredInConnection: ImageFeaturedInConnectionWhere @deprecated(reason : "Use `featuredInConnection_SOME` instead.")
  "Return PDFImages where all of the related ImageFeaturedInConnections match this filter"
  featuredInConnection_ALL: ImageFeaturedInConnectionWhere
  "Return PDFImages where none of the related ImageFeaturedInConnections match this filter"
  featuredInConnection_NONE: ImageFeaturedInConnectionWhere
  featuredInConnection_NOT: ImageFeaturedInConnectionWhere @deprecated(reason : "Use `featuredInConnection_NONE` instead.")
  "Return PDFImages where one of the related ImageFeaturedInConnections match this filter"
  featuredInConnection_SINGLE: ImageFeaturedInConnectionWhere
  "Return PDFImages where some of the related ImageFeaturedInConnections match this filter"
  featuredInConnection_SOME: ImageFeaturedInConnectionWhere
  "Return PDFImages where all of the related Articles match this filter"
  featuredIn_ALL: ArticleWhere
  "Return PDFImages where none of the related Articles match this filter"
  featuredIn_NONE: ArticleWhere
  featuredIn_NOT: ArticleWhere @deprecated(reason : "Use `featuredIn_NONE` instead.")
  "Return PDFImages where one of the related Articles match this filter"
  featuredIn_SINGLE: ArticleWhere
  "Return PDFImages where some of the related Articles match this filter"
  featuredIn_SOME: ArticleWhere
  url: String
  url_CONTAINS: String
  url_ENDS_WITH: String
  url_IN: [String!]
  url_NOT: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  url_NOT_CONTAINS: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  url_NOT_ENDS_WITH: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  url_NOT_IN: [String!] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  url_NOT_STARTS_WITH: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  url_STARTS_WITH: String
}

input TextBlockCreateInput {
  text: String
}

input TextBlockOptions {
  limit: Int
  offset: Int
  "Specify one or more TextBlockSort objects to sort TextBlocks by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [TextBlockSort!]
}

"Fields to sort TextBlocks by. The order in which sorts are applied is not guaranteed when specifying many fields in one TextBlockSort object."
input TextBlockSort {
  id: SortDirection
  text: SortDirection
}

input TextBlockUpdateInput {
  text: String
}

input TextBlockWhere {
  AND: [TextBlockWhere!]
  NOT: TextBlockWhere
  OR: [TextBlockWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_CONTAINS: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_ENDS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_IN: [ID] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_NOT_STARTS_WITH: ID @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  id_STARTS_WITH: ID
  text: String
  text_CONTAINS: String
  text_ENDS_WITH: String
  text_IN: [String]
  text_NOT: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  text_NOT_CONTAINS: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  text_NOT_ENDS_WITH: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  text_NOT_IN: [String] @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  text_NOT_STARTS_WITH: String @deprecated(reason : "Negation filters will be deprecated, use the NOT operator to achieve the same behavior")
  text_STARTS_WITH: String
}

----

'''
