:toc:
:toclevels: 42

= lower case type names

== should generate a valid schema

.Schema
[source,graphql,schema=true]
----
type movie {
  name: String
  year: Int
  createdAt: DateTime
  testId: String
  actors: [actor!]! @relationship(type: "ACTED_IN", direction: IN)
}

type actor {
  name: String
  year: Int
  createdAt: DateTime
  movies: [movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

.Augmented Schema
[source,graphql,augmented=true]
----
schema {
  query: Query
}

type ActorsConnection {
  edges: [actorEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type MoviesConnection {
  edges: [movieEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"Pagination information (Relay)"
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  actors(options: actorOptions, where: actorWhere): [actor!]!
  actorsConnection(after: String, first: Int, sort: [actorSort], where: actorWhere): ActorsConnection!
  movies(options: movieOptions, where: movieWhere): [movie!]!
  moviesConnection(after: String, first: Int, sort: [movieSort], where: movieWhere): MoviesConnection!
}

type actor {
  createdAt: DateTime
  movies(directed: Boolean = true, options: movieOptions, where: movieWhere): [movie!]!
  moviesConnection(after: String, directed: Boolean = true, first: Int, sort: [actorMoviesConnectionSort!], where: actorMoviesConnectionWhere): actorMoviesConnection!
  name: String
  year: Int
}

type actorEdge {
  cursor: String!
  node: actor!
}

type actorMoviesConnection {
  edges: [actorMoviesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type actorMoviesRelationship {
  cursor: String!
  node: movie!
}

type movie {
  actors(directed: Boolean = true, options: actorOptions, where: actorWhere): [actor!]!
  actorsConnection(after: String, directed: Boolean = true, first: Int, sort: [movieActorsConnectionSort!], where: movieActorsConnectionWhere): movieActorsConnection!
  createdAt: DateTime
  name: String
  testId: String
  year: Int
}

type movieActorsConnection {
  edges: [movieActorsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type movieActorsRelationship {
  cursor: String!
  node: actor!
}

type movieEdge {
  cursor: String!
  node: movie!
}

"An enum for sorting in either ascending or descending order."
enum SortDirection {
  "Sort by field values in ascending order."
  ASC
  "Sort by field values in descending order."
  DESC
}

"A date and time, represented as an ISO-8601 string"
scalar DateTime

input actorMoviesConnectionSort {
  node: movieSort
}

input actorMoviesConnectionWhere {
  AND: [actorMoviesConnectionWhere!]
  NOT: actorMoviesConnectionWhere
  OR: [actorMoviesConnectionWhere!]
  node: movieWhere
}

input actorOptions {
  limit: Int
  offset: Int
  "Specify one or more actorSort objects to sort Actors by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [actorSort!]
}

"Fields to sort Actors by. The order in which sorts are applied is not guaranteed when specifying many fields in one actorSort object."
input actorSort {
  createdAt: SortDirection
  name: SortDirection
  year: SortDirection
}

input actorWhere {
  AND: [actorWhere!]
  NOT: actorWhere
  OR: [actorWhere!]
  createdAt: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_IN: [DateTime]
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  "Return actors where all of the related actorMoviesConnections match this filter"
  moviesConnection_ALL: actorMoviesConnectionWhere
  "Return actors where none of the related actorMoviesConnections match this filter"
  moviesConnection_NONE: actorMoviesConnectionWhere
  "Return actors where one of the related actorMoviesConnections match this filter"
  moviesConnection_SINGLE: actorMoviesConnectionWhere
  "Return actors where some of the related actorMoviesConnections match this filter"
  moviesConnection_SOME: actorMoviesConnectionWhere
  "Return actors where all of the related movies match this filter"
  movies_ALL: movieWhere
  "Return actors where none of the related movies match this filter"
  movies_NONE: movieWhere
  "Return actors where one of the related movies match this filter"
  movies_SINGLE: movieWhere
  "Return actors where some of the related movies match this filter"
  movies_SOME: movieWhere
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_STARTS_WITH: String
  year: Int
  year_GT: Int
  year_GTE: Int
  year_IN: [Int]
  year_LT: Int
  year_LTE: Int
}

input movieActorsConnectionSort {
  node: actorSort
}

input movieActorsConnectionWhere {
  AND: [movieActorsConnectionWhere!]
  NOT: movieActorsConnectionWhere
  OR: [movieActorsConnectionWhere!]
  node: actorWhere
}

input movieOptions {
  limit: Int
  offset: Int
  "Specify one or more movieSort objects to sort Movies by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [movieSort!]
}

"Fields to sort Movies by. The order in which sorts are applied is not guaranteed when specifying many fields in one movieSort object."
input movieSort {
  createdAt: SortDirection
  name: SortDirection
  testId: SortDirection
  year: SortDirection
}

input movieWhere {
  AND: [movieWhere!]
  NOT: movieWhere
  OR: [movieWhere!]
  "Return movies where all of the related movieActorsConnections match this filter"
  actorsConnection_ALL: movieActorsConnectionWhere
  "Return movies where none of the related movieActorsConnections match this filter"
  actorsConnection_NONE: movieActorsConnectionWhere
  "Return movies where one of the related movieActorsConnections match this filter"
  actorsConnection_SINGLE: movieActorsConnectionWhere
  "Return movies where some of the related movieActorsConnections match this filter"
  actorsConnection_SOME: movieActorsConnectionWhere
  "Return movies where all of the related actors match this filter"
  actors_ALL: actorWhere
  "Return movies where none of the related actors match this filter"
  actors_NONE: actorWhere
  "Return movies where one of the related actors match this filter"
  actors_SINGLE: actorWhere
  "Return movies where some of the related actors match this filter"
  actors_SOME: actorWhere
  createdAt: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_IN: [DateTime]
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_STARTS_WITH: String
  testId: String
  testId_CONTAINS: String
  testId_ENDS_WITH: String
  testId_IN: [String]
  testId_STARTS_WITH: String
  year: Int
  year_GT: Int
  year_GTE: Int
  year_IN: [Int]
  year_LT: Int
  year_LTE: Int
}

----
