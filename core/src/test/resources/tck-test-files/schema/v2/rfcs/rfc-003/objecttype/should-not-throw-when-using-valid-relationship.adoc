:toc:

= schema/rfc/003 -> ObjectType -> should not throw when using valid relationship

== Source schema

[source,graphql,schema=true]
----
type Source {
  targets: [Target!]! @relationship(type: "HAS_TARGET", direction: OUT)
  target1: SecondTarget! @relationship(type: "HAS_TARGET", direction: OUT)
  target2: ThirdTarget @relationship(type: "HAS_TARGET", direction: OUT)
}

type Target {
  id: ID @id @unique
}

type SecondTarget {
  id: ID @id @unique
}

type ThirdTarget {
  id: ID @id @unique
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

"""
Information about the number of nodes and relationships created during a create mutation
"""
type CreateInfo {
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateSecondTargetsMutationResponse {
  info: CreateInfo!
  secondTargets: [SecondTarget!]!
}

type CreateSourcesMutationResponse {
  info: CreateInfo!
  sources: [Source!]!
}

type CreateTargetsMutationResponse {
  info: CreateInfo!
  targets: [Target!]!
}

type CreateThirdTargetsMutationResponse {
  info: CreateInfo!
  thirdTargets: [ThirdTarget!]!
}

"""
Information about the number of nodes and relationships deleted during a delete mutation
"""
type DeleteInfo {
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type IDAggregateSelection {
  longest: ID
  shortest: ID
}

type Mutation {
  createSecondTargets(input: [SecondTargetCreateInput!]!): CreateSecondTargetsMutationResponse!
  createSources(input: [SourceCreateInput!]!): CreateSourcesMutationResponse!
  createTargets(input: [TargetCreateInput!]!): CreateTargetsMutationResponse!
  createThirdTargets(input: [ThirdTargetCreateInput!]!): CreateThirdTargetsMutationResponse!
  deleteSecondTargets(where: SecondTargetWhere): DeleteInfo!
  deleteSources(delete: SourceDeleteInput, where: SourceWhere): DeleteInfo!
  deleteTargets(where: TargetWhere): DeleteInfo!
  deleteThirdTargets(where: ThirdTargetWhere): DeleteInfo!
  updateSecondTargets(update: SecondTargetUpdateInput, where: SecondTargetWhere): UpdateSecondTargetsMutationResponse!
  updateSources(connect: SourceConnectInput, connectOrCreate: SourceConnectOrCreateInput, create: SourceRelationInput, delete: SourceDeleteInput, disconnect: SourceDisconnectInput, update: SourceUpdateInput, where: SourceWhere): UpdateSourcesMutationResponse!
  updateTargets(update: TargetUpdateInput, where: TargetWhere): UpdateTargetsMutationResponse!
  updateThirdTargets(update: ThirdTargetUpdateInput, where: ThirdTargetWhere): UpdateThirdTargetsMutationResponse!
}

"""Pagination information (Relay)"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  secondTargets(options: SecondTargetOptions, where: SecondTargetWhere): [SecondTarget!]!
  secondTargetsAggregate(where: SecondTargetWhere): SecondTargetAggregateSelection!
  secondTargetsConnection(after: String, first: Int, sort: [SecondTargetSort], where: SecondTargetWhere): SecondTargetsConnection!
  sources(options: SourceOptions, where: SourceWhere): [Source!]!
  sourcesAggregate(where: SourceWhere): SourceAggregateSelection!
  sourcesConnection(after: String, first: Int, where: SourceWhere): SourcesConnection!
  targets(options: TargetOptions, where: TargetWhere): [Target!]!
  targetsAggregate(where: TargetWhere): TargetAggregateSelection!
  targetsConnection(after: String, first: Int, sort: [TargetSort], where: TargetWhere): TargetsConnection!
  thirdTargets(options: ThirdTargetOptions, where: ThirdTargetWhere): [ThirdTarget!]!
  thirdTargetsAggregate(where: ThirdTargetWhere): ThirdTargetAggregateSelection!
  thirdTargetsConnection(after: String, first: Int, sort: [ThirdTargetSort], where: ThirdTargetWhere): ThirdTargetsConnection!
}

type SecondTarget {
  id: ID
}

type SecondTargetAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input SecondTargetConnectOrCreateWhere {
  node: SecondTargetUniqueWhere!
}

input SecondTargetConnectWhere {
  node: SecondTargetWhere!
}

input SecondTargetCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

type SecondTargetEdge {
  cursor: String!
  node: SecondTarget!
}

input SecondTargetOnCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input SecondTargetOptions {
  limit: Int
  offset: Int
  """
  Specify one or more SecondTargetSort objects to sort SecondTargets by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [SecondTargetSort!]
}

"""
Fields to sort SecondTargets by. The order in which sorts are applied is not guaranteed when specifying many fields in one SecondTargetSort object.
"""
input SecondTargetSort {
  id: SortDirection
}

input SecondTargetUniqueWhere {
  id: ID
}

input SecondTargetUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input SecondTargetWhere {
  AND: [SecondTargetWhere!]
  NOT: SecondTargetWhere
  OR: [SecondTargetWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
}

type SecondTargetsConnection {
  edges: [SecondTargetEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An enum for sorting in either ascending or descending order."""
enum SortDirection {
  """Sort by field values in ascending order."""
  ASC
  """Sort by field values in descending order."""
  DESC
}

type Source {
  target1(directed: Boolean = true, options: SecondTargetOptions, where: SecondTargetWhere): SecondTarget!
  target1Aggregate(directed: Boolean = true, where: SecondTargetWhere): SourceSecondTargetTarget1AggregationSelection
  target1Connection(after: String, directed: Boolean = true, first: Int, sort: [SourceTarget1ConnectionSort!], where: SourceTarget1ConnectionWhere): SourceTarget1Connection!
  target2(directed: Boolean = true, options: ThirdTargetOptions, where: ThirdTargetWhere): ThirdTarget
  target2Aggregate(directed: Boolean = true, where: ThirdTargetWhere): SourceThirdTargetTarget2AggregationSelection
  target2Connection(after: String, directed: Boolean = true, first: Int, sort: [SourceTarget2ConnectionSort!], where: SourceTarget2ConnectionWhere): SourceTarget2Connection!
  targets(directed: Boolean = true, options: TargetOptions, where: TargetWhere): [Target!]!
  targetsAggregate(directed: Boolean = true, where: TargetWhere): SourceTargetTargetsAggregationSelection
  targetsConnection(after: String, directed: Boolean = true, first: Int, sort: [SourceTargetsConnectionSort!], where: SourceTargetsConnectionWhere): SourceTargetsConnection!
}

type SourceAggregateSelection {
  count: Int!
}

input SourceConnectInput {
  target1: SourceTarget1ConnectFieldInput
  target2: SourceTarget2ConnectFieldInput
  targets: [SourceTargetsConnectFieldInput!]
}

input SourceConnectOrCreateInput {
  target1: SourceTarget1ConnectOrCreateFieldInput
  target2: SourceTarget2ConnectOrCreateFieldInput
  targets: [SourceTargetsConnectOrCreateFieldInput!]
}

input SourceCreateInput {
  target1: SourceTarget1FieldInput
  target2: SourceTarget2FieldInput
  targets: SourceTargetsFieldInput
}

input SourceDeleteInput {
  target1: SourceTarget1DeleteFieldInput
  target2: SourceTarget2DeleteFieldInput
  targets: [SourceTargetsDeleteFieldInput!]
}

input SourceDisconnectInput {
  target1: SourceTarget1DisconnectFieldInput
  target2: SourceTarget2DisconnectFieldInput
  targets: [SourceTargetsDisconnectFieldInput!]
}

type SourceEdge {
  cursor: String!
  node: Source!
}

input SourceOptions {
  limit: Int
  offset: Int
}

input SourceRelationInput {
  target1: SourceTarget1CreateFieldInput
  target2: SourceTarget2CreateFieldInput
  targets: [SourceTargetsCreateFieldInput!]
}

type SourceSecondTargetTarget1AggregationSelection {
  count: Int!
  node: SourceSecondTargetTarget1NodeAggregateSelection
}

type SourceSecondTargetTarget1NodeAggregateSelection {
  id: IDAggregateSelection!
}

input SourceTarget1AggregateInput {
  AND: [SourceTarget1AggregateInput!]
  NOT: SourceTarget1AggregateInput
  OR: [SourceTarget1AggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
}

input SourceTarget1ConnectFieldInput {
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: SecondTargetConnectWhere
}

input SourceTarget1ConnectOrCreateFieldInput {
  onCreate: SourceTarget1ConnectOrCreateFieldInputOnCreate!
  where: SecondTargetConnectOrCreateWhere!
}

input SourceTarget1ConnectOrCreateFieldInputOnCreate {
  node: SecondTargetOnCreateInput!
}

type SourceTarget1Connection {
  edges: [SourceTarget1Relationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input SourceTarget1ConnectionSort {
  node: SecondTargetSort
}

input SourceTarget1ConnectionWhere {
  AND: [SourceTarget1ConnectionWhere!]
  NOT: SourceTarget1ConnectionWhere
  OR: [SourceTarget1ConnectionWhere!]
  node: SecondTargetWhere
}

input SourceTarget1CreateFieldInput {
  node: SecondTargetCreateInput!
}

input SourceTarget1DeleteFieldInput {
  where: SourceTarget1ConnectionWhere
}

input SourceTarget1DisconnectFieldInput {
  where: SourceTarget1ConnectionWhere
}

input SourceTarget1FieldInput {
  connect: SourceTarget1ConnectFieldInput
  connectOrCreate: SourceTarget1ConnectOrCreateFieldInput
  create: SourceTarget1CreateFieldInput
}

type SourceTarget1Relationship {
  cursor: String!
  node: SecondTarget!
}

input SourceTarget1UpdateConnectionInput {
  node: SecondTargetUpdateInput
}

input SourceTarget1UpdateFieldInput {
  connect: SourceTarget1ConnectFieldInput
  connectOrCreate: SourceTarget1ConnectOrCreateFieldInput
  create: SourceTarget1CreateFieldInput
  delete: SourceTarget1DeleteFieldInput
  disconnect: SourceTarget1DisconnectFieldInput
  update: SourceTarget1UpdateConnectionInput
  where: SourceTarget1ConnectionWhere
}

input SourceTarget2AggregateInput {
  AND: [SourceTarget2AggregateInput!]
  NOT: SourceTarget2AggregateInput
  OR: [SourceTarget2AggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
}

input SourceTarget2ConnectFieldInput {
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: ThirdTargetConnectWhere
}

input SourceTarget2ConnectOrCreateFieldInput {
  onCreate: SourceTarget2ConnectOrCreateFieldInputOnCreate!
  where: ThirdTargetConnectOrCreateWhere!
}

input SourceTarget2ConnectOrCreateFieldInputOnCreate {
  node: ThirdTargetOnCreateInput!
}

type SourceTarget2Connection {
  edges: [SourceTarget2Relationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input SourceTarget2ConnectionSort {
  node: ThirdTargetSort
}

input SourceTarget2ConnectionWhere {
  AND: [SourceTarget2ConnectionWhere!]
  NOT: SourceTarget2ConnectionWhere
  OR: [SourceTarget2ConnectionWhere!]
  node: ThirdTargetWhere
}

input SourceTarget2CreateFieldInput {
  node: ThirdTargetCreateInput!
}

input SourceTarget2DeleteFieldInput {
  where: SourceTarget2ConnectionWhere
}

input SourceTarget2DisconnectFieldInput {
  where: SourceTarget2ConnectionWhere
}

input SourceTarget2FieldInput {
  connect: SourceTarget2ConnectFieldInput
  connectOrCreate: SourceTarget2ConnectOrCreateFieldInput
  create: SourceTarget2CreateFieldInput
}

type SourceTarget2Relationship {
  cursor: String!
  node: ThirdTarget!
}

input SourceTarget2UpdateConnectionInput {
  node: ThirdTargetUpdateInput
}

input SourceTarget2UpdateFieldInput {
  connect: SourceTarget2ConnectFieldInput
  connectOrCreate: SourceTarget2ConnectOrCreateFieldInput
  create: SourceTarget2CreateFieldInput
  delete: SourceTarget2DeleteFieldInput
  disconnect: SourceTarget2DisconnectFieldInput
  update: SourceTarget2UpdateConnectionInput
  where: SourceTarget2ConnectionWhere
}

type SourceTargetTargetsAggregationSelection {
  count: Int!
  node: SourceTargetTargetsNodeAggregateSelection
}

type SourceTargetTargetsNodeAggregateSelection {
  id: IDAggregateSelection!
}

input SourceTargetsAggregateInput {
  AND: [SourceTargetsAggregateInput!]
  NOT: SourceTargetsAggregateInput
  OR: [SourceTargetsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
}

input SourceTargetsConnectFieldInput {
  """
  Whether or not to overwrite any matching relationship with the new properties.
  """
  overwrite: Boolean! = true
  where: TargetConnectWhere
}

input SourceTargetsConnectOrCreateFieldInput {
  onCreate: SourceTargetsConnectOrCreateFieldInputOnCreate!
  where: TargetConnectOrCreateWhere!
}

input SourceTargetsConnectOrCreateFieldInputOnCreate {
  node: TargetOnCreateInput!
}

type SourceTargetsConnection {
  edges: [SourceTargetsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input SourceTargetsConnectionSort {
  node: TargetSort
}

input SourceTargetsConnectionWhere {
  AND: [SourceTargetsConnectionWhere!]
  NOT: SourceTargetsConnectionWhere
  OR: [SourceTargetsConnectionWhere!]
  node: TargetWhere
}

input SourceTargetsCreateFieldInput {
  node: TargetCreateInput!
}

input SourceTargetsDeleteFieldInput {
  where: SourceTargetsConnectionWhere
}

input SourceTargetsDisconnectFieldInput {
  where: SourceTargetsConnectionWhere
}

input SourceTargetsFieldInput {
  connect: [SourceTargetsConnectFieldInput!]
  connectOrCreate: [SourceTargetsConnectOrCreateFieldInput!]
  create: [SourceTargetsCreateFieldInput!]
}

type SourceTargetsRelationship {
  cursor: String!
  node: Target!
}

input SourceTargetsUpdateConnectionInput {
  node: TargetUpdateInput
}

input SourceTargetsUpdateFieldInput {
  connect: [SourceTargetsConnectFieldInput!]
  connectOrCreate: [SourceTargetsConnectOrCreateFieldInput!]
  create: [SourceTargetsCreateFieldInput!]
  delete: [SourceTargetsDeleteFieldInput!]
  disconnect: [SourceTargetsDisconnectFieldInput!]
  update: SourceTargetsUpdateConnectionInput
  where: SourceTargetsConnectionWhere
}

type SourceThirdTargetTarget2AggregationSelection {
  count: Int!
  node: SourceThirdTargetTarget2NodeAggregateSelection
}

type SourceThirdTargetTarget2NodeAggregateSelection {
  id: IDAggregateSelection!
}

input SourceUpdateInput {
  target1: SourceTarget1UpdateFieldInput
  target2: SourceTarget2UpdateFieldInput
  targets: [SourceTargetsUpdateFieldInput!]
}

input SourceWhere {
  AND: [SourceWhere!]
  NOT: SourceWhere
  OR: [SourceWhere!]
  target1: SecondTargetWhere
  target1Aggregate: SourceTarget1AggregateInput
  target1Connection: SourceTarget1ConnectionWhere
  target1Connection_NOT: SourceTarget1ConnectionWhere
  target1_NOT: SecondTargetWhere
  target2: ThirdTargetWhere
  target2Aggregate: SourceTarget2AggregateInput
  target2Connection: SourceTarget2ConnectionWhere
  target2Connection_NOT: SourceTarget2ConnectionWhere
  target2_NOT: ThirdTargetWhere
  targetsAggregate: SourceTargetsAggregateInput
  """
  Return Sources where all of the related SourceTargetsConnections match this filter
  """
  targetsConnection_ALL: SourceTargetsConnectionWhere
  """
  Return Sources where none of the related SourceTargetsConnections match this filter
  """
  targetsConnection_NONE: SourceTargetsConnectionWhere
  """
  Return Sources where one of the related SourceTargetsConnections match this filter
  """
  targetsConnection_SINGLE: SourceTargetsConnectionWhere
  """
  Return Sources where some of the related SourceTargetsConnections match this filter
  """
  targetsConnection_SOME: SourceTargetsConnectionWhere
  """Return Sources where all of the related Targets match this filter"""
  targets_ALL: TargetWhere
  """Return Sources where none of the related Targets match this filter"""
  targets_NONE: TargetWhere
  """Return Sources where one of the related Targets match this filter"""
  targets_SINGLE: TargetWhere
  """Return Sources where some of the related Targets match this filter"""
  targets_SOME: TargetWhere
}

type SourcesConnection {
  edges: [SourceEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Target {
  id: ID
}

type TargetAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input TargetConnectOrCreateWhere {
  node: TargetUniqueWhere!
}

input TargetConnectWhere {
  node: TargetWhere!
}

input TargetCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

type TargetEdge {
  cursor: String!
  node: Target!
}

input TargetOnCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input TargetOptions {
  limit: Int
  offset: Int
  """
  Specify one or more TargetSort objects to sort Targets by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TargetSort!]
}

"""
Fields to sort Targets by. The order in which sorts are applied is not guaranteed when specifying many fields in one TargetSort object.
"""
input TargetSort {
  id: SortDirection
}

input TargetUniqueWhere {
  id: ID
}

input TargetUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input TargetWhere {
  AND: [TargetWhere!]
  NOT: TargetWhere
  OR: [TargetWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
}

type TargetsConnection {
  edges: [TargetEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ThirdTarget {
  id: ID
}

type ThirdTargetAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input ThirdTargetConnectOrCreateWhere {
  node: ThirdTargetUniqueWhere!
}

input ThirdTargetConnectWhere {
  node: ThirdTargetWhere!
}

input ThirdTargetCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

type ThirdTargetEdge {
  cursor: String!
  node: ThirdTarget!
}

input ThirdTargetOnCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ThirdTargetOptions {
  limit: Int
  offset: Int
  """
  Specify one or more ThirdTargetSort objects to sort ThirdTargets by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ThirdTargetSort!]
}

"""
Fields to sort ThirdTargets by. The order in which sorts are applied is not guaranteed when specifying many fields in one ThirdTargetSort object.
"""
input ThirdTargetSort {
  id: SortDirection
}

input ThirdTargetUniqueWhere {
  id: ID
}

input ThirdTargetUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ThirdTargetWhere {
  AND: [ThirdTargetWhere!]
  NOT: ThirdTargetWhere
  OR: [ThirdTargetWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_STARTS_WITH: ID
}

type ThirdTargetsConnection {
  edges: [ThirdTargetEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
Information about the number of nodes and relationships created and deleted during an update mutation
"""
type UpdateInfo {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateSecondTargetsMutationResponse {
  info: UpdateInfo!
  secondTargets: [SecondTarget!]!
}

type UpdateSourcesMutationResponse {
  info: UpdateInfo!
  sources: [Source!]!
}

type UpdateTargetsMutationResponse {
  info: UpdateInfo!
  targets: [Target!]!
}

type UpdateThirdTargetsMutationResponse {
  info: UpdateInfo!
  thirdTargets: [ThirdTarget!]!
}
----

'''
