:toc:

= Translator Tests

== Schema

[source,graphql,schema=true]
----
type Person {
  name: String
  age: Int
  livesIn : Location @relation(name:"LIVES_IN", direction: OUT)
  livedIn : [Location] @relation(name:"LIVED_IN", direction: OUT)
  born : Birth
  died : Death
  location: _Neo4jPoint
}
interface Temporal {
  date: String
}
type Birth implements Temporal @relation(name:"BORN") {
  from: Person
  to: Location
  date: String
}
type Death implements Temporal @relation(name:"DIED",from:"who",to:"where") {
  who: Person
  where: Location
  date: String
}
interface Location {
  name: String
  founded: Person @relation(name:"FOUNDED", direction: IN)
}
type City implements Location {
  name: String
  founded: Person @relation(name:"FOUNDED", direction: IN)
  city_Arg: String
}
type Village implements Location {
  name: String
  founded: Person @relation(name:"FOUNDED", direction: IN)
  villageArg: String
}
# enum _PersonOrdering { name_asc, name_desc, age_asc, age_desc }
enum E { pi, e }
type Query {
  person : [Person]
  personByName(name:String) : Person
}
----

== Tests

=== order by query single

.GraphQL-Query
[source,graphql]
----
 { person:person(orderBy:[name_asc]) { age } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .age } AS person ORDER BY person.name ASC
----

=== rich relationship

.GraphQL-Query
[source,graphql]
----
{ person { name born { date to { name } } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, born:[(person)-[personBorn:BORN]->(personBornTo:Location) | personBorn { .date, to:personBornTo { .name } }][0] } AS person
----

=== nested query multi

.GraphQL-Query
[source,graphql]
----
{ person { name age livedIn { name } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, .age, livedIn:[(person)-[:LIVED_IN]->(personLivedIn:Location) | personLivedIn { .name }] } AS person
----

=== inline fragment

.GraphQL-Query
[source,graphql]
----
 query { person { ... on Person { name } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name } AS person
----

=== simple query offset

.GraphQL-Query
[source,graphql]
----
 { person:person(offset:3) { age } }
----

.Cypher params
[source,json]
----
{
  "person_offset" : 3
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.age
} AS person SKIP $person_offset
----

=== query offset as variable

.GraphQL-Query
[source,graphql]
----
query getPersons($offset: Int){
  person(offset: $offset) {
    age
  }
}
----

.Query variables
[source,json,request=true]
----
{
  "offset": 10
}
----

.Cypher params
[source,json]
----
{
  "offset" : 10
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.age
} AS person SKIP $offset
----

=== nested query

.GraphQL-Query
[source,graphql]
----
{ person { name age livesIn { name } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, .age, livesIn:[(person)-[:LIVES_IN]->(personLivesIn:Location) | personLivesIn { .name }][0] } AS person
----

=== simple query

.GraphQL-Query
[source,graphql]
----
{ person { name age } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.name,
	.age
} AS person
----

=== named fragment

.GraphQL-Query
[source,graphql]
----
 query { person { ...name } } fragment name on Person { name }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name } AS person
----

=== rich relationship custom field names

.GraphQL-Query
[source,graphql]
----
{ person { name died { date where { name } } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, died:[(person)-[personDied:DIED]->(personDiedWhere:Location) | personDied { .date, where:personDiedWhere { .name } }][0] } AS person
----

=== rich relationship 2nd hop

.GraphQL-Query
[source,graphql]
----
{ person { name born { date to { name founded { name } } } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
  .name,
  born:[(person)-[personBorn:BORN]->(personBornTo:Location) | personBorn {
    .date,
    to:personBornTo {
      .name,
      founded:[(personBornTo)<-[:FOUNDED]-(personBornToFounded:Person) | personBornToFounded {
        .name
      }][0]
    }
  }][0]
} AS person
----

=== rich relationship 3 rd hop

.GraphQL-Query
[source,graphql]
----
{ person { name born { date to { name founded { name born { date to { name } } } } } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, born:[(person)-[personBorn:BORN]->(personBornTo:Location) | personBorn { .date, to:personBornTo { .name, founded:[(personBornTo)<-[:FOUNDED]-(personBornToFounded:Person) | personBornToFounded { .name, born:[(personBornToFounded)-[personBornToFoundedBorn:BORN]->(personBornToFoundedBornTo:Location) | personBornToFoundedBorn { .date, to:personBornToFoundedBornTo { .name } }][0] }][0] } }][0] } AS person
----

=== nested query parameter

.GraphQL-Query
[source,graphql]
----
{ person { name age livesIn(name:"Berlin") { name } } }
----

.Cypher params
[source,json]
----
{
  "personLivesIn_name" : "Berlin"
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.name,
	.age,
	livesIn: [(person)-[:LIVES_IN]->(personLivesIn:Location) WHERE personLivesIn.name = $personLivesIn_name | personLivesIn {
		.name
	}][0]
} AS person
----

=== order by query two

.GraphQL-Query
[source,graphql]
----
 { person:person(orderBy:[age_desc, name_asc]) { age } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .age } AS person ORDER BY person.age DESC, person.name ASC
----

=== order by with underscore

.GraphQL-Query
[source,graphql]
----
 { location(orderBy:[city_Arg_desc]) { name } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (location: Location)
RETURN location { .name } AS location
ORDER BY location.city_Arg DESC
----

=== named fragment multi field

.GraphQL-Query
[source,graphql]
----
  fragment details on Person { name, age } query { person { ...details } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, .age } AS person
----

=== simple query alias

.GraphQL-Query
[source,graphql]
----
 { foo:person {
     n:name
   }
 }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (foo:Person) RETURN foo { n:foo.name } AS foo
----

=== simple query first

.GraphQL-Query
[source,graphql]
----
 { person:person(first:2) { age } }
----

.Cypher params
[source,json]
----
{
  "person_first" : 2
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.age
} AS person LIMIT $person_first
----

=== simple query where

.GraphQL-Query
[source,graphql]
----
 { person:personByName(name:"Joe") { age } }
----

.Cypher params
[source,json]
----
{
  "person_name" : "Joe"
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
WHERE person.name = $person_name
RETURN person {
	.age
} AS person
----

=== nested query slice offset

.GraphQL-Query
[source,graphql]
----
{ person { livedIn(offset:3) { name } } }
----

.Cypher params
[source,json]
----
{
  "personLivedIn_offset" : 3
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	livedIn: [(person)-[:LIVED_IN]->(personLivedIn:Location) | personLivedIn {
		.name
	}][$personLivedIn_offset..]
} AS person
----

=== nested query slice first

.GraphQL-Query
[source,graphql]
----
{ person { livedIn(first:2) { name } } }
----

.Cypher params
[source,json]
----
{
  "personLivedIn_first" : 2
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	livedIn: [(person)-[:LIVED_IN]->(personLivedIn:Location) | personLivedIn {
		.name
	}][0..$personLivedIn_first]
} AS person
----

=== nested query 2 nd hop

.GraphQL-Query
[source,graphql]
----
{ person { name age livesIn { name founded {name}} } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, .age, livesIn:[(person)-[:LIVES_IN]->(personLivesIn:Location) | personLivesIn { .name, founded:[(personLivesIn)<-[:FOUNDED]-(personLivesInFounded:Person) | personLivesInFounded { .name }][0] }][0] } AS person
----

=== inline fragment multi fields

.GraphQL-Query
[source,graphql]
----
query { person { ... on Person { name,age } } }
----

.Cypher params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (person:Person) RETURN person { .name, .age } AS person
----

=== simple query first offset

.GraphQL-Query
[source,graphql]
----
 { person:person(first:2,offset:3) { age } }
----

.Cypher params
[source,json]
----
{
  "person_first" : 2,
  "person_offset" : 3
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.age
} AS person SKIP $person_offset LIMIT $person_first
----

=== nested query slice first offset

.GraphQL-Query
[source,graphql]
----
{ person { livedIn(first:2,offset:3) { name } } }
----

.Cypher params
[source,json]
----
{
  "personLivedIn_first" : 2,
  "personLivedIn_offset" : 3
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	livedIn: [(person)-[:LIVED_IN]->(personLivedIn:Location) | personLivedIn {
		.name
	}][$personLivedIn_offset..($personLivedIn_offset + $personLivedIn_first)]
} AS person
----

=== nested query slice first offset

.GraphQL-Query
[source,graphql]
----
{ location { name __typename } }
----

.Cypher params
[source,json]
----
{
  "location_validTypes" : [ "City", "Village" ]
}
----

.Cypher
[source,cypher]
----
MATCH (location:Location)
RETURN location {
	.name,
	__typename: head([label IN labels(location) WHERE label IN $location_validTypes])
} AS location
----

=== introspection

.GraphQL-Query
[source,graphql]
----
{
  person {
    name
    __typename
    born {
      __typename
    }
  }
}
----

.Cypher params
[source,json]
----
{
  "person_validTypes" : [ "Person" ]
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
RETURN person {
	.name,
	__typename: head([label IN labels(person) WHERE label IN $person_validTypes]),
	born: [(person)-[personBorn:BORN]->(personBornTo:Location) | personBorn {
		__typename: 'Birth'
	}][0]
} AS person
----

=== inline fragments on interfaces

.GraphQL-Query
[source,graphql]
----
{
  location {
    name
    __typename
    ... on City {
      city_Arg
    }
    ... on Village {
      villageArg
    }
  }
}
----

.Cypher params
[source,json]
----
{
  "location_validTypes" : [ "City", "Village" ]
}
----

.Cypher
[source,cypher]
----
MATCH (location:Location)
RETURN location {
	.name,
	__typename: head([label IN labels(location) WHERE label IN $location_validTypes]),
	.city_Arg,
	.villageArg
} AS location
----

=== fragments on interfaces

.GraphQL-Query
[source,graphql]
----
query {
  location {
    ...details
  }
}
fragment details on Location {
  name
  __typename
  ... on City {
    city_Arg
  }
  ... on Village {
    villageArg
  }
}
----

.Cypher params
[source,json]
----
{
  "location_validTypes" : [ "City", "Village" ]
}
----

.Cypher
[source,cypher]
----
MATCH (location:Location)
RETURN location {
	.name,
	__typename: head([label IN labels(location) WHERE label IN $location_validTypes]),
	.city_Arg,
	.villageArg
} AS location
----

=== query spatial types

.GraphQL-Query
[source,graphql]
----
query {
  person(location:{longitude: 1, latitude: 2 }){
    name
    location {
      crs
      longitude
      latitude
      height
    }
  }
}
----

.Cypher params
[source,json]
----
{
  "person_location_AND1_longitude" : 1,
  "person_location_AND2_latitude" : 2
}
----

.Cypher
[source,cypher]
----
MATCH (person:Person)
WHERE (person.location.longitude = $person_location_AND1_longitude
	AND person.location.latitude = $person_location_AND2_latitude)
RETURN person {
	.name,
	location:  {
		crs: person.location.crs,
		longitude: person.location.longitude,
		latitude: person.location.latitude,
		height: person.location.height
	}
} AS person
----

=== mutate spatial types

.GraphQL-Query
[source,graphql]
----
mutation{
  createPerson(name:"Test2", location:{x: 1, y: 2, z: 3, crs: "wgs-84-3d"}){
    name
    location{
      crs
      srid
      latitude
      longitude
      height
    }
  }
}
----

.Cypher params
[source,json]
----
{
  "createPerson_location" : {
    "x" : 1,
    "y" : 2,
    "z" : 3,
    "crs" : "wgs-84-3d"
  },
  "createPerson_name" : "Test2"
}
----

.Cypher
[source,cypher]
----
CREATE (createPerson:Person  {
	name: $createPerson_name,
	location: point($createPerson_location)
})
WITH createPerson
RETURN createPerson {
	.name,
	location:  {
		crs: createPerson.location.crs,
		srid: createPerson.location.srid,
		latitude: createPerson.location.latitude,
		longitude: createPerson.location.longitude,
		height: createPerson.location.height
	}
} AS createPerson
----
