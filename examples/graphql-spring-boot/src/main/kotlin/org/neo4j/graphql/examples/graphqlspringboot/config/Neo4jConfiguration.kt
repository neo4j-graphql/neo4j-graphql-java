package org.neo4j.graphql.examples.graphqlspringboot.config

import graphql.language.VariableReference
import graphql.schema.*
import org.neo4j.driver.v1.AuthTokens
import org.neo4j.driver.v1.Config
import org.neo4j.driver.v1.Driver
import org.neo4j.driver.v1.GraphDatabase
import org.neo4j.graphql.Cypher
import org.neo4j.graphql.DataFetchingInterceptor
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.math.BigDecimal
import java.math.BigInteger

/**
 * Configuration of the neo4j driver and the DataFetchingInterceptor
 */
@Configuration
@EnableConfigurationProperties(Neo4jProperties::class)
open class Neo4jConfiguration {

    @ConditionalOnMissingBean
    @Bean(destroyMethod = "close")
    open fun driver(neo4jProp: Neo4jProperties): Driver {
        return GraphDatabase.driver(
                neo4jProp.uri,
                AuthTokens.basic(neo4jProp.username, neo4jProp.password),
                Config.build().withoutEncryption().build()
        )
    }

    /**
     * This interceptor is bound to all the graphql fields generated by the neo4j-graphql-library.
     * Its purpose is the execution of the cypher query and the transformation of the query result.
     */
    @Bean
    open fun dataFetchingInterceptor(driver: Driver): DataFetchingInterceptor {
        return object : DataFetchingInterceptor {
            override fun fetchData(env: DataFetchingEnvironment, delegate: DataFetcher<Cypher>): Any? {

                val cypher = delegate.get(env)

                return driver.session().writeTransaction<Any> { tx ->
                    val boltParams = cypher.params.mapValues { toBoltValue(it.value, env.variables) }
                    val result = tx.run(cypher.query, boltParams)
                    val key = result.keys().stream().findFirst().orElse(null)
                    if (isListType(cypher.type)) {
                        result.list()
                            .map { record -> record.get(key).asObject() }
                    } else {
                        result.list()
                            .map { record -> record.get(key).asObject() }
                            .firstOrNull() ?: emptyMap<String, Any>()
                    }
                }
            }
        }
    }

    companion object {
        private fun toBoltValue(value: Any?, params: Map<String, Any?>) = when (value) {
            is VariableReference -> params[value.name]
            is BigInteger -> value.longValueExact()
            is BigDecimal -> value.toDouble()
            else -> value
        }

        private fun isListType(type: GraphQLType?): Boolean = when (type) {
            is GraphQLList -> true
            is GraphQLNonNull -> isListType(type.wrappedType)
            else -> false
        }
    }
}
