= JVM Library to translate GraphQL queries and mutations to Neo4j's Cypher
:version: 2.0.0-alpha
:toc:
:toclevels: 1
:toc-title: Quick Links

NOTE: This is a https://neo4j.com/labs/[Neo4j Labs Project^], it is not supported by Neo4j engineering or support and developed on a best-effort basis.
It is also not functionally equivalent to the https://github.com/neo4j/graphql[neo4j-graphql (Javascript) library and API^] even as we try to stay close to it.
Please use the official library for a JavaScript based GraphQL Middleware for production use-cases.

This is a https://graphql.org[GraphQL] to https://neo4j.com/developer/cypher[Cypher] transpiler written in Kotlin.

License: Apache 2.

== How does it work

This library

1. uses a GraphQL schema definition that is annotated with and concrete neo4j-graphql-java directives to generate a schema that is augmented with additional query fields and mutations.
2. generates a Graphql schema that uses special data-fetchers that translate the GraphQL queries and mutations into Cypher queries and runs these queries against a Neo4j database.

The database to be used can be configured when creating the Schema via the `SchemaBuilder` by providing a concrete `Neo4jAdapter` implementation.

NOTE: All the <<features,supported features>> are listed and explained below, more detailed docs will be added in time.

== Examples

For complex examples take a look at our link:examples/readme.adoc[example projects]

== API compatibility to @neo4j/graphql

Since the javascript pendant of this library (neo4j-graphql-js) has majored into a neo4j product, we want to migrate our augmented schema, to match as much as possible to the one of the https://github.com/neo4j/graphql[`@neo4j/graphql`].
Therefore, we created a https://github.com/neo4j-graphql/neo4j-graphql-java/issues?q=label%3AAPI-Alignment[list of issues to track progress].

== FAQ

=== How does this relate to the other neo4j graphql libraries?

https://grandstack.io[The GRANDstack^] is a full-stack package that integrates React frontends via GraphQL through `neo4j-graphql-js` with Neo4j.

Similar to https://grandstack.io/docs/neo4j-graphql-js-quickstart[`neo4j-graphql-js`] this library focuses on query translation, just for the *JVM* instead of Node.js.
It does not provide a server (except as examples) or other facilities but is meant to be used as a dependency included for a single purpose.

We plan to replace the code in the current Neo4j server plugin `neo4j-graphql` with a single call to this library.
The server plugin could still exist as an example that shows how to handle request-response and error-handling, and perhaps some minimal schema management but be slimmed down to a tiny piece of code.

=== How does this related to graphql-java

This library uses `graphql-java` under the hood for parsing of schema and queries, and managing the GraphQL state and context.
But *not for nested field resolvers or data fetching*.

If you wanted, you could combine `graphql-java` resolvers with this library to have a part of your schema handled by Neo4j.

Thanks a lot to the maintainers of `graphql-java` for the awesome library.

NOTE: We also use `neo4j-opencypher-dsl` provided graciously by the spring-data-neo4j-rx project to generate our cypher queries.

== Usage

You can use the library as dependency: `org.neo4j:neo4j-graphql-java:{version}` in any JVM program.

The basic usage should be:

[source,kotlin]
----
    val driver: Driver = GraphDatabase.driver(
        "bolt://localhost",
        AuthTokens.basic("neo4j", "test")
    )
    val neo4jAdapter = Neo4jDriverAdapter(driver, Neo4jAdapter.Dialect.NEO4J_5)

    @Language("GraphQL") val sdl = """
        type Movie {
          movieId: ID!
          title: String
        }
    """.trimIndent()

    val schema = SchemaBuilder.buildSchema(sdl, neo4jAdapter = neo4jAdapter)
    val graphql = GraphQL.newGraphQL(schema).build()
    val movies = graphql.execute("{ movies { title }}")
    println(movies.toSpecification())

// generates and executes the following cypher:
//  "MATCH (this:Movie) RETURN this { .title } AS this"
----

You find more usage examples in the:

* link:core/src/test/resources/tck-test-files/cypher/v2[Cypher TCK Tests]
* link:core/src/test/resources/tck-test-files/schema/v2[Schema TCK Tests]

== Demo

You can use the link:core/src/test/kotlin/demo/GraphQLServer.kt[GraphQL Demo Server] to play around with the library.
It is running against a Neo4j instance at `bolt://localhost` (username: `neo4j`, password: `test`) containing the `:play movies` graph.

Use http://localhost:4567/graphql as your GraphQL URL.

It uses a schema of:

[source,graphql]
----
type Person {
  name: ID!
  born: Int
  actedIn: [Movie] @relationship(type:"ACTED_IN", direction: OUT)
}
type Movie {
  title: ID!
  released: Int
  tagline: String
}
----

And can run queries like:

[source,graphql]
----
{
    people(options: {limit: 3}) {
    name
    born
    actedIn(options: {limit: 2}) {
      title
    }
  }
}
----

You can also test it with `curl`

----
curl -XPOST http://localhost:4567/graphql -d'{"query":"{people {name}}"}'
----

== Advanced Queries

.Filter, Sorting, Paging support
----
{
  people(where: {name_STARTS_WITH: "L"}, options: { sort: [{name: ASC}], limit: 5, offset: 2} ) {
    name
    born
    actedIn(options: {limit: 1}) {
      title
    }
  }
}
----

----
{
  people(where: {name_STARTS_WITH: "J", born_GTE: 1970}, options: { limit: 2} ) {
    name
    born
    actedIn(options: {limit: 1}) {
      title
    }
  }
}
----

[[features]]
== Features

=== Current

* querying nodes, interfaces and unions
* querying connections

* resolve query fields via result types
* handle arguments as equality comparisons for top level and nested fields
* handle relationships via @relation directive on schema fields
* @relation directive on types for rich relationships (from, to fields for start & end node)
* handle first, offset arguments
* argument types: string, int, float, array
* request parameter support
* parametrization for cypher query
* aliases
* inline and named fragments
* auto-generate query fields for all objects
* @cypher directive for fields to compute field values, support arguments
* @cypher directive for top level queries and mutations, supports arguments
* @cypher directives can have a  `passThrough:true` argument, that gives sole responsibility for the nested query result for this field to your Cypher query.
You will have to provide all data/structure required by client queries.
Otherwise, we assume if you return object-types that you will return the appropriate nodes from your statement.
* auto-generate mutation fields for all objects to create, update, delete
* date(time)
* interfaces
* complex filter parameters, with optional query optimization strategy
* scalars
* spatial
* skip limit params
* sorting (nested)
* ignoring fields

=== Next

* input types
* unions

== Documentation

=== Parse SDL schema

* Currently, schemas with object types, enums, fragments and Query types are parsed and handled.
* `@relationship` directives on fields and types for rich relationships
* The configurable augmentation auto-generates queries for all types.
* Supports the built-in scalars for GraphQL.
* For arguments input types in many places and filters from GraphCool/Prisma.

=== Resolve query Fields via Result Types

For _query fields_ that result in object types (even if wrapped in list/non-null), the appropriate object type is determined via the schema and used to translate the query.

e.g.

[source,graphql]
----
type Query {
  person: [Person]
}
# query "person" is resolved to and via "Person"

type Person {
  name : String
}
----

=== Neo4j 5.x support

This library supports queries for both neo4j `4.x` and `5.x`.
The Dialect is seth through the used `Neo4jAdapter` implementation.


=== Handle Relationships via @relationship Directive on Schema Fields

If you want to represent a relationship from the graph in GraphQL you have to add a `@relation` directive which contains the relationship-type and the direction.
The default direction for a relationship is 'OUT'.
Other values are 'IN' and 'BOTH'.
So you can use different domain names in your GraphQL fields that are independent of your graph model.

[source,graphql]
----
type Person {
  name : String
  actedIn: [Movie] @relationship(type:"ACTED_IN", direction:OUT)
}
----

[source,graphql]
----
people(where: {name:"Keanu Reeves"}) {
  name
  actedIn {
    title
  }
}
----

=== Handle pagination

To support pagination `limit` is translated to `LIMIT` in Cypher and `offset` into `SKIP`
For nested queries these are converted into slices for arrays.

[source,graphql]
----
{
  people(options: { limit: 10, offset: 5 }) {
    name
  }
}
----

[source,cypher]
----
MATCH (person:Person) RETURN person { .name }  AS person SKIP 5 LIMIT 10
----

=== Argument Types: string, int, float, array

The default Neo4j Cypher types are handled both as argument types as well as field types.

=== Parameter Support

GraphQL parameters are passed onto Cypher, these are resolved correctly when used within the GraphQL query.

=== Parametrization

For query injection prevention and caching purposes, literal values are translated into parameters.

[source,graphql]
----
{
  people(where: {name:"Joe", born_GT: 1942}, options: { limit: 10 }) {
   name
  }
}
----

to

[source,cypher]
----
MATCH (this:Person)
WHERE (this.name = $param0
	AND this.born > $param1)
WITH * LIMIT $param2
RETURN this {
	.name
} AS this
----

=== Aliases

We support query aliases, they are used as Cypher aliases too, so you get them back as keys in your result records.

For example:

[source,graphql]
----
{
  jane: people(where: {name:"Jane"}) { name, born }
  joe: people(where: {name:"Joe"}) { name, born }
}
----

=== Inline and Named Fragments

This is more of a technical feature, both types of fragments are resolved internally.

=== Sorting (top-level)

We support sorting via the `options::sort` argument, which takes an array of sort items each defining the filed and the direction to sort by.

[source,graphql]
----
{
  people(options: { sort:  [{name: ASC}, {born: DESC}]}) {
    name
    born
  }
}
----

[source,cypher]
----
MATCH (this:Person)
WITH * ORDER BY this.name ASC, this.born DESC
RETURN this {
	.name,
	.born
} AS this
----

=== Handle Rich Relationships via @relationship Directive on Schema Types

To represent rich relationship types with properties, a `@relationship` directive is supported on an object type.

In our example it would be the `Role` type.

[source,graphql]
----
type Role @relationshipProperties {
   roles: [String]
}
type Person {
  name: String
  born: Int
  movies: [Movie] @relationship(type:"ACTED_IN", direction: OUT, properties: Role)
}
type Movie {
  title: String
  released: Int
  characters: [Person] @relationship(type:"ACTED_IN", direction: IN, properties: Role)
}
----

[source,graphql]
----
{
    people(where: {name:"Keanu Reeves"} ){
      moviesConnection {
        edges {
          properties {
            roles
          }
          node {
            title
          }
        }
      }
    }
}
----

[[filters]]
=== Filters

Filters are a powerful way of selecting a subset of data.
Inspired by the https://www.graph.cool/docs/reference/graphql-api/query-api-nia9nushae[graph.cool/Prisma filter approach^], our filters work the same way.

These filters are documented in detail in the https://neo4j.com/docs/graphql/current/queries-aggregations/filtering/[Neo4j GraphQL Library].

[source,graphql]
----
{ company(where: { AND: { name_CONTAINS: "Ne", country_IN: ["SE"]}}) { name } }
----

You can also apply nested filter on relations, which use suffixes like `("",not,some, none, single, every)`

[source,graphql]
----
{ Company(filter: {
    employees_NONE { name_contains: "Jan"},
    employees_SOME: { gender_IN : [female]},
    NOT: { company: null } })
    {
      name
    }
}
----

=== Inline and Named Fragments

We support inline and named fragments according to the GraphQL spec.
Most of this is resolved on the parser/query side.

.Named Fragment
[source,graphql]
----
fragment details on Person { name, email, dob }
query {
  person {
    ...details
  }
}
----

.Inline Fragment
[source,graphql]
----
query {
  person {
    ... on Person { name, email, dob }
  }
}
----

=== Auto Generated Queries and Mutations

To reduce the amount of boilerplate code you have to write, we auto-generate generate top-level CRUD queries and mutations for all types.

This is configurable via https://neo4j.com/docs/graphql/current/directives/#_schema_configuration[directives].

Please consult the link:core/src/test/resources/tck-test-files/schema/v2/[Augmentation Tests] to see all currently supported features.

== Build-time schema augmentation

Sometimes you need the possibility to generate the augmented schema at compile time.
To achieve this, we provide a maven plugin which can be used as follows:

[source,xml,subs="attributes,verbatim"]
----
<plugin>
    <groupId>org.neo4j</groupId>
    <artifactId>neo4j-graphql-augmented-schema-generator-maven-plugin</artifactId>
    <version>{version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-schema</goal>
            </goals>
            <configuration>
                <schemaConfig> <!--1-->
                    <features>
                        <String>
                            <MATCHES>true</MATCHES>
                        </String>
                    </features>
                </schemaConfig>
                <outputDirectory>${project.build.directory}/augmented-schema</outputDirectory>
                <fileset> <!--2-->
                    <directory>${project.basedir}/src/main/resources</directory>
                    <include>*.graphql</include>
                </fileset>
            </configuration>
        </execution>
    </executions>
</plugin>
----

<1> Use the same configuration as for your SchemaBuilder
<2> Define the source schema for which you want to have an augmented schema generated

Take a look at the link:./examples/dgs-spring-boot/readme.adoc[spring boot dsg] example for a use case of this plugin, where it is used in combination with a code generator to have a type save graphql API
