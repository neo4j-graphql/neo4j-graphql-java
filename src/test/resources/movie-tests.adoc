:toc:

= Movie Test TCK

== Schema

[source,graphql,schema=true]
----
type Movie {
  _id: String
  movieId: ID!
  title: String
  year: Int
  released: Int # was DateTime
  plot: String
  poster: String
  imdbRating: Float
  genres: [Genre] @relation(name: "IN_GENRE", direction: OUT)
  similar(first: Int = 3, offset: Int = 0): [Movie] @cypher(statement: "MATCH (this)--(:Genre)--(o:Movie) RETURN o")
  mostSimilar: Movie @cypher(statement: "RETURN this")
  degree: Int @cypher(statement: "RETURN SIZE((this)--())")
  actors(first: Int = 3, offset: Int = 0, name: String): [Actor] @relation(name: "ACTED_IN", direction:IN)
  avgStars: Float
  filmedIn: State @relation(name: "FILMED_IN", direction: OUT)
  scaleRating(scale: Int = 3): Float @cypher(statement: "RETURN $scale * this.imdbRating")
  scaleRatingFloat(scale: Float = 1.5): Float @cypher(statement: "RETURN $scale * this.imdbRating")
  actorMovies: [Movie] @cypher(statement: """
  MATCH (this)-[:ACTED_IN*2]-(other:Movie)
  RETURN other
  """)
  publishedBy: Publisher @relation(name: "PUBLISHED_BY", direction: OUT)
  ratings: [Rated]
}
type Publisher {
  name: ID!
}
type Genre {
  _id: String!
  name: ID!
  movies(first: Int = 3, offset: Int = 0): [Movie] @relation(name: "IN_GENRE", direction: IN)
  highestRatedMovie: Movie @cypher(statement: "MATCH (m:Movie)-[:IN_GENRE]->(this) RETURN m ORDER BY m.imdbRating DESC LIMIT 1")
}
type State {
  name: String
}
#interface Person {
#  userId: ID!
#  name: String
#}
type Actor # implements Person
{
  userId: ID!
  name: String
  movies: [Movie] @relation(name: "ACTED_IN", direction:OUT)
  born: _Neo4jDateTime
}
type User # implements Person
{
  userId: ID!
  name: String
  rated(rating: Int): [Rated]
  friends(since: Int): [FriendOf]
  knows: [User] @relation(name: "KNOWS", direction:OUT)
  born: _Neo4jDateTime
}
type FriendOf {
  from: User
  since: Int
  to: User
}
type Rated @relation(name:"RATED") {
  from: User
  rating: Int
  to: Movie
}
enum BookGenre {
  Mystery,
  Science,
  Math
}
type Book {
  genre: BookGenre
}
# enum _MovieOrdering {
#   title_desc,
#   title_asc
# }
# enum _GenreOrdering {
#   name_desc,
#   name_asc
# }
type Query {
  Movie(_id: String, movieId: ID, title: String, year: Int, plot: String, poster: String, imdbRating: Float, first: Int, offset: Int, orderBy: _MovieOrdering): [Movie]
  MoviesByYear(year: Int): [Movie]
  MovieById(movieId: ID!): Movie
  MovieBy_Id(_id: String!): Movie
  GenresBySubstring(substring: String): [Genre] @cypher(statement: "MATCH (g:Genre) WHERE toLower(g.name) CONTAINS toLower($substring) RETURN g")
  Books: [Book]
  User: [User]
}
type Mutation {
  createGenre(name:String): Genre @cypher(statement:"CREATE (g:Genre) SET g.name = name RETURN g")
}
# scalar DateTime
----

== Queries

=== Top Level Query

.Query
[source,graphql]
----
query {
  Movie {
    movieId
  }
}
----

.Params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)
RETURN movie { .movieId } AS movie
----

=== Query Single Object

.Query
[source,graphql]
----
{
  MovieById(movieId: "18") {
    title
  }
}
----

.Params
[source,json]
----
{
  "movieByIdMovieId": "18"
}
----

.Cypher
[source,cypher]
----
MATCH (movieById:Movie)
WHERE movieById.movieId = $movieByIdMovieId
RETURN movieById { .title } AS movieById
----

=== Basic Query with Parameter

.Query
[source,graphql]
----
{  Movie(title: "River Runs Through It, A")  {  title }  }
----
.Params
[source,json]
----
{
  "movieTitle": "River Runs Through It, A"
}
----
.Cypher
[source,cypher]
----
MATCH (movie:Movie)
WHERE  movie.title = $movieTitle  
RETURN movie { .title } AS movie
----

=== Paging

.Query
[source,graphql]
----
{
  Movie(title: "River Runs Through It, A", first: 1, offset: 1) {
    title
    year
  }
}
----

.Params
[source,json]
----
{"movieTitle": "River Runs Through It, A"}
----


.Cypher
[source,cypher]
----
MATCH (movie:Movie) 
WHERE movie.title = $movieTitle 
RETURN movie { .title, .year } AS movie 
SKIP 1 LIMIT 1
----

=== Query Single Relation

.Query
[source,graphql]
----
{
  MovieById(movieId: "3100") {
    title
    filmedIn {
      name
    }
  }
}
----

.Params
[source,json]
----
{
  "movieByIdMovieId": "3100"
}
----


.Cypher
[source,cypher]
----
MATCH (movieById:Movie) 
WHERE movieById.movieId = $movieByIdMovieId 
RETURN movieById {
  .title,
  filmedIn:[(movieById)-[:FILMED_IN]->(movieByIdFilmedIn:State) | movieByIdFilmedIn { .name }][0]
} AS movieById
----

=== Query Single Object and Array of Object Relations

.Query
[source,graphql]
----
{
  MovieById(movieId: "3100") {
    title
    actors {
      name
    }
    filmedIn{
      name
    }
  }
}
----

.Params
[source,json]
----
{
  "movieByIdMovieId": "3100"
}
----


.Cypher
[source,cypher]
----
MATCH (movieById:Movie) 
WHERE movieById.movieId = $movieByIdMovieId 
RETURN movieById {
  .title,
  actors:[(movieById)<-[:ACTED_IN]-(movieByIdActors:Actor) | movieByIdActors { .name }],
  filmedIn:[(movieById)-[:FILMED_IN]->(movieByIdFilmedIn:State) | movieByIdFilmedIn { .name }][0]
} AS movieById
----

=== Relationship Expansion

.Query
[source,graphql]
----
{
  Movie(title: "River Runs Through It, A") {
    title
    actors {
      name
    }
  }
}
----

.Params
[source,json]
----
{
  "movieTitle": "River Runs Through It, A"
}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)  
WHERE movie.title = $movieTitle 
RETURN movie {
  .title,
  actors:[(movie)<-[:ACTED_IN]-(movieActors:Actor) | movieActors { .name }]
} AS movie
----

=== Projection with sub-paging

.Query
[source,graphql]
----
{
  Movie(title: "River Runs Through It, A") {
    title
    actors(first:3) {
      name
    }
  }
}
----

.Params
[source,json]
----
{
  "movieTitle": "River Runs Through It, A"
}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)  
WHERE movie.title = $movieTitle 
RETURN movie {
  .title,
  actors:[(movie)<-[:ACTED_IN]-(movieActors:Actor) | movieActors { .name }][0..3]
} AS movie
----

=== Subquery Cypher Directive

.Query
[source,graphql]
----
{
  Movie {
    title
    similar {
      title
    }
  }
}
----

.Cypher Params
[source,json]
----
{
  "movieFirst":3,
  "movieOffset":0
}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)  
RETURN movie {
  .title,
  similar:[movieSimilar
    IN apoc.cypher.runFirstColumnMany('WITH $this AS this, $first AS first, $offset AS offset MATCH (this)--(:Genre)--(o:Movie) RETURN o', {
        this:movie,
        first:$movieFirst,
        offset:$movieOffset
      }) | movieSimilar {
        .title
      }]
} AS movie
----

=== Subquery Cypher Directive Paging

.Query
[source,graphql]
----
{
  Movie {
    title
    similar(first:3) {
      title
    }
  }
}
----

.Cypher Params
[source,json]
----
{
  "movieFirst":3,
  "movieOffset":0
}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)
RETURN movie {
  .title,
  similar:[movieSimilar
    IN apoc.cypher.runFirstColumnMany('WITH $this AS this, $first AS first, $offset AS offset MATCH (this)--(:Genre)--(o:Movie) RETURN o', {
      this:movie,
      first:$movieFirst,
      offset:$movieOffset
    }) | movieSimilar {
      .title
    }][0..3]
} AS movie
----

=== Handle Cypher Directive on Query Type

.Query
[source,graphql]
----
{
  GenresBySubstring(substring:"Action") {
    name
    movies(first: 3) {
      title
    }
  }
}
----

.Params
[source,json]
----
{
  "genresBySubstringSubstring": "Action"
}
----

.Cypher
[source,cypher]
----
UNWIND apoc.cypher.runFirstColumnMany('WITH $substring AS substring MATCH (g:Genre) WHERE toLower(g.name) CONTAINS toLower($substring) RETURN g', { substring:$genresBySubstringSubstring }) AS genresBySubstring
RETURN genresBySubstring {
  .name,
  movies:[(genresBySubstring)<-[:IN_GENRE]-(genresBySubstringMovies:Movie) | genresBySubstringMovies { .title }][0..3]
} AS genresBySubstring
----

=== Handle Cypher directive on Mutation type

.Query
[source,graphql]
----
mutation someMutation {
  createGenre(name: "Wildlife Documentary") {
    name
  }
}
----

.Params
[source,json]
----
{
  "createGenreName": "Wildlife Documentary"
}
----

.Cypher
[source,cypher]
----
CALL apoc.cypher.doIt('WITH $name AS name CREATE (g:Genre) SET g.name = name RETURN g', { name:$createGenreName }) YIELD value
WITH value[head(keys(value))] AS createGenre
RETURN createGenre { .name } AS createGenre
----

=== Query using Inline Fragment

.Query
[source,graphql]
----
{
  Movie(title: "River Runs Through It, A") {
    title
    ratings {
      rating
      from {
        ... on User {
          name
          userId
        }
      }
    }
  }
}
----

.Params
[source,json]
----
{
  "movieTitle": "River Runs Through It, A"
}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)
WHERE movie.title = $movieTitle
RETURN movie {
  .title,
  ratings:[(movie)<-[movieRatings:RATED]-(movieRatingsFrom:User) | movieRatings {
    .rating,
    from:movieRatingsFrom { .name, .userId }
  }]
} AS movie
----

=== Deeply nested object query

.Query
[source,graphql]
----
{
  Movie(title: "River Runs Through It, A") {
    title
    actors {
      name
      movies {
        title
        actors(name: "Tom Hanks") {
          name
          movies {
            title
            year
            similar(first: 3) {
              title
              year
            }
          }
        }
      }
    }
  }
}
----

.Params
[source,json]
----
{
  "movieTitle": "River Runs Through It, A", 
  "movieActorsMoviesActorsName": "Tom Hanks", 
  "movieActorsMoviesActorsMoviesFirst": 3, 
  "movieActorsMoviesActorsMoviesOffset": 0
}
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie)
WHERE movie.title = $movieTitle
RETURN movie { .title, actors:[(movie)<-[:ACTED_IN]-(movieActors:Actor) |
       movieActors { .name, movies:[(movieActors)-[:ACTED_IN]->(movieActorsMovies:Movie) |
         movieActorsMovies { .title, actors:[(movieActorsMovies)<-[:ACTED_IN]-(movieActorsMoviesActors:Actor)
           WHERE movieActorsMoviesActors.name = $movieActorsMoviesActorsName |
             movieActorsMoviesActors { .name, movies:[(movieActorsMoviesActors)-[:ACTED_IN]->(movieActorsMoviesActorsMovies:Movie) |
               movieActorsMoviesActorsMovies { .title, .year, similar:[movieActorsMoviesActorsMoviesSimilar
                 IN apoc.cypher.runFirstColumnMany('WITH $this AS this, $first AS first, $offset AS offset MATCH (this)--(:Genre)--(o:Movie) RETURN o', { this:movieActorsMoviesActorsMovies, first:$movieActorsMoviesActorsMoviesFirst, offset:$movieActorsMoviesActorsMoviesOffset }) |
                   movieActorsMoviesActorsMoviesSimilar { .title,.year }][0..3] }] }] }] }] } AS movie
----

=== Should merge an actor by the userId

.Query
[source,graphql]
----
mutation {
  actor: mergeActor(userId: "1", name: "Andrea") {
    name
  }
}
----

.Params
[source,json]
----
{
  "actorUserId": "1", 
  "actorName": "Andrea"
}
----

.Cypher
[source,cypher]
----
MERGE (actor:Actor { userId: $actorUserId })
SET actor.name = $actorName
WITH actor
RETURN actor { .name } AS actor
----

=== Should auto generate `add` relationship mutations for arrays

.Query
[source,graphql]
----
mutation {
  add: addMovieGenres(movieId: 1, genres: ["Action", "Fantasy"]) {
    title
  }
}
----

.Params
[source,json]
----
{
  "movieId": 1,
  "genres": [
    "Action", 
    "Fantasy"
  ]
}
----

.Cypher
[source,cypher]
----
MATCH (from:Movie { movieId: $movieId })
MATCH (to:Genre)
WHERE to.name IN $genres
MERGE (from)-[r:IN_GENRE]->(to)
WITH DISTINCT from
RETURN from { .title } AS movie
----

=== Should auto generate `delete` relationship mutations for arrays

.Query
[source,graphql]
----
mutation {
  del: deleteMovieGenres(movieId: 1, genres: ["Action", "Fantasy"]) {
    title
  }
}
----

.Params
[source,json]
----
{"movieId": 1, "genres": ["Action", "Fantasy"]}
----

.Cypher
[source,cypher]
----
MATCH (from:Movie {movieId:$movieId})
MATCH (to:Genre)
WHERE to.name IN $genres
MATCH (from)-[r:IN_GENRE]->(to)
DELETE r
WITH DISTINCT from
RETURN from { .title } AS movie
----

=== Should auto generate `add` relationship mutations

.Query
[source,graphql]
----
mutation {
  add: addMoviePublishedBy(movieId: 1, publishedBy: "Company") {
    title
  }
}
----

.Params
[source,json]
----
{"movieId": 1, "publishedBy": "Company"}
----

.Cypher
[source,cypher]
----
MATCH (from:Movie {movieId:$movieId})
MATCH (to:Publisher)
WHERE to.name = $publishedBy
MERGE (from)-[r:PUBLISHED_BY]->(to)
WITH DISTINCT from
RETURN from { .title } AS movie
----

=== Should auto generate `delete` relationship mutations

.Query
[source,graphql]
----
mutation {
  del: deleteMoviePublishedBy(movieId: 1, publishedBy: "Company") {
    title
  }
}
----

.Params
[source,json]
----
{"movieId": 1, "publishedBy": "Company"}
----

.Cypher
[source,cypher]
----
MATCH (from:Movie {movieId:$movieId})
MATCH (to:Publisher)
WHERE to.name = $publishedBy
MATCH (from)-[r:PUBLISHED_BY]->(to)
DELETE r
WITH DISTINCT from
RETURN from { .title } AS movie
----

=== Should auto generate `add` recursive relationship mutations for arrays

.Query
[source,graphql]
----
mutation {
  add: addUserKnows(userId: 1, knows: [10, 23]) {
    name
  }
}
----

.Params
[source,json]
----
{"userId": 1, "knows": [10, 23]}
----

.Cypher
[source,cypher]
----
MATCH (from:User {userId:$userId})
MATCH (to:User)
WHERE to.userId IN $knows
MERGE (from)-[r:KNOWS]->(to)
WITH DISTINCT from
RETURN from { .name } AS user
----

== Order By

=== Descending, top level

.Query
[source,graphql]
----
{
  Movie(year: 2010, orderBy:title_desc, first: 10) {
    title
  }
}
----

.Params
[source,json]
----
{"movieYear":  2010 }
----

.Cypher
[source,cypher]
----
MATCH (movie:Movie) 
WHERE movie.year = $movieYear 
RETURN movie { .title } AS movie 
ORDER BY movie.title DESC  
LIMIT 10
----

== Neo4j Data Types queryies


=== User born extraction

.Query
[source,graphql]
----
query {
  User {
    born {
      formatted
      year
    }
  }
}
----

.Params
[source,json]
----
{}
----

.Cypher
[source,cypher]
----
MATCH (user:User)
RETURN user { born: { formatted: user.born, year: user.born.year } } AS user
----

=== User born query filter with multiple fields

.Query
[source,graphql]
----
query {
  User {
    born(formatted: "2015-06-24T12:50:35.556000000+01:00", year: 2015) {
      year
    }
  }
}
----

.Params
[source,json]
----
{"userBornFormatted": "2015-06-24T12:50:35.556000000+01:00", "userBornYear": 2015}
----

.Cypher
[source,cypher]
----
MATCH (user:User)
WHERE user.born = datetime($userBornFormatted) AND user.born.year = $userBornYear
RETURN user { born: { year: user.born.year } } AS user
----

=== Merge Actor with born field formatted

.Query
[source,graphql]
----
mutation {
  actor: mergeActor(userId: "1", name: "Andrea", born: { formatted: "2015-06-24T12:50:35.556000000+01:00" }) {
    name
  }
}
----

.Params
[source,json]
----
{"actorUserId": "1", "actorName": "Andrea", "actorBorn": { "formatted": "2015-06-24T12:50:35.556000000+01:00" }}
----

.Cypher
[source,cypher]
----
MERGE (actor:Actor {userId:$actorUserId}) SET actor.name = $actorName,actor.born = datetime($actorBorn.formatted)
WITH actor
RETURN actor { .name } AS actor
----


=== Create Actor with born field formatted

.Query
[source,graphql]
----
mutation {
  actor: createActor(userId: "1", name: "Andrea", born: { formatted: "2015-06-24T12:50:35.556000000+01:00" }) {
    name
  }
}
----

.Params
[source,json]
----
{"actorUserId": "1", "actorName": "Andrea", "actorBorn": { "formatted": "2015-06-24T12:50:35.556000000+01:00" }}
----

.Cypher
[source,cypher]
----
CREATE (actor:Actor {userId: $actorUserId, name: $actorName, born: datetime($actorBorn.formatted)})
WITH actor
RETURN actor { .name } AS actor
----

=== Merge Actor with born field object

.Query
[source,graphql]
----
mutation {
  actor: mergeActor(userId: "1", name: "Andrea", born: { year: 2018
                                                         month: 11
                                                         day: 23
                                                         hour: 10
                                                         minute: 30
                                                         second: 1
                                                         millisecond: 2
                                                         microsecond: 3
                                                         nanosecond: 4
                                                         timezone: "America/Los_Angeles" }) {
    name
  }
}
----

.Params
[source,json]
----
{"actorUserId": "1", "actorName": "Andrea", "actorBorn": { "year": 2018,
                                                           "month": 11,
                                                           "day": 23,
                                                           "hour": 10,
                                                           "minute": 30,
                                                           "second": 1,
                                                           "millisecond": 2,
                                                           "microsecond": 3,
                                                           "nanosecond": 4,
                                                           "timezone": "America/Los_Angeles" }}
----

.Cypher
[source,cypher]
----
MERGE (actor:Actor {userId:$actorUserId}) SET actor.name = $actorName,actor.born = datetime($actorBorn)
WITH actor
RETURN actor { .name } AS actor
----

=== Create Actor with born field object

.Query
[source,graphql]
----
mutation {
  actor: createActor(userId: "1", name: "Andrea", born: { year: 2018
                                                         month: 11
                                                         day: 23
                                                         hour: 10
                                                         minute: 30
                                                         second: 1
                                                         millisecond: 2
                                                         microsecond: 3
                                                         nanosecond: 4
                                                         timezone: "America/Los_Angeles" }) {
    name
    born {
      year
      month
    }
  }
}
----

.Params
[source,json]
----
{"actorUserId": "1", "actorName": "Andrea", "actorBorn": { "year": 2018,
                                                           "month": 11,
                                                           "day": 23,
                                                           "hour": 10,
                                                           "minute": 30,
                                                           "second": 1,
                                                           "millisecond": 2,
                                                           "microsecond": 3,
                                                           "nanosecond": 4,
                                                           "timezone": "America/Los_Angeles" }}
----

.Cypher
[source,cypher]
----
CREATE (actor:Actor {userId: $actorUserId, name: $actorName, born: datetime($actorBorn)})
WITH actor
RETURN actor { .name,born: { year: actor.born.year, month: actor.born.month } } AS actor
----